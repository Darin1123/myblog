export const ARTICLES = [
    {
        "id": "6faf0d2b-4753-4bab-8a85-1e3a28945d92",
        "title": "Matched Pairs",
        "category": "机器学习",
        "date": { "year": 2022, "month": 4, "day": 17 },
        "peek": "本文介绍了列别数据分析中的 matched pairs",
        "content": "> 2022 年 4 月 16 日\n\n## Matched Pairs\n\n<b style=\"color: #0087fc\">[定义] Matched Pairs</b>\n\nMatched pair 是两个统计意义上相互依赖的两个样本 (sample). 这两个样本有着相同的 response. 两个样本是配对的.\n\n> 通常 matches pairs 会用一个方形的表格表示.\n\n## 例子: 有没有打电话\n\n在 1994 年 7 月分到 1995 年 8 月份, 在多伦多发生了 699 起没有人受伤的车祸. **危险时间段**的定义为在车祸发生之前的十分钟, **控制时间段**的定义为前一天的同一十分钟. \n\n|            | 有打电话 | 没有打电话 | 总计 |\n| ---------- | -------- | ---------- | ---- |\n| 危险时间段 | 170      | 529        | 699  |\n| 控制时间段 | 37       | 662        | 699  |\n\n## Matched Pair Analysis\n\n若果想要对比相互依赖的部分, 可以使用:\n\n- Marginal homogeneity\n- McNemar's test\n\n逻辑斯蒂回归可以用于 binary 的 response.\n\n## 相互依赖的成分对比\n\n在回到之前的例子, 经过变形, 得到新的表格 (不用管是怎么来的.)\n\n|                | 在控制时间段 | 不在控制时间段 |      |\n| -------------- | ------------ | -------------- | ---- |\n| 在危险时间段   | 13           | 157            | 170  |\n| 不在危险时间段 | 24           | 505            | 529  |\n|                | 37           | 662            | 699  |\n\n在这里, 需要对比的是 $170 / 699 = 0.24$ 和 $37 / 699 = 0.05$. \n\n两个成分的差: $0.24 - 0.05 = 0.19$\n\n<b style='color: red'>问题是, 这里的两个成分是相互依赖的.</b>\n\n看一个更加**一般化的表格**\n\n|        | $Y(1)$     | $Y(2)$     |            |\n| ------ | ---------- | ---------- | ---------- |\n| $X(1)$ | $\\pi_{11}$ | $\\pi_{12}$ | $\\pi_{1+}$ |\n| $X(2)$ | $\\pi_{21}$ | $\\pi_{22}$ | $\\pi_{2+}$ |\n|        | $\\pi_{+1}$ | $\\pi_{+2}$ | $1$        |\n\n如果是一般的**列联表**, 那么就是判断 $X$ 和 $Y$ 之间有没有关联. 检查 $\\pi_{11} = \\pi_{1+} \\pi_{+1}$.\n\n但是现在是 **matched pairs**, 那么就对比 Marginal homogeneity. 检查 $\\pi_{1+} = \\pi_{+1}$.\n\n## McMemar 检验\n\n零假设 ($H_0$) : $\\pi_{1+} = \\pi_{+1}$, 即 $\\pi_{12} = \\pi_{21}$.\n\nA假设 ($H_\\alpha$) : $\\pi_{1+} > \\pi_{+1}$, 即 $\\pi_{12} > \\pi_{21}$.\n\n使得 $n^* = n_{12} + n_{21}$, 那么在**零假设**成立的情况下, $n_{12}$ 和 $n_{21}$ 应该各自构成 $n^*$ 的一半.\n$$\nn_{12}\\sim \\textrm{Binomial}(n^*, 0.5).\n$$\n当 $n^*$ 很大的时候, 用正态近似\n$$\nz = \\dfrac {n_{12} - 0.5 n^*}{\\sqrt{n^*(.5)(.5)}} = \\dfrac{n_{12} - n_{21}}{\\sqrt{n_{12} + n_{21}}} \\sim N(0,1)\n$$\n\n$$\nz^2 = \\dfrac {(n_{12} - n_{21})^2}{n_{12} + n_{21}} \\sim \\chi_1^2\n$$\n\n## 在例子中的应用\n\n在之前的例子中, \n\n|                | 在控制时间段 | 不在控制时间段 |      |\n| -------------- | ------------ | -------------- | ---- |\n| 在危险时间段   | 13           | 157            | 170  |\n| 不在危险时间段 | 24           | 505            | 529  |\n|                | 37           | 662            | 699  |\n\n$$\nz = \\dfrac{157 - 24}{\\sqrt{157 + 24}} = 9.89\n$$\n\n此时, $p$-值 $< 0.0001$. 那么可以拒绝零假设, 并**得到结论, 与平时相比, 在发生事故之前使用电话的概率更高**.\n\n现在, 估计成分之间的差:\n$$\np_{1+}- p_{+1}= \\dfrac {170}{699} - \\dfrac {37}{699} = 0.2432 - 0.0529 = 0.1903\n$$\nstandard error:\n$$\nSE = \\dfrac 1n \\sqrt{n_{12} + n_{21} - \\dfrac{(n_{12} - n_{21})^2}{n}}\n$$\n代入数据:\n$$\nSE = \\dfrac 1{699} \\sqrt{157 + 24 - \\dfrac{(157 - 24)^2}{699}} = 0.0179\n$$\n得到 $95\\%$ 的 CI\n$$\n0.1903 \\pm1.96 \\times0.0179 = (0.1553, 0.2253)\n$$\n于是得到入下结论: **在事故前使用手机的概率比平时高 $0.155$ 到 $0.225$.**\n\n## Matched Pair 的逻辑斯蒂回归\n\n### 边缘成分的边缘模型\n\n**第一种模型**是使用 identity link 的模型\n$$\nP(Y_t= 1) = \\alpha+ \\delta x_t, \\qquad x_t = \\begin{cases}1&\\textrm{if } t = 1\\\\0 & \\textrm{if } t = 2\\end{cases}\n$$\n其中, $\\hat{\\delta} = p_{1+} - p _{+1}$.\n\n**如果要使用模型对零假设 $H_0 : \\delta = 0$ 进行验证, 那么可以使用 McNemar 检验**\n$$\nP(Y_1 = 1) = \\alpha\n$$\n\n$$\nP(Y_2 = 1) = \\alpha + \\delta\n$$\n\n**第二种模型**是使用 logit link 的模型\n$$\n\\textrm{logit}[P(Y_t = 1)] = \\alpha + \\beta x_t, \\qquad x_t =\\begin{cases}1&\\textrm{if } t = 1\\\\0 & \\textrm{if } t = 2\\end{cases}\n$$\n其中, $\\hat{\\beta} = \\log \\left(\\dfrac {p_{1+}/p_{2+}}{p_{+1}/p_{+2}}\\right) = \\log \\left(\\dfrac {n_{1+} n_{+2}}{n_{2+} n_{+1}}\\right)$.\n\n\n\n样本边缘分布的对数比值比为\n$$\n\\textrm{logit}[P(Y_1 = 1)] = \\log(p_{1+}/ p_{2+}) = \\alpha\n$$\n\n$$\n\\textrm{logit}[P(Y_2 = 1)] = \\log((p_{1+}/ p_{2+}) = \\alpha + \\beta\n$$\n\n### Cochran-Mantel-Haenszel Test\n\n简称 CMH 检验. **用于 $2 \\times2 \\times K$ 的表格**. 在部分表格 $k$ 中, 行总数为 $\\{n_{1+k}, n_{2+k}\\}$, 列总数为 $\\{n_{+1k}, n_{+2k}\\}$.\n\n在零假设 $H_0$ : $X$ 和 $Y$ 没有关联 下:\n$$\n\\mu_{11k} = \\mathbb{E}[n_{11k}] = \\dfrac {n_{1+k}n_{+1k}}{n_{++k}}\n$$\n \n$$\n\\textrm{Var}(n_{11k}) = \\dfrac {n_{1+k}\\cdot n_{2+k} \\cdot n_{+1k} \\cdot n_{+2k}}{n^2_{++k}\\cdot(n_{++k} - 1)}\n$$\nCMH 重要性\n$$\n\\textrm{CMH}= \\dfrac {\\left[\\sum_k (n_{11k} - \\mu_{11k})\\right]^2}{\\sum_k \\textrm{Var}(n_{11k})},\n$$\n对于大的样本, 大致服从 $\\chi_1^2$ 分布.\n\n### 条件逻辑斯蒂回归\n\n假设有以下模型,\n$$\n\\textrm{logit}[P(Y_{it} = 1)] = \\alpha_i + \\beta x_{it}, \\qquad x_{it} =\\begin{cases}1&\\textrm{if } t = 1\\\\0 & \\textrm{if } t = 2\\end{cases}\n$$\n可以拟合一个基于条件逻辑斯蒂回归模型来规避 strata effects\n$$\n\\begin{aligned}\n&P(y_{i1} = 1, y_{i1} = 0\\, |\\, y_{i1} = 1, y_{i2} = 0 \\textrm{ or }y_{i1} = 0, y_{i2} = 1)\\\\\n= \\quad &\\dfrac {P(y_{i1} = 1)P(y_{i2} = 0)}{P(y_{i1} = 1)P(y_{i2} = 0) + P(y_{i1} = 0)P(y_{i2} = 1)}\\\\\n= \\quad & \\dfrac {e^\\beta}{1 + e ^ \\beta}\n\\end{aligned}\n$$\n**条件概率**为\n$$\nl = \\left[\\dfrac {e^\\beta}{1 + e ^ \\beta}\\right]^{n_{12}}\\left[\\dfrac 1{1 + e ^ \\beta}\\right]^{n_{21}}\n$$\n$\\beta$ 可以通过如下公式获得\n$$\n\\hat\\beta = \\log\\left(\\dfrac {n_{12}}{n_{21}}\\right)\n$$\n\n#### 应用\n\n还是之前的那个例子\n\n|                | 在控制时间段 | 不在控制时间段 |      |\n| -------------- | ------------ | -------------- | ---- |\n| 在危险时间段   | 13           | 157            | 170  |\n| 不在危险时间段 | 24           | 505            | 529  |\n|                | 37           | 662            | 699  |\n\n**边缘模型**: $\\exp(\\hat\\beta) = \\dfrac {170 \\times 662}{529 \\times 37} = 5.75$.\n\n这个意味着, 在事故前使用手机的数量比值大概是在平时使用手机的数量比值的 5.75 倍.\n\n**Conditional model stratified by subject**: $\\exp(\\hat{\\beta}) = \\dfrac {157}{24} = 6.54$.\n\n这意味着, a subject's estimated odds of using a cell phone prior to car accident are 6.54 times the odds during normal time.\n\n## 参考资料\n\nSDSC 8013 课件 - Lec10 match pairs"
    },

    {
        "id": "9ac79f57-5d0e-4d4b-9b3e-c6c7aed3428a",
        "title": "卷积神经网络 - 例子",
        "category": "机器学习",
        "date": { "year": 2022, "month": 4, "day": 14 },
        "peek": "本文介绍了卷积神经网络的具体实现. 这是一个将 cnn 运用于手写数字识别的例子",
        "content": "> 2022 年 4 月 14 日\n\n## 简介\n\n本文介绍了卷积神经网络的具体实现. 源代码出处详见参考资料. 这是一个将 cnn 运用于手写数字识别的例子.\n\n## 导包\n\n```python\nimport numpy as np  # 用于线性代数运算\nimport pandas as pd  # 数据处理, CSV file 读/写\nimport seaborn as sns  # 画图包\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings('ignore')  # ignore warnings\n```\n\n## 导入数据\n\n> 数据文件请访问参考资料中的链接.\n\n```python\n# 读数据\ntrain = pd.read_csv('./data/train.csv')\ntest= pd.read_csv('./data/test.csv')\n```\n\n## 数据预处理\n\n```python\n# 区分标签和特征\ny_train = train['label']\nX_train = train.drop(labels=['label'], axis=1)\n```\n\n```python\n# 标准化数据\nX_train = X_train / 255.0\ntest = test / 255.0\n```\n\n```python\n# reshape\nX_train = X_train.values.reshape(-1, 28, 28, 1)\ntest = test.values.reshape(-1, 28, 28, 1)\n```\n\n```python\n# 标签编码\nfrom keras.utils.np_utils import to_categorical\ny_train = to_categorical(y_train, num_classes = 10)\n```\n\n```python\n# 拆分训练集, 测试集\nfrom sklearn.model_selection import train_test_split\nX_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size=0.1, random_state=2)\n```\n\n## 定义卷积神经网络\n\n```python\nfrom sklearn.metrics import confusion_matrix\nfrom keras.models import Sequential\nfrom keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D\nfrom tensorflow.keras.optimizers import RMSprop, Adam\nfrom keras.preprocessing.image import ImageDataGenerator\n\n\nmodel = Sequential()\nmodel.add(Conv2D(\n    filters=8,\n    kernel_size=(5, 5),\n    padding='Same',\n    activation=\"relu\",\n    input_shape=(28, 28, 1)\n))\nmodel.add(MaxPool2D(pool_size=(2, 2)))\nmodel.add(Dropout(0.25))\nmodel.add(Conv2D(\n    filters=16,\n    kernel_size=(3, 3),\n    padding='Same',\n    activation=\"relu\",\n))\nmodel.add(MaxPool2D(pool_size=(2, 2), strides=(2, 2)))\nmodel.add(Dropout(0.25))\n# fully connected\nmodel.add(Flatten())\nmodel.add(Dense(256, activation=\"relu\"))\nmodel.add(Dropout(0.5))\nmodel.add(Dense(10, activation=\"softmax\"))\n```\n\n```python\n# 定义优化器\noptimizer = Adam(lr=0.001, beta_1=0.9, beta_2=0.999)\n```\n\n```python\n# 编译模型\nmodel.compile(optimizer=optimizer, loss=\"categorical_crossentropy\", metrics=['accuracy'])\n```\n\n```python\n# Epochs and batch size\nepochs = 10\nbatch_size = 250\n```\n\n```python\n# data augmentation\ndatagen = ImageDataGenerator(\n    featurewise_center=False,  # set input mean to 0 over the dataset\n    samplewise_center=False,  # set each sample mean to 0\n    featurewise_std_normalization=False,\n    samplewise_std_normalization=False,\n    zca_whitening=False,\n    rotation_range=5,\n    zoom_range=0.1,\n    width_shift_range=0.1,\n    height_shift_range=0.1,\n    horizontal_flip=False,\n    vertical_flip=False\n)\ndatagen.fit(X_train)\n```\n\n## 训练模型\n\n```python\nhistory = model.fit_generator(\n    datagen.flow(\n        X_train,\n        y_train,\n        batch_size=batch_size\n    ),\n    epochs=epochs,\n    validation_data=(X_val, y_val),\n    steps_per_epoch=X_train.shape[0] // batch_size\n)\n```\n\n## 模型评估\n\n```python\n# evaluate model\nplt.plot(history.history['val_loss'], color='b', label='validation loss')\nplt.title(\"test loss\")\nplt.xlabel('# epochs')\nplt.ylabel('Loss')\nplt.legend()\nplt.show()\n```\n\n得到以下图表:\n\n![cnn-evaluation-result](img/articles/cnn-evaluation-result.png)\n\n## 用模型进行预测\n\n```python\n# Predict the values from the validation dataset\ny_pred = model.predict(X_val)\n# Convert predictions classes to one hot vectors\ny_pred_classes = np.argmax(y_pred,axis = 1)\n# Convert validation observations to one hot vectors\ny_true = np.argmax(y_val,axis = 1)\n# compute the confusion matrix\nconfusion_mtx = confusion_matrix(y_true, y_pred_classes)\n# plot the confusion matrix\nf,ax = plt.subplots(figsize=(8, 8))\nsns.heatmap(confusion_mtx, annot=True, linewidths=0.01,cmap=\"Greens\",linecolor=\"gray\", fmt= '.1f',ax=ax)\nplt.xlabel(\"Predicted Label\")\nplt.ylabel(\"True Label\")\nplt.title(\"Confusion Matrix\")\nplt.show()\n```\n\n得到以下图表:\n\n![cnn-prediction-result](img/articles/cnn-prediction-result.png)\n\n## 参考资料\n\n1. [Convolutional Neural Network (CNN) Tutorial](https://www.kaggle.com/code/kanncaa1/convolutional-neural-network-cnn-tutorial/notebook)\n\n"
    },

    {
        "id": "8965436c-7c24-4a05-ace9-094d6fd35811",
        "title": "卷积神经网络",
        "category": "机器学习",
        "date": { "year": 2022, "month": 4, "day": 10 },
        "peek": "卷积神经网络适合对图数据进行相关计算.",
        "content": "> 2022 年 4 月 10 日\n\n## 简介\n\nCNN (Convolutional Neural Network), 即卷积神经网络, 适合对图数据进行相关计算.  图的数据往往以 3D tensor 的形式表示. \n\n## Tensor\n\nTensor 就是 multi-way array 数据的一般叫法. \n\n一维的 tensor 即是向量, 二维的 tensor 就是一个矩阵, 三维的向量的就是一个立方体...\n\n如图所示:\n\n![tensors](img/articles/tensors.png)\n\n## 图片数据\n\n很容易可以想到, 一张图片是二维的, 但是同时需要注意的一点是, 图片的每个像素往往是通过多个值构成的, 如 RGB. 所以, 对于一张图片而言, 他的数据表示即是 $n$ 个 matrix, 也就是 $n$ 个二维 tensor. 其中这里的 $n$ 指的是通道 (channel) 的数量, 如果每个像素点是有 RGB 三个数值组成的, 那么此时 $n$ 就为 $3$. 如下图所示:\n\n\n\n![image-data-representation](img/articles/image-data-representation.png)\n\n## 卷积神经网络 Convolutional Neural Network\n\ncnn 主要有三个部分组成, 卷积层 (Convolutional layer), 池化层 (Pooling layer), 以及全连接层 (fully-connected layer). 如图所示:\n\n![cnn](img/articles/cnn.png)\n\n\n\n### 卷积层\n\n在卷积层中, 主要做的事情就是对输入的图片进行**局部信息抽取**. 具体地说, 就是用一个过滤器扫描整个图片, 然后汇总过滤器得到的信息. 如下图所示:\n\n![convolution-layer](img/articles/convolution-layer.png)\n\n举一个具体的例子:\n$$\n\\begin{bmatrix}\n1 & 2 & 3 & 1\\\\\n4 & 5 & 6 & 1\\\\\n7 & 8 & 9 & 1\n\\end{bmatrix}\n\\ast \n\\begin{bmatrix}\n1 & 1 \\\\ 1 & 1\n\\end{bmatrix}\n = \n\\begin{bmatrix}\n12 & 16 & 11\\\\\n24 & 28 & 17\n\\end{bmatrix}\n$$\n其中左侧的举证代表图片, 中间的矩阵是过滤器, 得到局部信息(最右侧的矩阵.) 其中具体的计算如下图所示:\n\n![filter-example](img/articles/filter-example-1.png)\n\n再看另外一个具体的例子, 如下图所示\n\n![filter-example-2](img/articles/filter-example-2.png)\n\n这里我们使用的是 sobel filter, \n$$\nK= \n\\begin{pmatrix}\n1 & 0 & -1\\\\\n2 & 0 & -2\\\\\n1 & 0 & -1\n\\end{pmatrix}.\n$$\n\n> 因为这是一个有色彩的图片 (RGB), 所以过滤器其实是  $3\\times3\\times3$ 的, 我们让每一个通道的 $K$ 都为上面所示的过滤器. \n>\n> 这样的 $K$ 可以使得横向的特征非常明显, 见图 (b).\n>\n> 其中 (c) 的过滤器为 $K^\\top$, 他可以使纵向的特征更加突出.\n\n这样得到的结果会传入一个非线性的激活函数\n$$\n\\widetilde{\\mathbf{X}}_{ijk} = \\sigma([O^k]_{ij}), \\quad\\forall\\,i\\in [d_1 - w +1], j\\in[d_2 - w + 1], k \\in [d_3].\n$$\n\n### 池化层\n\n池化层做的事情是把相近的特征聚合成一个值. 比方说一个 $2\\times2$ 的 max-pooling 过滤器的效果如下:\n\n![pooling-example](img/articles/pooling-example.png)\n\n这么做的主要目的在于可以为后续的 layer 减小特征的数量并减少计算量.\n\n### 全连接层\n\n全连接层将输入的 tensor 作为一个向量, 记为 $\\text{vec}(\\mathbf{X})$. 然后计算\n$$\n\\widetilde{\\mathbf{X}} = \\sigma(\\mathbf{W}\\text{vec}(\\mathbf{X})).\n$$\n全连接层主要位于 CNN 的最后几个 layer 中.\n\n### Put All Of Them Together\n\n一个经典的 CNN 如下图所示:\n\n![LeNET-CNN](img/articles/LeNET-CNN.png) \n\n## 参考资料\n\nSDSC 6001 课件 - CNN & RNN\n\n"
    },

    {
        "id": "b43c55c2-a102-4aa9-9d73-43b63f612e01",
        "title": "Git - 如何 '忘记' 已经 add 的文件",
        "category": "Git",
        "date": { "year": 2022, "month": 4, "day": 9 },
        "peek": "有时候我们会错误的将一些不重要的文件通过 `git add` 命令添加到版本控制的历史中, 但是现在想要将他们忘记",
        "content": "> 2022 年 4 月 9 日\n\n## 问题描述\n\n有时候我们会错误的将一些不重要的文件通过 `git add` 命令添加到版本控制的历史中, 但是现在想要将他们 '忘记'. 也就是不删除他们, 仅仅是在历史中将他们删除.\n\n## 解决方法\n\n使用如下命令\n\n```bash\ngit rm --cached <file>\n```\n\n如果想要移除整个文件夹, 那么使用\n\n```bash\ngit rm -r --cached <folder>\n```\n\n## 参考资料\n\n[How can I make Git \"forget\" about a file that was tracked, but is now in .gitignore?](https://stackoverflow.com/questions/1274057/how-can-i-make-git-forget-about-a-file-that-was-tracked-but-is-now-in-gitign)\n\n"
    },

    {
        "id": "9f016fd4-86aa-447e-a6e1-a8bc99e6c84f",
        "title": "R - factor",
        "category": "R",
        "date": { "year": 2022, "month": 4, "day": 7 },
        "peek": "因子用于存储不同类别的数据类型.",
        "content": "> 2022 年 4 月 6 日\n\n## 用途\n\n因子用于存储不同类别的数据类型. (人按性别分有男女, 按年龄分有成年人和未成年人)\n\n## 语法格式$^1$\n\n```r\nfactor(x = character(), levels, labels = levels, \n       exclude = NA, ordered = is.ordered(x), nmax = NA)\n```\n\n参数说明\n\n`x` : 向量\n\n`levels` : 指定各水平值, 不指定时由 `x` 的不同值来求得. \n\n`labels` : 水平的标签. 不指定时用各水平值对应的字符串.\n\n`exclude` : 排除的字符.\n\n`ordered` : 逻辑值, 用于指定水平是否有序.\n\n`nmax` : 水平的上限数量.\n\n## 使用示例$^1$\n\n简单使用\n\n```r\nx <- c('f', 'm', 'f', 'f', 'm')\nsex <- factor(x)\nprint(sex)\n\n# output\n# [1] f m f f m\n# Levels: f m\n```\n\n添加因子水平\n\n```r\nx <- c('f', 'm', 'f', 'f', 'm', levels=c('m', 'f'))\nsex <- factor(x)\nprint(sex)\n\n# output\n#                                         levels1 levels2\n#       f       m       f       f       m       m       f\n# Levels: f m\n```\n\n## 总结 \n\n当在处理类别数据的时候, 可以使用因子.\n\n##  参考资料\n\n1. [R 因子](https://www.runoob.com/r/r-factor.html)\n2. [如何理解R中因子的概念]("
    },

    {
        "id": "d4ab294f-95fa-465d-aa81-1a91118d860f",
        "title": "如何读论文?",
        "category": null,
        "date": { "year": 2022, "month": 4, "day": 3 },
        "peek": "那么在这篇文章中, 就来研究一下如何有效地阅读论文",
        "content": "> 2022 年 4 月 3 日\n\n## 简介\n\n在大学生涯中, 或是工作的需要, 总是不可避免的需要读一些论文. 对于新手来说, 能做到有效地阅读一篇论文是一件很有挑战性的事情. 毕竟方法对了, 做事情那就是事半功倍. 那么在这篇文章中, 就来研究一下如何有效地阅读论文. \n\n本文参考了一篇题为 \"How to read paper\" 的论文.\n\n## 阅读论文的误区\n\n没有经验的读论文会进入一些典型的误区. 最常见的, 就是**纠结于某个细节**, 因为在这个细节上卡住而停滞不前. \n\n## 3-PASS 读法\n\n这里要介绍的是 3-pass 法. 对于一篇论文, 不要从一开始就打算一路用心把他读完, 而是阅读全文三次. 每一遍都有不同的着重点. 在第一遍阅读时, 要了解论文的大致主题. 第二遍的时候要了解论文的基本内容. 最后, 第三遍阅读时要完全理解论文, 包括其中的每一个细节.\n\n### 第一遍\n\n第一遍就是要总览整篇论文, 花费大概五到十分钟. 具体的步骤如下:\n\n1. 认真阅读论文的标题, abstract, introduction.\n2. 阅读各个 section, subsection 的标题, 同时略过其他的内容.\n3. 对于数学的内容, 快速浏览一遍, 对其中的理论基础有一个基本的了解.\n4. 阅读 conclusion.\n5. 阅读 references, 看看有没有已经读过的文献.\n\n在完成上述步骤后, 应该可以掌握一下信息. (作者称之为 5 C's)\n\n1. Category: 这篇论文属于哪个类别.\n2. Context: 这篇论文引用了哪些其他的内容, 有哪些理论基础.\n3. Correctness: 论文中的前提条件是否合理.\n4. Contributions: 这篇论文的主要贡献是什么.\n5. Clarity: 这篇论文写的如何.\n\n 在得到这些信息以后, 就要决定是否要继续阅读这篇论文. \n\n> 不再继续的原因可能是\n>\n> 1. 这篇论文不够吸引你.\n> 2. 这篇论文所涉及的领域对于你来说太遥远.\n> 3. 文中的前提条件有明显的缺陷.\n>\n> ... \n\n### 第二遍\n\n第二遍阅读时, 除了很细节的内容以外, 认真阅读. 在阅读的过程中, 可以做一些笔记, 如划线, 在空白处做标注. 在这遍阅读中, 要认真看其中展示的图表等. \n\n对于一个有经验的人来说, 第二遍可能会花费大概一个小时的时间. 在这遍结束后, 你应该要掌握这篇论文的内容. 第二遍阅读的深度适合于你感兴趣的, 但不是你专注的文章. \n\n### 第三遍\n\n第三遍的目标就是要完全理解这篇论文. 一个好的办法是, 重新实现论文中描述的内容.\n\n## 参考资料\n\n*How to read a paper*, S. Keshav, Feb 17, 2016"
    },

    {
        "id": "4a272b16-78ff-4233-ad9a-20571b0ad068",
        "title": "sklearn 模型的 score 方法",
        "category": "机器学习",
        "date": { "year": 2022, "month": 4, "day": 1 },
        "peek": "本文介绍了 sklearn 库中模型的 score 方法. 主要目的是想了解一下他是如何计算得分的",
        "content": "> 2022 年 4 月 1 日\n\n## 简介\n\n本文介绍了 sklearn 库中模型的 score 方法. 主要目的是想了解一下他是如何计算得分的.\n\n## 官方文档\n\nAPI\n\n```python\nscore(X, y, sample_weight=None)[source]\n```\n\nReturn the coefficient of determination of the prediction.\n\nThe coefficient of determination $R^2$ is defined as $(1−\\dfrac uv)$, where $u$ is the residual sum of squares `((y_true - y_pred)** 2).sum()` and $v$ is the total sum of squares `((y_true - y_true.mean()) ** 2).sum()`. The best possible score is 1.0 and it can be negative (because the model can be arbitrarily worse). A constant model that always predicts the expected value of `y`, disregarding the input features, would get a $R^2$ score of 0.0.\n\n## 解析\n\n从官方文档中可以了解到, 该方法的计算方式为计算 $R^2 = 1 - \\dfrac uv$. \n\n其中 $u$ 为残差的平方和, 即 $\\sum_i (y_i - \\hat{y}_i)^2$.  其中 $y$ 为真实的值, $\\hat{y}$ 是预测的值.\n\n$v = \\sum_i (y_i - \\bar y )^2$.\n\n所以\n$$\nR^2 = 1 - \\dfrac uv = 1 - \\dfrac {\\sum_i (y_i - \\hat{y}_i)^2}{\\sum_i (y_i - \\bar y)^2}.\n$$\n\n## 结论\n\nscore 方法的计算公式如下:\n$$\nR^2 = 1 - \\dfrac uv = 1 - \\dfrac {\\sum_i (y_i - \\hat{y}_i)^2}{\\sum_i (y_i - \\bar y)^2}.\n$$\n其中 $\\hat{y}_i$ 为预测值, $y_i$ 为真实值, $\\bar{y}$ 为真实值的均值.\n\n分数越接近1, 则表示模型性能越优秀.\n\n## 参考资料\n\n[sklearn - LinearRegression](https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LinearRegression.html)\n\n"
    },

    {
        "id": "3041a27b-a54e-4641-90a3-f469bb3899d5",
        "title": "Gaussian Mixture Model",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 31 },
        "peek": "GMM 是一个无监督的学习算法. 顾名思义, Mixture, 它是基于模型 \"混合\" 的一种算法",
        "content": "> 2022 年 3 月 31 日\n\n## 简介\n\nGMM 是一个无监督的学习算法. 顾名思义, Mixture, 它是基于模型 \"混合\" 的一种算法.\n\n假设数据中有 $k$ 个簇族, 每个簇族用一个高斯模型表示, 那么整个数据就是 $k$ 个高斯模型的组合.\n\n## 数学描述\n\n假设有 cluster variable $C\\in \\{1, \\dots, K\\}$, 且有如下假设:\n\n- 如果 $C= k$, 那么 $X$ 的条件分布是**正态**的: $X\\,|\\,C = k \\sim\\phi(X;\\mu_k, \\Sigma_k)$\n- $C$ 满足**多项式分布**, $\\mathbb{P}(C = k) = \\alpha_k,\\quad \\sum_ka_k = 1$\n\n那么有如下模型\n$$\n\\mathbb{P}(C = k \\,|\\,X) = \\dfrac {\\mathbb{P}(X, C = k)}{\\mathbb{P}(X)} = \\dfrac{\\alpha_k\\phi(X;\\mu_k, \\Sigma_k)}{\\textcolor{red}{\\sum_{i=1}^K \\alpha_k\\phi(X; \\mu_i, \\Sigma_i)}}\n$$\n\n> 注意标红的部分就是一系列的高斯模型组合在一起.\n\n见下图$^1$中的例子, 由3个簇族变量构成的混合高斯模型.\n\n![gmm](img/articles/gmm.jpg)\n\n有了基本的模型后就要对其进行训练.\n\n我们的目标是以 $\\theta$ 为参数, 最大化似然函数 $L(\\theta; X) = f(X; \\theta)$.\n\n其中 $f(X; \\theta)$ 是 $X$ 的边缘密度函数, 定义如下:\n$$\nf(X; \\theta) = \\sum_{k=1} ^K \\alpha_k \\phi(X; \\mu_k, \\Sigma_k)\n$$\n这里的位置参数有 $\\theta = (\\mu_1,\\dots,\\mu_K, \\Sigma_1, \\dots, \\Sigma_K, \\alpha_1,\\dots, \\alpha_K)$.\n\n> 这是一个很难处理的情况, 但是可以使用**最大期望算法** (Expectation-Maximization algorithm, 简称 EM 算法) 来解决这个问题.\n\n## 参考资料\n\n1. [浅显易懂的GMM模型及其训练过程](https://blog.csdn.net/sun___shy/article/details/82850751)\n\n2. SDSC 6001 课件"
    },

    {
        "id": "d78ddf4f-999e-480c-a8e5-822624a55dbb",
        "title": "GNN - Message Passing II",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 30 },
        "peek": "本文主要介绍了 C & S 方法. C & S 的全称为 Correct and Smooth",
        "content": "> 2022 年 3 月 30 日\n\n## 简介\n\n本文主要介绍了 C & S 方法. C & S 的全称为 Correct and Smooth. (以下简称 cs/CS) 是用于预测图中未标记结点标记的一种方法. 之前的文章中介绍了另外的两个方法: Relational Classification 和 Iterative Classification.\n\ncs 主要分为三步:\n\n1. 训练 base predictor\n2. 通过 base predictor 计算每个结点的软标签\n3. 通过图的结构, 对预测结果进行后续处理 (post-process), 最终得到对所有结点的合理预测\n\n## 第一步\n\n训练 base predictor. 这个模型可以是十分简单的模型.\n\n![gnn-ii-1](img/articles/gnn-ii-1.png)\n\n## 第二步\n\n通过 base predictor 计算每个结点的软标签\n\n![gnn-ii-2](img/articles/gnn-ii-2.png)\n\n## 第三步\n\n通过图的结构, 对预测结果进行后续处理 (post-process), 最终得到对所有结点的合理预测.\n\n其中后续处理包含两部分, 根据 cs 的这个名字, 分别为 Correct 和 Smooth. 意为纠正和平整.\n\n### Correct\n\n纠正步骤的主要思想就是: 预测错误会顺着图中的边散开. 在下面的图中, 可以观察到绿色圈中的预测结果较为合理, 而红色圈中的预测结果则不能令人满意.\n\n![gnn-ii-3](img/articles/gnn-ii-3.png)\n\n要纠正这种错误, 对所有已有标签的结点计算训练错误 training error. (真实情况减去软标签.)\n\n对于没有标签的结点, 直接设为 $0$.\n\n![gnn-ii-4](img/articles/gnn-ii-4.png)\n\n接下来, 沿着边将错误进行扩散\n$$\n\\mathbf{E}^{(t+1)} \\leftarrow (1 - \\alpha) \\cdot\\mathbf{E}^{(t)} + \\alpha\\cdot \\widetilde{\\mathbf{A}}\\cdot\\mathbf{E}^{(t)}\n$$\n其中 \n\n- $\\alpha$ 是一个超参数.\n- $\\widetilde{\\mathbf{A}}$ 为扩散矩阵 (diffusion matrix), $\\widetilde{\\mathbf{A}} = \\mathbf{D}^{-1/2}\\mathbf{A} \\mathbf{D}^{-1/2}$.\n- $\\mathbf{D} = \\text{Diag}(d_1, \\dots, d_n)$ 是一个度矩阵 (degree matrix).\n\n最后, 将扩散的 training error 加到原来(第二步)的软标签中.\n\n![gnn-ii-5](img/articles/gnn-ii-5.jpg)\n\n### Smooth\n\n在做完纠正之后, 就要对结果再进行平滑化. 这么做的原因是, 相邻的结点通常都有相同的标签.\n\n如下图所示, 图中的预测不是很平滑.\n\n![gnn-ii-6](img/articles/gnn-ii-6.jpg)\n\n首先, 对于已有标签的结点, 使用 ground truth 而不是软标签\n\n![gnn-ii-7](img/articles/gnn-ii-7.jpg)\n\n然后计算扩散标签 $\\mathbf{Z}$.\n$$\n\\mathbf{Z}^{(t+1)} \\leftarrow (1 - \\alpha)\\mathbf{Z}^{(t)} + \\alpha \\widetilde{\\mathbf{A}}\\mathbf{Z}^{(t)}\n$$\n经过几轮计算以后就能得到较为平滑的预测.\n\n> 注意\n>\n> 平滑后的软标签的和可能会大于 1. 如 (0.9, 0.15). \n>\n> 判断标签时, 选择数值较大的那一个.\n\n## 参考资料\n\nSDSC 8009 课件 GNN I"
    },

    {
        "id": "1630f78e-50c0-437e-8f8a-a62c66631527",
        "title": "GNN - Message Passing I",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 30 },
        "peek": "本文主要介绍了 GNN 中的 Relational Classification 和 Iterative Classification",
        "content": "> 2022 年 3 月 30 日\n\n## 大纲\n\n本文主要介绍了 Message Passing 和 GNN 入门.\n\n在正式开始之前, 先介绍我们想要做到的事情: label propagation. 简单地说, 就是预测未分类的结点标签是什么. 如下图所示:\n\n![label-propagation](img/articles/label-propagation.png)\n\n## Message Passing\n\n### Intuition\n\n因为在网络数据中存在相关性, 依赖性, 所以我们可以做到 label propagation. \n\n对此我们有两个解释. \n\n1. **同质性** (homophily), 描述了相似的结点倾向于聚集在一起. 也就是\"物以类聚\". \n2. **Influence**, 描述的是社会性连接 (social connection) 会影响每个人的特点.\n\n## GNN 的正式设定\n\n首先要有一幅图 Graph. 具体是要有一个邻接矩阵 $\\mathbf{A}$.\n\n然后要有一个存有标记信息的向量 $Y= \\{0, 1\\}^n$.\n\n> 这是一个 semi-supervised binary node 分类问题.\n\n## 关系分类 Relational Classification\n\n关系分类的中心思想是让已有标签的结点的信息在图里面传播. 定义类概率 $Y_v$, 即结点 $v$ 为标签 $1$ 的概率. 在更新计算时, 取相邻结点的类概率的均值.\n\n**初始化**\n\n对于已经有标签的结点, 直接记\n$$\nY_v = \n\\begin{cases}\n1, &\\text{label is }\\,1\\\\\n0, &\\text{label is }\\,0.\n\\end{cases}\n$$\n对于没有标签的结点, $Y_v = 0.5$.\n\n直到所有结点收敛或者达到某个最大迭代次数前, 按随机顺序更新所有结点的 $Y_v$.\n\n> 这个方式仅仅用到了标签信息, 完全没有用到结点的特征信息.\n\n## 迭代分类 Iterative Classification\n\n迭代方式的具体做法是训练两个分类器 $\\phi_1(f_v)$ 和 $\\phi_2(f_v, z_v)$. \n\n其中 $\\phi_1(f_v)$ 被称为 Base Classifier, 使用结点的特征信息 $f_v$ 来预测标签; $\\phi_2(f_v, z_v)$ 被称为 Relational Classifier, 使用特征信息 $f_v$ 以及 <span style='color: red'>summary vector </span>$\\textcolor{red}{z_v}$ 来预测标签.\n\n### 计算 Summary Vector\n\n对于计算 summary vector, 有三种方式\n\n1. $N_v$ 中每个标签的数量\n2. 在 $N_v$ 中最常见的标签\n3. $N_v$ 中不同标签的数量\n\n### 迭代分类的架构\n\n**第一步: 只用结点的特征信息进行分类**\n\n使用有标签的训练集, 训练 $\\phi_1(f_v)$ 和 $\\phi_2(f_v, z_v)$.\n\n**第二步: 迭代直到收敛**\n\n在测试集上, 用 $\\phi_1$ 来标记标签, 然后计算 $z_v$ 并用 $\\phi_2$ 来标记标签.\n\n对于每一个结点 $v$, 重复:\n\n- 根据 $Y_u$ 来更新 $Z_v$, 其中 $u \\in N_v$\n- 根据 $z_v$ 来更新 $Y_u$\n\n直到收敛或者达到最大迭代数\n\n> 注意: 不能保证总是收敛\n\n## Correct & Smooth\n\n这个部分内容较多, 单独写一篇文章介绍.\n\n## 参考资料\n\nSDSC 8009 课件 - GNN I"
    },

    {
        "id": "20b1f9f2-2f83-447e-9728-7f9fe544b1f3",
        "title": "主成分分析 PCA",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 26 },
        "peek": "PCA 即 Principle Component Analysis. 中文名为主成分分析. 是一种简化数据集的方法",
        "content": "> 2022 年 3 月 26 日\n\n## 什么是 PCA?\n\nPCA 即 Principle Component Analysis. 中文名为**主成分分析**. 是一种简化数据集的方法.\n\n顾名思义, 就是从数据集中找到最主要的那些成分. 因此, PCA 常用于减少数据集的维度, 同时保留数据集中对方差贡献最大的特征. \n\n## 准备工作 (Matrix Normalization)\n\n这一步的动作是把数据的 \"中心\" 移回到坐标原点上. 然后使其的方差归一. 正如下图所示.\n\n![img/articles/data-normalization.png](img/articles/data-normalization.png)\n\n假设有数据 $\\mathbf{X}$\n$$\n\\mathbf{X} = \n\\begin{pmatrix}\nX_{11} & X_{12} & \\cdots & X_{1p}\\\\\nX_{21} & X_{22} & \\cdots & X_{2p}\\\\\n       &        & \\cdots &       \\\\\nX_{n1} & X_{n2} & \\cdots & X_{np}\\\\\n\\end{pmatrix}_{n\\times p}\n$$\n将其进行 \"中心化\", 也就是让每一列的均值为 0. \n\n定义 centering matrix:\n$$\n\\mathbf{J}_n = \\mathbf{I}_n - \\dfrac 1n \\mathbf{1}\\mathbf{1}^\\top.\n$$\n**那么 $\\mathbf{J}_n \\mathbf{X}$ 就是中心化后的矩阵.**\n\n接下来就要让每个变量的方差变为1.\n\n定义 standardizing matrix:\n$$\n\\mathbf{N} = \\Big(\\text{diag}(\\mathbf{X}^\\top\\mathbf{X}/n)\\Big)^{-1/2}\n$$\n**那么 $\\mathbf{XN}$ 就是 $L_2$ standardized 的矩阵**. (每列的 norm 等于 n).\n\n**最终得到:** $\\color{red} \\mathbf{J}_n\\mathbf{XN}$ - centered and normalized.\n\n## PCA 的统计学理解\n\n<span style='color: red'>PCA 就是找到一个连续的线性变量组合, 每个变量的方差要尽可能大, 同时各个变量之间要互不相关 (mutually uncorrelated).</span>\n\n![img/articles/pca-stat-view.png](img/articles/pca-stat-view.png)\n\n上面这句话的数学表达就是\n$$\n\\mathbf{Z_k} = \\mathbf{Xv}_k,\\quad \\Vert\\mathbf{v}_k\\Vert = 1, \\quad\\mathbf{v}_k \\in \\mathbf{R}^p,\\quad k = 1, \\cdots, d\n$$\n且 $\\mathbf{Z}_k$ 的方差要最大化, 并且满足\n$$\n\\text{Var}(\\mathbf{Z}_1) \\geq\\text{Var}(\\mathbf{Z}_2) \\geq\\cdots \\geq\\text{Var}(\\mathbf{Z}_d) \\geq 0\n$$\n\n$$\n\\text{Cor}(\\mathbf{Z}_k, \\mathbf{Z}_{k'}) = 0, \\quad \\forall k \\neq k'\n$$\n\n>$\\mathbf{v}_k$ 是 loading, 他们在特征空间中定义了数据方差最大的那些方向. \n>\n>$\\mathbf{Z}_k$ 是 PC 分数.\n\n### 计算主成分\n\n对于第一个 PC, $\\mathbf{Z}_1 = \\mathbf{Xv}_1$, 就是要计算 $\\mathbf{v}_1$\n$$\n\\begin{aligned}\n&\\max\\limits_{\\mathbf{v}_1} \\, \\text{Var}(\\mathbf{Z}_1),\\quad \\text{subject to}\\,\\,\\Vert\\mathbf{v}_1\\Vert = 1\\\\\n\\implies &\\max\\limits_{\\mathbf{v}_1} \\, \\mathbf{v}_1^\\top\\mathbf{X}^\\top\\mathbf{X}\\mathbf{v}_1,\\quad \\text{subject to}\\,\\,\\Vert\\mathbf{v}_1\\Vert = 1\\\\\n\\end{aligned}\n$$\n找到第一个 PC 后, 第二个 PC:\n$$\n\\max\\limits_{\\mathbf{v}_2} \\, \\mathbf{v}_2^\\top\\mathbf{X}^\\top\\mathbf{X}\\mathbf{v}_2,\\quad \\text{subject to}\\,\\,\\Vert\\mathbf{v}_2\\Vert = 1,\\quad\\mathbf{v}_2^\\top\\mathbf{v}_1 = 0\\\\\n$$\n$\\dots$\n\n对于第 k 个 PC\n$$\n\\begin{aligned}\n&\\max\\limits_{\\mathbf{v}_k} \\, \\mathbf{v}_k^\\top\\mathbf{X}^\\top\\mathbf{X}\\mathbf{v}_k\\\\\n&\\text{subject to}\\,\\,\\Vert\\mathbf{v}_k\\Vert = 1,\\quad\\mathbf{v}_{k}^\\top\\mathbf{v}_{k'} = 0, \\quad k' = 1,2,\\dots,k - 1\\\\\n\\end{aligned}\n$$\n\n## PCA 的几何学理解\n\n简单地说, PCA 的几何理解就是找到原数据的子空间, 使得 mse 最小化.\n\n![img/articles/pca-geo-view.png](img/articles/pca-geo-view.png)\n\n\n\n## 参考资料\n\n1. [PCA - 维基百科](https://zh.wikipedia.org/wiki/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90)\n2. SDSC 6001 课件 PCA\n\n"
    },

    {
        "id": "96c1f9f1-617f-418f-9bce-8e3c3437a69f",
        "title": "Network Embedding",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 25 },
        "peek": "将节点映射到一个 embedding 空间. 两个 embedding 的相似度反映到两幅图的相似度",
        "content": "> 2022 年 3 月 25 日\n\n## 什么是 network embedding?\n\n\"Map nodes into an embedding space\"\n\n将节点映射到一个 embedding 空间. 两个 embedding 的相似度反映到两幅图的相似度.\n\n## 具体做法\n\n![img/articles/embedding-graph.png](img/articles/embedding-graph.png)\n\n\n\n### 编码和解码\n\n对于任意的两个点 $u$ 和 $v$, 通过编码后分别得到 $\\mathbf{Z}_u$, $\\mathbf{Z}_v$.\n$$\n\\text{encode}(u) = \\mathbf{Z}_u\\\\\n\\text{encode}(v) = \\mathbf{Z}_v\n$$\n\n> 那么现在的目标就是\n> $$\n> \\text{similarity}(u, v) = \\mathbf{Z}_u^\\top\\mathbf{Z}_v\n> $$\n\n注意, \n\n- 这里的 $\\text{encode}(\\cdot)$ 和 $\\text{similarity}(u, v)$ 都是需要自己定义的.\n- $\\text{similarity}(u, v)$ 在这里便是 $\\text{decode}(\\cdots)$.\n\n## Random Walk Embedding\n\n在了解 random walk embedding 之前, 需要先了解什么是 random walk\n\n**[定义] [Random Walk]**\n\n> 从 $u$ 出发, 一直随机地选取某一个相邻结点, 然后移动.\n>\n> 这样形成的路径就是 random walk.\n\n**在 random walk embedding 中**, $\\mathbf{z}_u^\\top \\mathbf{z}_v$ **约等于 $u$ 和 $v$ 同时在一个random walk 中出现的概率**.\n\n### RW 优化问题\n\n给定图 $G = (V, E)$, 我们的目标是学习到一个函数 $f : u\\rightarrow\\mathbb{R}^d$, 使得\n$$\n\\max\\limits_{f} \\sum_{u\\in V} \\,\\log P\\Big(N_R(u)\\,|\\,\\mathbf{z}_u\\Big) \\tag{1}\n$$\n\n> 其中 $N_R(u)$ 是策略 $R$ 定义下 $u$ 的相邻结点.\n\n然后\n\n1. 在某 random walk 策略 $R$ 下, 对于图内的每一个点 $u$, 运行一次固定长度的 random walk.\n2. 对于每一个 $u$, 收集 $N_R(u)$. \n3. 根据 \"给定某个点 $u$, 预测他的 $N_R(u)$\" 来最优化 embedding\n\n由 $(1)$ 可以得到\n$$\n\\mathcal{L} = \\sum_{u\\in V}\\sum_{v \\in N_R(u)} \\, -\\log \\Big(P(v\\,|\\,\\mathbf{z}_u)\\Big) \\tag{2}\n$$\n用 softmax 来参数化 $P(v\\,|\\,\\mathbf{z}_u)$\n$$\nP(v\\,|\\,\\mathbf{z}_u) = \\dfrac{\\exp(\\mathbf{z}_u^\\top \\mathbf{z}_v)}{\\sum_{n\\in V}\\,\\exp(\\mathbf{z}_u^\\top\\mathbf{z}_n)} \\tag{3}\n$$\n通过 $(2), (3)$ 可得\n$$\n\\mathcal{L} = \\sum_{u\\in V}\\sum_{v \\in N_R(u)} \\, -\\log \\Big(\\dfrac{\\exp(\\mathbf{z}_u^\\top \\mathbf{z}_v)}{\\sum_{n\\in V}\\,\\exp(\\mathbf{z}_u^\\top\\mathbf{z}_n)}\\Big) \\tag{4}\n$$\n到这里, 最优化 RW embedding 就等价于找到一个最小化 $\\mathcal{L}$ 的 embedding $\\mathbf{z}_u$.\n\n但是这个优化问题的**代价很大**, 可以观察到嵌套的 $\\sum$ 带来的复杂度是 $O\\Big(\\vert V\\vert^2\\Big)$.\n\n可以用 **Negative Sampling** 解决这个问题.\n\n#### Negative Sampling\n\n$$\n\\begin{aligned}\n&\\,\\,\\log \\Big(\\dfrac{\\exp(\\mathbf{z}_u^\\top \\mathbf{z}_v)}{\\sum_{n\\in V}\\,\\exp(\\mathbf{z}_u^\\top\\mathbf{z}_n)}\\Big)\\\\\n\\approx &\\,\\,\\log\\Big(\\sigma(\\mathbf{z}_u^\\top \\mathbf{z}_v)\\Big) - \\sum_{i=1}^k\\,\\log(\\sigma(\\mathbf{z}_u^\\top \\mathbf{z}_{n_i}))), \\quad n_i \\sim P_V\n\\end{aligned}\n$$\n\n> $\\sigma$ 是 sigmoid 函数\n>\n> $n_i \\sim P_V$ 代表结点的随机分布情况\n\n那么现在就不必再对所有结点来进行 normalization, 我们只要对 $k$ 个随机 \"负样本\" $n_i$ 来进行 normalization 就可以了.\n\n\n\n## 参考资料\n\nSDSC 8009 课件\n\n"
    },

    {
        "id": "0926666c-da50-4ccc-8e3a-a3339de06b20",
        "title": "做事与格局",
        "category": null,
        "date": { "year": 2022, "month": 3, "day": 23 },
        "peek": "所谓格局, 一是精神, 二是对自己身份的定位",
        "content": "> 2022 年 3 月 23 日\n\n## 做事五要素\n\n我认为, 要做好一件事情, 就必须做到 5 个关键的点:\n\n态度, 思考, 勇气, 坚持, 专注.\n\n### 态度\n\n去做了, 就要 **尽自己最大的努力**, 但是 **不要过分要求完美**, 只要 **问心无愧** 就够了.\n\n### 思考\n\n在行动之前一定要 **勤思考**, 少走弯路, 最大效率地完成事情.\n\n### 勇气\n\n在行动时要有 **克服恐惧的勇气** !\n\n### 坚持\n\n不顺利是正常的, 不要因为一些小挫折而轻易放弃. 即是真的是很巨大的困难, 也要有不服输的精神.\n\n### 专注\n\n做事情不专注的结果就是无限期拖延, 极大地拉低效率. 三三心二意是很容易忽视却又极其危险的.\n\n## 说说格局\n\n对于格局这个概念, 给我的感觉一直都是\"在嘴边但是就是说不出来\". 就好像向别人解释老家方言的某个词汇一样. 今天读到一篇文章$^1$, 让我对 \"格局\" 又有了更加清晰的认识.\n\n**所谓格局, 一是精神, 二是对自己身份的定位.**\n\n下面给出文章$^1$中对格局的分层:\n\n![格局](img/articles/格局.jpeg)\n\n然后是文章$^1$中对每个层次的解释:\n\n![格局1](img/articles/格局1.jpeg)\n\n## 做事和格局\n\n通过这两张图, 可以很容易地注意到做事和格局之间的关系. 具体的, 思考, 专注, 分别对应了能力, 行为. 此外, 态度, 精神, 则应该划分在精神层面. \n\n\n\n## 写在最后\n\n我渐渐的体会到, 评价一个人, 归根结底的还是在评价他的精神. 而且我十分坚定地认为, 拥有一些可贵的精神才是最大的财富. \n\n## 参考资料\n\n1. [什么是大格局?](https://www.zhihu.com/question/288688040/answer/2166955365?utm_source=wechat_session&utm_medium=social&utm_oi=980215692691402752&utm_content=group3_Answer&utm_campaign=shareopn)\n\n"
    },

    {
        "id": "96a88256-7b52-45c8-b7b3-073cd9c14b9b",
        "title": "神经网络介绍 - 单层感知器",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 19 },
        "peek": "本文介绍了神经网络的单层感知器",
        "content": "> 2022 年 3 月19 日\n\n本文介绍了单层感知器.\n\n## 感知器\n\n![perception.png](img/articles/perception.png)\n\n把感知器作为一个函数, 则输入有三个: \n\n1. 输入值 $\\mathbf{x}$ \n2. 权重 $\\mathbf{w}$\n3. 偏量 $b$\n\n计算输出如下\n$$\no = \\sigma(\\langle\\mathbf{w}, \\mathbf{x}\\rangle + b)\\\\\n\\sigma(x)= \n\\begin{cases}\n1&\\text{if}\\,\\,\\,\\, x > 0\\\\\n0 &\\rm{otherwise}\n\\end{cases}\n$$\n\n## 训练单层感知器\n\n**[算法]**\n\n**initialize** $w = 0, b = 0$\n\n**repeat**\n\n- **if** $y_i[\\langle w, x_i\\rangle + b] \\leq 0$ **then**\n  - $w \\leftarrow w + y_i x_i$\n  - $b \\leftarrow b + y_i$\n\n**until** all classified correctly \n\n\n\n## 收敛理论\n\n假设半径 $r$ 的圆可以将数据完全涵盖, margin $\\rho$ 可以将数据分类\n$$\ny(\\mathbf{x^\\top\\mathbf{w}}+ b) \\geq \\rho,\\quad\\Vert\\mathbf{w}\\Vert^2 + b^2 \\leq 1\n$$\n那么保证: 感知器将会在 $\\dfrac{r^2 + 1}{\\rho^2}$ 步后收敛.\n\n\n\n## XOR 问题\n\n单感知器不能处理 XOR 问题, **因为单感知器只能生成线性分割器**.\n\n## 参考资料\n\nSDSC 8009 课件"
    },

    {
        "id": "964eaf3b-f823-43c2-8d49-7cb07fa00e3d",
        "title": "Significant Test",
        "category": "统计",
        "date": { "year": 2022, "month": 3, "day": 18 },
        "peek": "本文介绍了重要性测试",
        "content": "> 2022 年 3 月 18 日\n\n$H_0: \\pi = \\pi_0$\n\n$H_a : \\pi \\neq \\pi_0$\n\n如果 $H_0$ 成立, 那么\n$$\nz = \\dfrac{p - \\pi_0}{\\sigma(p)} = \\dfrac{p - \\pi_0}{\\sqrt{\\dfrac{\\pi_0(1 - \\pi_0)}{n}}}\\sim N(0, 1)\n$$\n\n## One-sided Test\n\n对于 one-sided alternative hypothesis, \n$$\nH_0: \\pi\\geq\\pi_0  \\quad vs. \\quad H_a:\\pi < \\pi_0\n$$\n如果 $z < -z_{\\alpha}$, 那么拒绝 $H_0$, 否则无法拒绝 $H_0$.\n\n或者等价地, 如果对于 $P(Z < z)$ 的  $\\text{p-value} < \\alpha$, 那么拒绝 $H_0$.\n\n**另外一个情况**:\n$$\nH_0: \\pi\\leq\\pi_0  \\quad vs. \\quad H_a:\\pi > \\pi_0\n$$\n如果 $z > z_{\\alpha}$, 那么拒绝 $H_0$, 否则无法拒绝 $H_0$.\n\n或者等价地, 如果对于 $P(Z > z)$ 的 $\\text{p-value} < \\alpha$, 那么拒绝 $H_0$.\n\n## Two-sided Test\n\n对于 two-sided alternative hypothesis, 如果 $z > z_{\\alpha/2}$ 或 $z < -z_{\\alpha/2}$, 那么拒绝 $H_0$ , 否则无法拒绝 $H_0$.\n\n\n\n## p-值检验\n\np-值越小, 越应该拒绝 $H_0$.\n\n\n\n## Wald 检验\n\n$$\nH_0: \\pi=\\pi_0  \\quad vs. \\quad H_a:\\pi \\neq \\pi_0\n$$\n\n试用如下统计测试\n$$\nz = \\dfrac{p - \\pi_0}{\\sqrt{\\dfrac{p(1 - p)}{n}}}\\sim N(0, 1)\n$$\n\n\n## Likelihood Ratio Test\n\n使 $l_0 =$ 在 $H_0$ 下的最大似然函数,  使 $l_1 =$ 试用所有参数值后得到的最大似然函数,  那么LR测验就是这两个函数的比值\n$$\n-2\\ln (l_0/l_1)\n$$\n注意这个值永远不为负.\n\n### 解析\n\n这个值越大, 那么就越应该拒绝 $H_0$.\n\n## 参考资料\n\nSDSC 8013 课件\n\n"
    },

    {
        "id": "39897f98-4c57-4a3d-9fb9-e56c078781a1",
        "title": "强化学习 (六) - 无模型预测 Model-Free Prediction",
        "category": "强化学习",
        "date": { "year": 2022, "month": 3, "day": 18 },
        "peek": "本文主要关注在 策略评估 (policy evaluation) 上",
        "content": "> 2022 年 3 月 17 日\n\n本文主要关注在**策略评估** (policy evaluation) 上.\n\n> Recall $v_\\pi = \\mathcal{T}_\\pi v_\\pi$\n\n\n\n## 蒙特卡洛学习 Monte-Carlo Learning\n\n蒙特卡洛的中心思想是: **价值 = 平均回报**. \n\n直接从过去经验中学习. \n\n> 无模型: 我们不知道 MDP 的 transition 或是 rewards.\n\n- 不假设状态是 Markov 的\n\n### 蒙特卡洛策略评估\n\n**[目标]** 在策略 $\\pi$ 下, 从经验中学习得到 $v_\\pi$.\n$$\nS_1, A_1, R_2, \\dots, S_k \\sim \\pi\n$$\n\n> **Recall**\n>\n> 回报是折扣奖励的总和\n> $$\n> G_t= R_{t+1} + \\gamma R_{t+2} + \\cdots + \\gamma^{T - 1} R_T\n> $$\n> 价值函数是期望回报\n> $$\n> v_\\pi(s)= \\mathbb{E}^\\pi \\left[G_t\\,|\\, S_t = s\\right]\n> $$\n\n### First-Visit MC Policy Evaluation\n\n**[算法]**\n\n**(初始化)** $N(s) = 0, G(s) = 0, \\forall s \\in \\mathcal{S}$\n\n**for 循环** ($i= 1, 2, \\dots$):\n\n- 样本事件 $i$ : $S_{i,1}, A_{i, 1}, R_{i, 2}, \\dots, S_{i, T_i}$\n- 定义 step $t$ 的回报: $G_{i,t}= R_{i, t+1} + \\gamma R_{i, t+2} + \\cdots + \\gamma^{T_i - 1}R_{i, T_i}$\n- for 每一个在事件 $i$ 中的状态 $s$, 找到状态 $s$ 在事件 $i$ 中出现的**第一次**时刻 $t$:\n  - 增大计数器 $N(s) \\leftarrow N(s) + 1$\n  - 增大总回报 $G(s) \\leftarrow G(s) + G_{i, t}$\n  - 更新估计 $V(s) = G(s) / N(s)$\n\n### Every-Visit MC Policy Evaluation\n\n**[算法]**\n\n**(初始化)** $N(s) = 0, G(s) = 0, \\forall s \\in \\mathcal{S}$\n\n**for 循环** ($i= 1, 2, \\dots$):\n\n- 样本事件 $i$ : $S_{i,1}, A_{i, 1}, R_{i, 2}, \\dots, S_{i, T_i}$\n- 定义 step $t$ 的回报: $G_{i,t}= R_{i, t+1} + \\gamma R_{i, t+2} + \\cdots + \\gamma^{T_i - 1}R_{i, T_i}$\n- for 每一个在事件 $i$ 中的状态 $s$, for **每一次**状态 $s$ 在事件 $i$ 中出现的时刻 $t$:\n  - 增大计数器 $N(s) \\leftarrow N(s) + 1$\n  - 增大总回报 $G(s) \\leftarrow G(s) + G_{i, t}$\n  - 更新估计 $V(s) = G(s) / N(s)$\n\n### \n\n### 增大的mean\n\n序列 $x_1, x_2, \\dots$ 的均值 $\\mu_1,\\mu_2,\\dots$ 可以被增大地计算\n$$\n\\begin{aligned}\n\\mu_k &= \\dfrac 1k \\sum_{j = 1}^k x_j\\\\\n&=\\dfrac 1k \\left(x_k + \\sum_{j = 1}^{k-1}x_j\\right)\\\\\n&=\\dfrac 1k(x_k + (k - 1)\\mu_{k - 1})\\\\\n&= \\mu_{k - 1} + \\dfrac 1k (x_k - \\mu_{k-1})\n\\end{aligned}\n$$\n\n### MC 增大更新\n\n在事件 $S_1,A_1, R_2, \\dots, S_T$ 后更新 $V(s)$.\n\n对于每一个状态 $S_t$, 它的回报为 $G_t$, \n$$\nN(S_t) \\leftarrow N(S_t) + 1\\\\\nV(S_t) \\leftarrow V(S_t) \\dfrac 1{N(S_t)}(G_t - V(S_t))\n$$\n\n### MC 的缺陷\n\n- 高方差 (不稳定)\n- 只有在事件设定 (spisodic setting) 下有效\n\n## 时间差分学习 Temporal-Difference Learning\n\n- 直接从过去经验中学习. \n\n- 是 MC 和 DP 的结合.\n\n- 通过 boostraping, 从不完整的的事件中学习\n\n### TD(0)\n\n**目标**: 在策略 $\\pi$ 下, 通过经验学习得到 $v_\\pi$.\n$$\nV(S_t) \\leftarrow V(S_t) + \\alpha (R_{t+1} + \\gamma V(S_{t+1}) - V(S_t))\n$$\n\n- $R_{t+1} + \\gamma V(S_{t+1})$ 被称为 TD 目标\n- $\\delta_t = R_{t+1} + \\gamma V(S_{t+1}) - V(S_t)$ 被称为 TD 误差\n\n\n\n## 参考资料\n\nSDSC 6007 课件"
    },

    {
        "id": "f7692586-09a9-4a74-babc-efe35ad99cae",
        "title": "强化学习 (五) - 解 MDPs",
        "category": "强化学习",
        "date": { "year": 2022, "month": 3, "day": 18 },
        "peek": "本文介绍了强化学习的解 MDP",
        "content": "> 2022 年 3 月 17 日\n\n## 值迭代 Value Iteration (VI)\n\n1. 从任意的 $v_0 \\in \\mathbb{R}^S$ 开始\n2. 迭代 $k = 1, 2,\\dots$, 计算 $v_k = \\mathcal{T}v_{k - 1}$\n\n### 压缩映射 Contraction Mappings\n\n**[命题]** 对于任意的 $v, v' \\in \\mathbb{R}^S$, 有\n$$\n\\Vert\\mathcal{T}v - \\mathcal{T} v'\\Vert_\\infty \\leq \\gamma\\cdot\\Vert v - v'\\Vert_\\infty\n$$\n如果该命题成立, 那么\n$$\n\\Vert\\mathcal{T}v - \\mathcal{T} v'\\Vert_\\infty = \\Vert\\mathcal{T}^kv - \\mathcal{T}^kv^*\\Vert_\\infty \\leq \\gamma \\cdot\\Vert\\mathcal{T}^{k- 1}v - \\mathcal{T}^{k-1}v^*\\Vert_\\infty \\leq \\gamma^k\\cdot\\Vert v - v*\\Vert_\\infty\n$$\n**[命题]** 对于任意的 $v \\in \\mathbb{R}^S$, 有\n$$\n\\Vert v^* - v\\Vert_\\infty \\leq \\dfrac 1{1 - \\gamma}\\cdot\\Vert\\mathcal{T}v - v\\Vert_\\infty\n$$\n**[命题]** 对于任意的 $v \\in \\mathbb{R}^S$, 有\n$$\n\\Vert v^* - \\mathcal{T}v\\Vert_\\infty \\leq \\dfrac \\gamma{1 - \\gamma}\\cdot\\Vert\\mathcal{T}v - v\\Vert_\\infty \\tag{1}\n$$\n\n### 单调误差边界 Monotonic Error Bounds\n\n使 $(1) := b_k$, 那么我们可以得到 $v^*(s)$ 的误差边界:\n$$\n(\\mathcal{T}^kv)(s)\\pm b_k\n$$\n**[命题]** 对于任意的 $v \\in \\mathbb{R}^S$, 有\n$$\n(\\mathcal{T}^kv)(s)+ \\underline{c}_k \\leq (\\mathcal{T}^{k+1}v)(s)  + \\underline{c}_{k+1} \\leq v^*(s) \\leq (\\mathcal{T}^{k+1}v)(s) + \\bar{c}_{k+1} \\leq (\\mathcal{T}^kv)(s) + \\bar{c}_k\n$$\n其中\n$$\n\\underline{c}_k = \\dfrac \\gamma {1 - \\gamma} \\min\\limits_{s \\in \\mathcal{S}} \\left[(\\mathcal{T}^kv)(s) - (\\mathcal{T}^{k-1}v)(s)\\right]\n$$\n\n$$\n\\bar{c}_k = \\dfrac \\gamma {1 - \\gamma} \\max\\limits_{s \\in \\mathcal{S}} \\left[(\\mathcal{T}^kv)(s) - (\\mathcal{T}^{k-1}v)(s)\\right]\n$$\n\n### 得到策略的最优性 Optimality of the Obtained Policy\n\n[命题] 如果对于任意的 $v\\in \\mathbb{R}^S$ 和策略 $\\pi$ , 且 $\\mathcal{T}v= \\mathcal{T}_\\pi v$, 那么\n$$\n\\Vert v^* - v_\\pi\\Vert \\leq \\dfrac\\gamma {1 - \\gamma} \\left(\\max\\limits_{s \\in \\mathcal{S}} [(\\mathcal{T}v)(s) - v(s)] - \\min\\limits_{s \\in \\mathcal{S}} [(\\mathcal{T}v)(s)] - v(s)\\right)\n$$\n\n### 消除次最优的行动 Elimination of Suboptimal Actions\n\n我们知道\n$$\nv^*(s) = \\max\\limits_{a \\in \\mathcal{A}} \\left(r_{sa} + \\gamma \\sum _{s' \\in \\mathcal{S}} p_{sas'} \\cdot v^*(s')\\right)\n$$\n如果我们有这样的一个行动 $a$, 使得\n$$\nv^*(s)> r_{sa}+ \\gamma \\sum_{s' \\in \\mathcal{S}} p_{sas'} \\cdot v^*(s')\n$$\n那么 $a$ 不是一个在状态 $s$ 时最优的行动. 也就是说, $\\pi(s) \\neq a$ 或者 $\\pi(a \\,|\\, s) = 0$.\n\n但是在完成 VI 之前, 我们并不知道 $v^*$...\n\n**[想法]** 早每次迭代时, 我们算出上限和下限\n$$\n\\underline{v} \\leq v^* \\leq \\bar{v}\n$$\n然后做检查以下情况是否成立\n$$\n\\underline{v}(s) > r_{sa}+ \\gamma\\sum_{s' \\in \\mathcal{S}} p_{sas'} \\cdot \\bar v(s')\n$$\n如果成立, 那么 $a$ 不是一个在状态 $s$ 时最优的行动. \n\n### Gauss-Seidel Version\n\n#### 一般的版本\n\n1. 从任意的 $v_0 \\in \\mathbb{R}^S$ 开始\n2. 对于 $k = 1, 2, \\dots$, 计算 $v_k= \\mathcal{T}v_{k-1}$\n\n#### Gauss-Seidel 版本\n\n1. 从任意的 $v \\in \\mathbb{R}^S$ 开始\n2. 对每一个状态 $s \\in \\mathcal{S}$, 设 $v(s) = \\max\\limits_{a \\in \\mathcal{A}}\\left(r_{sa} + \\gamma\\sum_{s' \\in \\mathcal{S}} p_{sas'} \\cdot v(s')\\right)$\n3. 重复 2 直到 $v$ 收敛\n\n## 策略迭代 Policy Iteration\n\n**[算法]**\n\n1. (初始化) 从任意的(静态)策略 $\\pi_0$ 开始\n2. 对于 $k = 0, 1, \\dots$\n   1. (决策评估) 计算 $v_{\\pi_k} = \\mathcal{T}_{\\pi_k} v_{\\pi_k}$\n   2. (决策提升) 获得新的策略 $\\mathcal{T}_{\\pi_{k+1}} v_{\\pi_k} = \\mathcal{T}v_{\\pi_k}$\n\n### 策略提升的性质\n\n[命题] 让 $\\pi$ 和 $\\hat{\\pi}$ 都是使得 $\\mathcal{T}_{\\hat{\\pi}}v_\\pi = \\mathcal{T}v_\\pi$ 的静态策略, 那么我们有\n$$\nv_{\\hat{\\pi}} \\geq v_\\pi\n$$\n此外, 仅当 $\\pi$ 是最优的时候, $v_{\\hat{\\pi}} = v_\\pi$.\n\n### 改动过的策略迭代\n\n**[算法]** \n\n1. (初始化) 从任意的 $v_0 \\in \\mathbb{R}^S$ 开始\n2. 对于  $k = 0, 1, \\dots$\n   1. 计算新的策略, $\\mathcal{T}_{\\pi_k} v_k = \\mathcal{T}v_k$\n   2. 计算 $v_{k+1} = \\mathcal{T} _{\\pi_k}^{m_k} v_k$, 其中 $m_k$ 是某个正整数\n\n> **特殊情况**\n>\n> - $m_k= 1, \\quad k = 0, 1, \\dots$ 这就是 VI\n> - $m_k= \\infty, \\quad k = 0, 1, \\dots$ 这就是 PI\n## 参考资料\n\nSDSC 6007 课件\n"
    },

    {
        "id": "6c62febe-6d17-4b57-ad34-ffa11cec63b4",
        "title": "强化学习 (四) - MDP 的最优条件",
        "category": "强化学习",
        "date": { "year": 2022, "month": 3, "day": 17 },
        "peek": "本文介绍了MDP的最优条件",
        "content": "> 2022 年 3 月 17 日\n>\n> 更新于 2022 年 3 月 29 日\n\n## Recall MDP\n\n在上一篇强化学习的文章中, 我们介绍了 MDP 的基本定义, \n\n**[定义]** **马尔科夫决策过程**是一个元组 $\\langle\\mathcal{S}, \\mathcal{A}, \\mathcal{P}, r, \\gamma\\rangle$. 其中\n\n- $\\mathcal{S}$ 是一个有限的状态的集合.\n- $\\mathcal{A}$ 是一个有限的行为的集合.\n\n- $\\mathcal{P}$ 是状态转移概率矩阵. $p_{sas'} = \\mathbb{P}(S_{t+1} = s'\\,|\\,S_t = s, A_t = a)$.\n- $r$ 是回报函数 (reward function), $r_{sa} = \\mathbb{E}[R_{t+1}\\,|\\,S_t = s, A_t = a]$.\n- $\\gamma$ 是折扣因子 (discount factor), 取值范围为 $[0, 1]$.\n\n## The Finite-Horizon Case 和 Bellman Operator\n\n### The Finite-Horizon case\n\n首先使用一组新的术语:\n\n- **动态** (dynamics) : $s_{t+1} = w_t$ \n- **干扰** (disturbance) : $w_t$ 取值于 $\\mathcal{S}$ 并服从根据 $p_{sas'}$ 的分布\n- **行动** (action) : $a_t$\n- 在时刻 $t$ 的**回报**: $\\gamma^tr_{sa}$ (没有 terminal reward)\n\n- **目标**是: $\\max\\, \\mathbb{E}\\left[\\sum_{t=0}^{T-1}\\,\\gamma^t\\textcolor{red}{R_{t+1}}\\right]\n  = \\max\\, \\mathbb{E}\\left[\\sum_{t=0}^{T-1}\\,\\gamma^t\\textcolor{red}{r_{S_tA_t}}\\right]$\n\n那么可以使用**动态规划**来解决这个问题\n$$\n\\begin{aligned}\nJ_{N-t}(s) &= \\max\\limits_{a \\in \\mathcal{A}} \\textcolor{red}{\\mathbb{E}}\\left[\\gamma^{N-t} r_{sa} + J_{N-t+1}(\\textcolor{red}{S_{t+1}})\\,|\\,\\textcolor{red}{S_t = s}\\right]\\\\\n&=\\max\\limits_{a \\in \\mathcal{A}} \\Big(\\gamma^{N-t} r_{sa} + \\textcolor{red}{\\sum_{s' \\in \\mathcal{S}} \\, p_{sas'}}\\cdot J_{N-t+1}(\\textcolor{red}{s'})\\Big)\\\\\nJ_N(s) &= \\gamma^N\\times 0 = 0 \\qquad\\langle\\text{no terminal reward}\\rangle\n\\end{aligned}\n$$\n使 $v_t(s)= \\dfrac{J_{N-t}(s)}{\\gamma^{N-t}}$, (**Normalization**, ) 经过计算后得到\n$$\n\\begin{aligned}\n\\textcolor{red}{v_{t+1}(s)} &= \\max\\limits_{a \\in \\mathcal{A}} \\Big(r_{sa} + \\textcolor{red}{\\gamma}\\sum_{s' \\in \\mathcal{S}} p_{sas'} \\cdot \\textcolor{red}{v_t(s')}\\Big)\\\\\nv_0(s) &= 0\n\\end{aligned}\n\\tag{1}\n$$\n\n### Bellman operator\n\n**[定义]** **Bellman operator**\n\n已知 $v_{t+1}(s) = \\max\\limits_{a \\in \\mathcal{A}} \\Big(r_{sa} + \\gamma\\sum_{s' \\in \\mathcal{S}} p_{sas'} \\cdot v_t(s')\\Big)$, 那么 **Bellman operator** $\\mathcal{T}$ 的定义如下\n$$\n(\\mathcal{T} v)(s) = \\max\\limits_{a \\in \\mathcal{A}} \\Big(r_{sa} + \\gamma \\sum_{s' \\in \\mathcal{S}} p_{sas'} \\cdot v(s')\\Big).\n$$\n\nDenote \n$$\n(\\mathcal{T}^k v)(s) = (\\mathcal{T}(\\mathcal{T}^{k-1}v))(s)\n$$\n其中 $(\\mathcal{T}^0 v)(s) = v(s)$.\n\n然后就可以把 finite-horizon case 求解\n$$\n\\mathcal{T}^Nv_0 = v_N = J_0\n$$\n\n#### 静态确定策略下的 Bellman Operator\n\n假设有 **静态确定政策 (stationary deterministic policy)** \n$$\n\\pi = \\{\\mu, \\mu, \\dots\\}\n$$\nBellman operator  $\\mathcal{T}_\\pi$ 为\n$$\n(\\mathcal{T}_\\pi v)(s) = r_{s\\pi(s)} + \\gamma \\sum_{s' \\in \\mathcal{S}}\\, p_{s\\pi(s)s'}\\cdot v(s').\n$$\n\n> Denote, $(\\mathcal{T}\\pi^k v)(s) = (\\mathcal{T}_\\pi(\\mathcal{T}_\\pi^{k-1}v))(s)$[Note: $(\\mathcal{T}^0_\\pi v)(s) = v(s)$].\n\n## Bellman Operator 的性质\n\n### 单调性论点\n\n如果 $v, v' \\in \\mathbb{R}^S$, 其中 $v(s) \\leq v(s'), \\forall\\,s \\in \\mathcal{S}$, 那么有\n$$\n(\\mathcal{T}^kv)(s)\\leq(\\mathcal{T}^kv')(s), \\quad s\\in \\mathcal{S}, k = 1, 2, \\dots\n$$\n在静态的策略 $\\pi$ 下, 则是\n$$\n(\\mathcal{T}^k_\\pi v)(s)\\leq(\\mathcal{T}^k_\\pi v')(s), \\quad s\\in \\mathcal{S}, k = 1, 2, \\dots\n$$\n特别地, 如果 $v(s) \\leq (\\mathcal{T}v)(s), \\forall\\,s \\in \\mathcal{S}$, 那么\n$$\n(\\mathcal{T}^k_\\pi v)(s)\\leq(\\mathcal{T}^{k+1}_\\pi v)(s), \\quad s\\in \\mathcal{S}, k = 1, 2, \\dots\n$$\n\n### Constant shift lemma\n\n如果对于任何的静态策略 $\\pi$, $b, v\\in\\mathbb{R}^S$, 那么有\n$$\n(\\mathcal{T}^k(v + b \\cdot\\mathbf{1}_S))(s)= (\\mathcal{T}^kv)(s)+ \\gamma^k b, \\quad s\\in\\mathcal{S}, \\quad k = 1, 2, \\dots\n$$\n\n$$\n(\\mathcal{T}^k_\\pi(v + b \\cdot\\mathbf{1}_S))(s)= (\\mathcal{T}_\\pi^kv)(s)+ \\gamma^k b, \\quad s\\in\\mathcal{S}, \\quad k = 1, 2, \\dots\n$$\n\n其中 $\\mathbf{1}_S \\in \\mathbb{R}^S$, 是一个有 $1$ 构成的向量.\n\n## 命题: DP 算法的收敛\n\n### 假设\n\n1. 及时回报 $R_t$ 是有限制的. $|R_t| \\leq M$, $M$ 是某个常数.\n2. $0 < \\gamma< 1$.\n\n### 命题\n\n对于任何的初始猜测 $v_0 \\in \\mathbb{R}^S$, 对于任何状态 $s \\in \\mathcal{S}$, 有\n$$\nv^*(s) = \\lim\\limits_{N\\rightarrow\\infty}(\\mathcal{T}^Nv_0)(s),\n$$\n其中 $v^*$ 是值函数的最优值,\n$$\nv^*(s_0) = \\max\\limits_{\\pi} \\lim\\limits_{K\\rightarrow \\infty}\\mathbb{E}\\left[\\sum_{t=0}^K\\gamma^tR_{t+1}\\,\\,\\,\\,|\\,\\,\\,\\,S_0 = s_0\\right].\n$$\n\n## 命题: Bellman 等式\n\n应用 $\\mathcal{T}$ 来迭代地求得最优价值函数 $v^*$.\n\n### 命题\n\n对于所有的 $s, s\\in\\mathcal{S}$, 最优值函数满足\n$$\nv^*(s) = \\max\\limits_{a\\in \\mathcal{A}} \\Big(r_{sa} + \\gamma \\sum_{s' \\in \\mathcal{S}}p_{sas'}\\cdot v^*(s')\\Big)\n$$\n或者, 等价地,\n$$\nv^* = \\mathcal{T}v^*\n$$\n注意这里的 $v^*$ 是唯一的. \n\n此外, 对于任何使得 $v \\geq \\mathcal{T} v$ (或 $v \\leq \\mathcal{T} v$) 的 $v, v\\in \\mathbb{R}^S$, 我们有 $v \\geq v^*$ (或 $v\\leq v^*$.)\n\n## 命题: 必要和充要的最优条件\n\n### 命题\n\n当且仅当: 对于所有的 $s \\in \\mathcal{S}$, 运用 $\\pi(s)$ 可以达到 Bellman 等式的最大值, i.e., \n$$\n\\mathcal{T} v^* = \\mathcal{T}_\\pi v^*\n$$\n那么我们说这个**静态**策略 $\\pi$ 是最优的. *[结束命题]*\n\n> 首先计算出 $v^*$.\n>\n> 对于每一个 $s \\in \\mathcal{S}$, \n> $$\n> a_s \\in \\mathop{\\arg\\max}\\limits_{a \\in \\mathcal{A}} \\Big(r_{sa} + \\gamma \\sum_{s' \\in \\mathcal{S}}p_{sas'} \\cdots v^*(s')\\Big)\n> $$\n> 构建一个策略 $\\pi$ 使得 $\\pi(s) = a_s$.\n>\n> 最终通过构建得到, $\\mathcal{T}v^* = \\mathcal{T}_\\pi v^*$.\n>\n> 这个策略 $\\pi$ 是静态最优确定性的策略.\n\n\n\n\n\n## 参考资料\n\nSDSC 6007 课件\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"
    },

    {
        "id": "2f277768-477b-46e2-9914-5b3f084e02ed",
        "title": "强化学习 (三) - 马尔科夫决策过程 MDPs",
        "category": "强化学习",
        "date": { "year": 2022, "month": 3, "day": 15 },
        "peek": "MDPs, 全称是 Markov decision processes, 在 RL 中是正式描述环境的一个模型",
        "content": "> 2022 年 3 月 15 日\n>\n> 更新于 2022 年 3 月 26 日\n\n## MDPs 是什么?\n\nMDPs, 全称是 Markov decision processes, 在 RL 中是正式描述环境的一个模型. 这样的环境是可完全观测的 (fully observable). \n\n> 回想起, 在环境是可完全观测时, 有  $O_t= S_t^a= S_t^e$. \n\n## 马尔科夫链\n\n马尔科夫链描述了一个**无记忆的随机过程** (Memoryless random process). 换句话说, 就是一个满足马尔科夫性质的序列, $S_1, S_2, \\dots$ \n\n**[定义]**  一个**有限状态的马尔科夫链**是一个元组 $\\langle \\mathcal{S}, \\mathcal{P}\\rangle$. 其中 \n\n- $\\mathcal{S}$ 是一个有限的状态的集合.\n- $\\mathcal{P}$ 是状态转移概率矩阵. $p_{ss'} = \\mathbb{P}(S_{t+1} = s'\\,|\\,S_t = s)$.\n\n## MRPs \n\nMRPs, 即 Markov Reward Processes, **马尔科夫回报过程**. 也就是在**马尔科夫链**的基础上添加了回报这一个元素.\n\n**[定义]**  一个 **MRP** 是一个元组 $\\langle\\mathcal{S}, \\mathcal{P}, r, \\gamma\\rangle$. 其中,\n\n- $\\mathcal{S}$ 是一个有限的状态的集合.\n\n- $\\mathcal{P}$ 是状态转移概率矩阵. $p_{ss'} = \\mathbb{P}(S_{t+1} = s'\\,|\\,S_t = s)$.\n- $r$ 是回报函数 (reward function), $r_s = \\mathbb{E}[R_{t+1}\\,|\\,S_t = s]$.\n- $\\gamma$ 是折扣因子 (discount factor), 取值范围为 $[0, 1]$.\n\n### 回报\n\n**[定义]** 回报 $G_t$ 是从时间 $t$ 开始的折扣回报总和. \n$$\nG_t = R_{t+1} + \\gamma R_{t+2} +\\cdots = \\sum_{k=0}^\\infty \\, \\gamma^k R_{t+k+1}\\tag{1}\n$$\n\n> 当 $\\gamma = 1$, 未来的回报和当前的回报一样重要,\n>\n> 当 $\\gamma = 0$, 仅仅关心当前的回报.\n\n### 值函数 Value Function\n\n**[定义]** MRP 的**状态价值函数** $v(s)$ 是从状态 $s$ 开始的期望回报.\n$$\nv(s) = \\mathbb{E}[G_t\\,|\\,S_t = s] \\tag{2}\n$$\n\n### Bellman 等式\n\n将 $(1)$ 代入 $(2)$ 可以得到\n\n$$\n\\begin{aligned}\nv(s) \n&= \\mathbb{E}[\\textcolor{red}{G_t}\\,|\\,S_t = s]\\\\\n&= \\mathbb{E}[\\textcolor{red}{R_{t+1} + \\gamma R_{t+2} + \\gamma^2R_{t+3}+ \\cdots}\\,|\\,S_t = s]\\\\\n&= \\mathbb{E}[R_{t+1} + \\gamma (R_{t+2} + \\gamma R_{t+3}+ \\cdots)\\,|\\,S_t = s]\\\\\n&= \\mathbb{E}[R_{t+1}+ \\gamma G_{t+1}\\,|\\, S_t = s]\n\\end{aligned}\n$$\n\n注意,\n$$\n\\begin{aligned}\n\\mathbb{E}[G_{t+1}\\,|\\,S_{t} = s] \n&= \\mathbb{E}\\Big[\\mathbb{E}[G_{t+1}\\,|\\,S_t=s, S_{t+1} = s']\\,|\\, S_t = s\\Big]\\\\\n&= \\mathbb{E}\\Big[\\mathbb{E}[G_{t+1}\\,|\\,S_{t+1}=s']\\,|\\, S_t = s\\Big]\\\\\n\\mathbb{E}[\\textcolor{red}{G_{t+1}}\\,|\\,S_{t} = s] &=\\mathbb{E}\\Big[\\textcolor{red}{v(S_{t+1})}\\,|\\,S_t = s\\Big]\n\\end{aligned}\n$$\n\n>**🤔 关于 $\\mathbb{E}[G_{t+1}\\,|\\,S_{t} = s] =\\mathbb{E}[v(S_{t+1})\\,|\\,S_t = s]$ 的理解**\n>\n>**当前时间为 $t$, 状态为 $s$, 下一时刻的回报 $G_{t+1}$** 的数学表达为 $\\mathbb{E}[G_{t+1}\\,|\\,S_t = s]$.\n>\n>因为 $G_{t+1} = \\mathbb{E}[G_{t+1}\\,|\\,S_t = s, S_{t+1} = s']$, 所以**当前时间为 $t$, 状态为 $s$, 下一时刻的回报 $G_{t+1}$** 可以写成 \n>$$\n>\\mathbb{E}\\Big[\\mathbb{E}[G_{t+1}\\,|\\,S_t = s, S_{t+1} = s']\\,|\\,S_t = s\\Big].\n>$$\n>又因为马尔科夫性质, 我们可以忽略左侧的 $S_t = s$, 于是得到\n>$$\n>\\mathbb{E}\\Big[\\mathbb{E}[G_{t+1}\\,|\\,S_{t+1} = s']\\,|\\,S_t = s\\Big].\n>$$\n>此时我们发现中间的部分 $\\mathbb{E}[G_{t+1}\\,|\\,S_{t+1} = s']$ 就等于 $v(S_{t+1})$. 于是得到\n>$$\n>\\mathbb{E}\\Big[v(S_{t+1})\\,|\\,S_t = s\\Big].\n>$$\n>**总结**一下, 也就是\n>$$\n>\\mathbb{E}[G_{t+1}\\,|\\,S_{t} = s] =\\mathbb{E}\\Big[v(S_{t+1})\\,|\\,S_t = s\\Big]\n>$$\n>\n>仔细观察发现, 其实只有中间的部分发生了改变:\n>$$\n>\\color{red}G_{t+1} = v(S_{t+1}).\n>$$\n>(注意, 剩下的部分也就是这个改变发生的条件.)\n>\n>**[tl;dr]** 用语言表达就是: \n>\n>**[条件]** 当前时间为 $t$, 状态为 $s$, \n>\n>**[事件]** 下一时刻的回报 $G_{t+1}$ 就等于 $v(S_{t+1})$.\n\n因此\n$$\n\\begin{aligned}\nv(s) &= \\mathbb{E}[R_{t+1} + \\gamma \\, \\textcolor{red}{G_{t+1}} \\,|\\, S_t = s]\\\\\n&= \\mathbb{E}[R_{t+1} + \\gamma \\, \\textcolor{red} {v(S_{t+1})}\\,|\\, S_t = s]\\\\\n\\end{aligned}\n$$\n求得\n$$\nv(s) = \\mathbb{E}[R_{t+1} + \\gamma \\, v(S_{t+1})\\,|\\, S_t = s] = r_s+ \\gamma\\sum_{s'\\in\\mathcal{S}} \\, p_{ss'}v(s')\n$$\n这里我们有 $S$ 组等式, 把他们写成矩阵的形式\n$$\n\\begin{bmatrix}\nv_1\\\\v_2\\\\\\vdots\\\\v_S\n\\end{bmatrix}\n = \n \\begin{bmatrix}\nr_1\\\\r_2\\\\\\vdots\\\\r_S\n\\end{bmatrix}\n+\\gamma\n\\begin{bmatrix}\np_{11} & p_{12} &\\cdots &p_{1S}\\\\\np_{21} & p_{22} &\\cdots &p_{2S}\\\\\n\\vdots & \\vdots &\\ddots &\\vdots\\\\\np_{S1} & p_{S2} &\\cdots &p_{SS}\\\\\n\\end{bmatrix}\n\\cdot\n \\begin{bmatrix}\nv_1\\\\v_2\\\\\\vdots\\\\v_S\n\\end{bmatrix}\n$$\n等价地,\n$$\n\\mathbf{v} = \\mathbf{r} + \\gamma \\mathbf{P} \\mathbf{v}\n$$\n解 $\\mathbf{v}$\n$$\n\\mathbf{v} = \\mathbf{r} + \\gamma \\mathbf{P} \\mathbf{v}\\\\\n\\implies\\mathbf{v} = (\\mathbf{I} - \\gamma \\mathbf{P})^{-1}\\mathbf{r}\n$$\n\n> 然而对于非常大的 $\\mathcal{S}$, 计算成本极高!\n\n## MDPs\n\n马尔科夫决策过程就是在马尔科夫回报过程的基础上增加了行动 (actions).\n$$\n\\text{Markov Decision Process} = \\text{Markov reward process} + \\text{Actions}\n$$\n**[定义]** **马尔科夫决策过程**是一个元组 $\\langle\\mathcal{S}, \\mathcal{A}, \\mathcal{P}, r, \\gamma\\rangle$. 其中\n\n- $\\mathcal{S}$ 是一个有限的状态的集合.\n- $\\mathcal{A}$ 是一个有限的行为的集合.\n\n- $\\mathcal{P}$ 是状态转移概率矩阵. $p_{sas'} = \\mathbb{P}(S_{t+1} = s'\\,|\\,S_t = s, A_t = a)$.\n- $r$ 是回报函数 (reward function), $r_{sa} = \\mathbb{E}[R_{t+1}\\,|\\,S_t = s, A_t = a]$.\n- $\\gamma$ 是折扣因子 (discount factor), 取值范围为 $[0, 1]$.\n\n### 策略 Policies\n\n**[定义]** 一个策略就是在给定状态的时候各个行动的分布.\n$$\n\\pi(a \\, | \\, s) = \\mathbb{P}(A_t = a\\,|\\,S_t = s).\n$$\n\n## 参考资料\n\nSDSC 6007 课件\n\n"
    },

    {
        "id": "3c3f51d0-9a10-47ab-a0e4-49b9c30fd3d4",
        "title": "强化学习 (二) - 组成部分详解",
        "category": "强化学习",
        "date": { "year": 2022, "month": 3, "day": 15 },
        "peek": "本文较详细地介绍了强化学习的各个组成部分",
        "content": "> 2022 年 3 月 15 日\n\n## 复习\n\n在深入了解强化学习的组成部分之前, 先对已有知识进行复习.\n\n### 强化学习的组成部分\n\n强化学习的五个基本元素为.\n\n1. Agent 和环境\n2. 回报\n3. 策略\n4. 值函数\n5. 模型\n\n## Agent 和环境\n\n### 马尔科夫\n\n首先介绍**马尔科夫**的定义:\n\n如果一个状态包含了它的历史的所有信息, 那么我们称这个状态是马尔科夫的. 数学表达为\n$$\n\\mathbb{P}(S_{t+1}\\,|\\,S_t) = \\mathbb{P}(S_{t+1}\\,|\\,S_1,\\dots,S_t).\n$$\n换句话说就是, 下一个状态只和现在的状态有关.\n\n#### 例子\n\n举两个简单的例子\n\n- 根据当前的血压, 决定是否要进行治疗. 这是马尔科夫的.\n- 根据现在查看的商品, 推荐信的商品. 这不是马尔科夫的.\n\n### 马尔科夫决策过程 (Markov Decision Process) 的设定\n\n回到 agent 和环境, 如果环境是可完全观测的, 那么\n$$\nO_t= S_t^a= S_t^e.\n$$\n这就是马尔科夫决策过程 (Markov Decision Process) 的设定.\n\n\n\n## 回报 Reward Signal\n\n$R_t$ 衡量了 agent 在时刻 $t$ 的表现.\n\n再一次, 在 RL 中, 我们的目标是最大化累积未来回报.\n\n\n\n## 策略 Policy\n\n策略决定了 agent 的行为.\n\n对于 agent 的每一个状态, 策略都能够算得相对应应该采取的行动. \n\n![img/articles/RL_with_policy.png](img/articles/RL_with_policy.png)\n有两种策略模式: \n\n第一种是确定性的, 也就是对于同一个状态值 $s$, 计算所得的行动一定也是一样的. 用数学表达就是\n$$\n\\pi(s) = a.\n$$\n第二种是不确定行的. 在某个状态 $s$ 下, 下一步采取的行动有很多, 但是采取任何一个的概率都不相同. 用数学表达就是\n$$\n\\pi(a\\,|\\,s) = \\pi(A_t = a \\, |\\, S_t = s).\n$$\n\n> 不确定性的策略的一个优势在于不会被 \"对手\" 完全拿捏. 比方说 agent 在玩一个石头剪刀布的游戏, 如果 agent 的策略是完全确定的, 那么对手很容易就能找到 agent 的出拳规律并必败 agent. ([例子来源](https://youtu.be/vmkRMvhCW5c))\n\n\n\n## 值函数 Value Function\n\n值函数 $v$ 的作用是, 在采取某个策略的情况下预测未来的回报.\n\n\n\n## 模型 Model\n\n模型的作用在于预测环境的行为. 他会对下一个状态和下一个回报进行预测.\n\n\n\n## 参考资料\n\nSDSC 6007 课件"
    },

    {
        "id": "7e21881c-bea7-4a51-b3f7-bb88ddbdd694",
        "title": "强化学习 (一) - 简介",
        "category": "强化学习",
        "date": { "year": 2022, "month": 3, "day": 14 },
        "peek": "本文介绍了强化学习的基本知识",
        "content": "> 2022 年 3 月 14 日\n\n## 强化学习是什么?\n\n**学习**如何做出**一组好的**决定.\n\n> 注意这里有三个关键词: \"**学习**\", \"**好的**\", 以及 \"**一组**\".\n\n那么是谁在学习呢? 引入一个 **agent** 的概念. 是 agent 在学习.\n\n可是 agent 如何学习呢? 一个不大贴切的答案是 agent 在**环境** (environment) 中学习.\n\n到这里, 我们有了两个对象: **agent** 和 **环境**.\n\n### 强化学习的组成部分\n\n1. agent 和环境\n2. 回报 reward signal\n3. 策略 (policy)\n4. 价值函数 (value function)\n5. 模型 (model)\n\n## 强化学习如何运作?\n\n### 基本流程\n\n- **agent** 根据**观察**采取一个**行动**.\n\n- **环境**给予相应的**回报**.\n\n![img/articles/RL.png](img/articles/RL.png)\n\n我们的**目标**是: \n\n- 让 agent 作出好的决策, 使得预期的总回报最大化.\n\n### 更多\n\n### 历史 History\n\n历史是一个集观察, 行动, 回报的序列:\n$$\nH_t= O_1, R_1, A_1, \\dots, A_{t-1}, O_t, R_t.\n$$\n\n### 状态 State\n\n环境和 agent 都有自己的状态. \n\n#### 环境的状态\n\n环境的状态对于 agent 来说通常是不可见的.\n\n来自环境的下一个观测和回报都是基于当前的状态的.\n\n#### Agent 的状态\n\nAgent 的下一个行动取决于自己当前的状态.\n\nAgent 的状态由 RL 算法计算.\n$$\nS_t^a= f(H_t)\n$$\n\n## 参考资料\n\nSDSC 6007 课件"
    },

    {
        "id": "7fdae025-4c8c-481a-b353-d02cf7af6063",
        "title": "广义线性模型 (四) - Loglinear 模型",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 14 },
        "peek": "本文介绍了 glm 中的 loglinear 模型, 并加入了一个例子",
        "content": "> 2022 年 3 月 13 日\n\n## 动机\n\n类别数据通常以离散的计数出现. 例如仪器的故障次数, 疾病的发生次数等等. \n\n对于这样的数据, 我们主要关注两个部分: 1) 估算某个时间的发生频率, 2) 判断一组解释变量之间是否存在关系. \n\n在这样的设定下, Poisson 回归是一个很合适的模型. \n\n> 解释变量可以是离散的, 也可以是连续的.\n\n## 模型描述\n\n假设 $Y$ 服从泊松分布,\n$$\nP(y) = \\dfrac{e^{-\\mu}\\mu^y}{y!},\\quad y = 0, 1, 2,\\dots\n$$\n那么 loglinear 模型为\n$$\n\\log(\\mu) = \\alpha + \\beta x.\n$$\n\n> 也就是在泊松模型的基础上使用一个 log 链接函数.\n\n## 模型性质\n\n在这里我们对模型的参数进行分析.\n\n因为模型满足 $\\log(\\mu) = \\alpha + \\beta x$, 所以可以计算 mean\n$$\n\\mu =\n\\begin{cases}\ne^{\\alpha+\\beta x} & \\text{at}\\,x\\\\\ne^{\\alpha + \\beta(x+1)} = e^{\\beta}e^{\\alpha + \\beta x} &\\text{at}\\,x+1.\n\\end{cases}\n$$\n在这里我们可以得到\n$$\n\\dfrac{\\text{mean at}\\, (x+1)}{\\text{mean at}\\, x} = e^\\beta,\n$$\n\n$$\n\\dfrac{\\text{mean at}\\, (x+\\Delta x)}{\\text{mean at}\\, x} = e^{\\beta\\Delta x}.\n$$\n根据这个计算, 我们可以有以下的解释\n\n- 当 $x$ 增大一个单位时, log mean 会增大 $\\beta$ 的单位.\n- 当 $x$ 增大一个单位时, mean 会增大 $e^\\beta$ 倍.\n- 当 $\\beta = 0$ 时, $e^\\beta = 1$. 此时 $Y$ 的 mean 与 $x$ 无关.\n- 当 $\\beta > 0$ 时, $\\mu$ 有关 $x$ 单调递增.\n- 当 $\\beta < 0$ 时, $\\mu$ 有关 $x$ 单调递减.\n\n## 例子: AIDS 研究\n\n在这里介绍一个有关AIDS的研究. 具体的研究内容为: 以每三个月(一个季度)为单位, 在1983年一月到1986年六月这个时间端内, 澳大利亚因为AIDS导致的死亡人数. 数据如下:\n\n| $x_i$ | $y_i$ | $x_i$ | $y_i$ |\n| ----- | ----- | ----- | ----- |\n| 1     | 0     | 8     | 18    |\n| 2     | 1     | 9     | 23    |\n| 3     | 2     | 10    | 31    |\n| 4     | 3     | 11    | 20    |\n| 5     | 1     | 12    | 25    |\n| 6     | 4     | 13    | 37    |\n| 7     | 9     | 14    | 45    |\n\n> $x_i:$ 时间点\n>\n> $y_i:$ 死亡人数\n\n使用 loglinear 模型拟合数据. 经过软件训练后得到 $\\alpha$ 和 $\\beta$ 的值.\n\n```text\nDeviance Residuals: \n     Min        1Q    Median        3Q       Max  \n-2.21008  -1.02032  -0.69704   0.04028   2.70758  \n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  0.33963    0.25119   1.352    0.176    \nxs           0.25652    0.02204  11.639   <2e-16 ***\n---\nSignif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 207.272  on 13  degrees of freedom\nResidual deviance:  29.654  on 12  degrees of freedom\nAIC: 86.581\n\nNumber of Fisher Scoring iterations: 5\n```\n\n模型为\n$$\n\\log(\\hat\\mu) = 0.3396 + 0.2565x.\n$$\n\n### 问题\n\n随着 $x$ 增大, $\\hat\\mu$ 会如何变化, 为什么?\n\n> $\\hat\\mu$  也会增大, 因为 $\\beta>0$.\n\n$x$ 增大一个单位后, 死亡数量会有怎样的变化?\n\n> $e^{\\hat\\beta} = e^{0.2565} \\approx 1.29$. \n>\n> $x$ 增大一个单位后, 死亡数量会增大 1.29 倍.\n\n当 $x = 3$, 预计的死亡数为?\n\n> $\\hat\\mu = e^{ 0.3396 + 0.2565\\times 3} \\approx3.03$.\n\n求 $\\beta$ 的 95% CI.\n\n> 公式为: $\\hat\\beta \\pm z_{\\alpha/2}SE(\\hat\\beta)$.\n>\n> 所以, CI 为 $0.2565 \\pm(1.96)(0.022) \\approx (0.2133, 0.2997)$.\n\n$H_0:\\beta = 0$ 的统计意义检验\n\n> **使用 Wald Test**\n> $$\n> z = \\dfrac {\\hat\\beta}{SE(\\hat\\beta)} = \\dfrac {0.2565}{0.022} = 11.64.\n> $$\n> 此时 p值 < .0001, 所以拒绝零假设 $H_0$.\n>\n> **使用 LR Test**\n>\n> 当 $\\beta = 0$, $L_0 = 383.25$.\n>\n> 当 $\\beta = \\hat\\beta$, $L_1 = 472.06$.\n>\n> $-2(L_0 - L_1) = 177.62$, $\\chi^2$自由度为 1.\n>\n> 此时 p值 < .0001, 所以拒绝零假设 $H_0$.\n\n## 参考资料\n\nSDSC 8013 课件 - glm\n\n"
    },

    {
        "id": "82c6db52-7fc2-4daf-b5f8-550b3d1c75ab",
        "title": "广义线性模型 (三) - 统计推断",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 13 },
        "peek": "本文介绍了对于 glm 的统计推断",
        "content": "> 2022 年 3 月 13 日\n\n本文介绍了对于 glm 的统计推断 (statistical inference).\n\n## Wald Test\n\n零假设 $H_0 : \\beta = 0$, 那么有\n\n- 在零假设下, $z = \\dfrac {\\hat\\beta}{SE}$ 几乎服从 $N(0, 1)$ 的分布 (正态分布).\n- 对于 $H_a : \\beta \\neq 0$, 则有 $z^2 = \\left(\\dfrac{\\hat\\beta}{SE}\\right)^2$ , 几乎服从 $\\chi_1^2$ 分布.\n\n零假设 $H_0 : \\beta = \\beta_0$, 那么有\n\n- 在零假设下, 用 $z = \\dfrac{\\hat\\beta-\\beta_0}{SE}$.\n- Wald CI : $\\hat\\beta \\,\\pm\\,z_{\\alpha/2}SE$\n\n## Likelihood Ratio Test\n\n提出 $H_0$ 和 $H_a$:\n\n- $H_0: \\beta = 0$\n- $H_a : \\beta \\neq 0$\n\n使得:\n\n- $l_0$ = 当 $\\beta = 0$ 时的最大可能性\n- $l_a$ = $\\beta$ 可以是任意值的最大可能性\n\n那么有\n$$\n\\begin{aligned}\n\\text{test stat} &= -2\\log\\left(\\dfrac{l_0}{l_a}\\right)\\\\\n&=-2\\Big(\\log l_0 - \\log l_a\\Big)\\\\\n&= -2(L_0 - L_a)\n\\end{aligned}\n$$\n\n> ⚠️ \n>\n> 当样本数量很大时, Wald 和 LR test 几乎是相同的, 但是对于中小样本, LR test 会更加可靠和强大.\n\n## 异常行为  Deviance\n\n### 定义 饱和模型 (Saturated model):\n\n饱和模型对每一个观测数据都有一个单独的参数使得模型可以完美地拟合所有观测数据: $\\hat\\mu_i = y_i$.\n\n### 定义 Deviance:\n\n对于一个模型 M, 假设他的最大对数可能性 (log-likelihood) 为 $L_M$, 那么\n$$\nD_{\\mathcal{M}} = -2(L_M - L_S). \\tag{1}\n$$\n其中 $S$ 指的是饱和模型.\n\n换句话说, deviance 就是对比一个模型 $M$ 和他的饱和模型 $S$ 的 LR 统计数据. 其中, \n$$\nH_0 : \\text{model}\\,M\\, \\text{holds}\\\\\nH_a : \\text{saturated model holds}\n$$\n$(1)$ 经过转换以后可以得到\n$$\nD_\\mathcal{M} = \\dfrac 1 {\\sigma^2}\\min\\limits_{\\beta} \\sum_{i=1}^n\\,\\left(y_i - \\sum_{j=1}^p\\,\\beta_jX_{ij}\\right)^2\n$$\n对于二项分布和泊松分布的模型,\n$$\nD_\\mathcal{M} = G^2 = 2\\sum y_i\\log\\left(\\dfrac {y_i}{\\hat\\mu_i}\\right) \n$$\n\n> 其中 $\\hat\\mu_i$ 是通过计算伯努利试验成功和失败的次数总和得来的.\n\n**当 $\\hat\\mu_i$ 的值很大且 predictor 的设置是固定的, 那么 $G^2$ 可以用于检验模型的拟合度.**\n\n有如下零假设, $H_0:$ 模型拟合数据.\n\n在该零假设下, $G^2$ 几乎服从自由度为 $d$ 的 $\\chi^2$ 分布, $d = $ 样本数量 - 模型 predictor 的数量.\n\n## 参考资料\n\nSDSC 8013 课件"
    },

    {
        "id": "16d3b599-d56b-4b9c-8353-1f60366d80a6",
        "title": "广义线性模型 (二) - 简单例子",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 13 },
        "peek": "本文包含两个glm的例子",
        "content": "> 2022 年 3 月 13 日\n\n## 例子: 拟合二元数据\n\n假设二元数据服从二项分布, 那么有\n$$\nP(Y= 1) = \\pi,\\quad P(Y = 0) = 1 - \\pi.\n$$\n而且有 $E(Y) = \\pi, Var(Y) = \\pi (1 - \\pi)$.\n\n我们要用已有的观测来拟合目标分布中的参数. 在这个例子中, 就是要用观测来拟合 $\\pi$. \n\n### 用Indentity 链接\n\nIdentity 链接:\n$$\ng(\\mu) = \\alpha +\\beta x\n$$\n如果用 identity 链接来拟合该数据, 那么可以有\n$$\n\\hat\\pi = \\pi'(x) = \\alpha + \\beta x.\n$$\n(其中 $x$ 为解释变量.)\n\n#### 使用 identity 链接带来的问题\n\n1. 方差不恒定: $Var(\\hat Y) = \\hat\\pi(1 - \\hat\\pi) = \\pi'(x)(1 - \\pi'(x))$.\n2. 模型会使得 $0<\\hat\\pi$ 或 $\\hat\\pi > 0$.\n\n### 用 logit 链接 (逻辑斯蒂回归)\n\n回想 logit 链接:\n$$\ng(\\mu) = \\log(\\dfrac \\mu {1 - \\mu}).\n$$\n那么有\n$$\n\\log \\left[\\dfrac{\\pi'(x)}{1 - \\pi'(x)}\\right] = \\alpha + \\beta x.\n$$\n该模型解决了使用 identity 链接的问题.\n\n## 例子: 拟合计数数据\n\n假设 $Y$ 是一个服从泊松分布的计数变量.\n\n回想泊松分布, 有概率密度函数:\n$$\nP(Y = y)= \\dfrac {e^{-\\mu}\\mu^y}{y!}, \\quad y = 0, 1, 2,\\dots\\\\\nE(Y) = Var(Y) = \\mu\n$$\n\n### 使用 identity 链接\n\n很显然, identity 链接会产生负数, 这是\"不允许\"的.\n\n### 使用 log 链接\n\n回想 log 链接:\n$$\ng(\\mu) = \\log(\\mu) = \\alpha + \\beta x.\n$$\n由此可得 loglinear 模型:\n$$\n\\mu = \\exp(\\alpha + \\beta x) = e^\\alpha\\cdot (e^\\beta)^x\n$$\n\n> 解释: $x$ 每增加一个单位, $\\mu$ 就会增大 $e^\\beta$ 倍.\n\n## 参考资料\n \nSDSC 8013 课件\n\n"
    },

    {
        "id": "50689578-a06b-4453-aea9-6b06de5b74ed",
        "title": "泊松分布 Poisson Distribution",
        "category": "统计",
        "date": { "year": 2022, "month": 3, "day": 12 },
        "peek": "泊松分布是一种常见的离散概率分布",
        "content": "> 2022 年 3 月 12 日\n\n## 简介\n\n泊松分布的英文为 Poisson Distribution. 是一种常见的**离散概率分布**.\n\n泊松分布适合描述**单位时间内随机事件发生的次数**.\n\n## 泊松分布的概率密度函数\n\n泊松分布的概率密度函数为:\n$$\nP(X=k)=\\dfrac {e^{-\\lambda}\\lambda^k}{k!}\n$$\n其中 $\\lambda$ 是单位时间内随机事件的发生率.\n\n概率密度函数图:\n\n![poisson_pmf.svg](img/articles/poisson_pmf.svg)\n\n## 一些性质\n\n期望值和方差相同, 都为 $\\lambda$.\n$$\nE(X) = V(X) = \\lambda\n$$\n两个独立的服从泊松分布的随机变量的和仍然服从泊松分布.\n$$\nX_1\\sim Poisson(\\lambda_1)\\quad X_2 \\sim Poisson(\\lambda_2)\\\\\n\\implies X_1 + X_2 \\sim Poisson(\\lambda_1 + \\lambda_2)\n$$\n\n## 参考资料\n\n1. [泊松分布 - 维基百科](https://zh.m.wikipedia.org/wiki/%E5%8D%9C%E7%93%A6%E6%9D%BE%E5%88%86%E5%B8%83)\n\n"
    },

    {
        "id": "2e431f45-249f-4391-aac2-a7d437a41622",
        "title": "正态分布",
        "category": "统计",
        "date": { "year": 2022, "month": 3, "day": 9 },
        "peek": "是一个非常常见的连续概率分布",
        "content": "> 2022 年 3 月 9 日\n\n## 是什么?\n\n是一个非常常见的连续概率分布.\n\n## 概率密度函数\n\n$$\nf(x)= \\dfrac 1{\\sigma\\sqrt{2\\pi}}e^{-\\tfrac{(x - \\mu)^2}{2\\sigma^2}}\n$$\n\n可以从该概率密度函数中得到两个参数: \n\n- 位置参数 $\\mu$, 决定了分布的位置\n- 尺度参数 $\\sigma^2$, 决定了分布的幅度\n\n若一个随机变量 $X$ 服从位置参数为$\\mu$, 尺度参数为$\\sigma$的正态分布, 记为:\n$$\nX \\sim N(\\mu, \\sigma^2)\n$$\n下面给到该函数的图形\n\n![正态分布pdf.svg](img/articles/正态分布pdf.svg)\n\n## 一些性质\n\n### 期望\n\n$\\mu$\n\n### 方差\n\n$\\sigma^2$\n\n## 参考资料\n\n[正态分布 - 维基百科](https://zh.wikipedia.org/wiki/%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83)\n\n"
    },

    {
        "id": "7f078886-f4bd-415d-88be-137e32d8f75f",
        "title": "K-Mean 算法",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 9 },
        "peek": "K-Mean 算法是一个聚类算法, 属于非监督学习算法",
        "content": "> 2022 年 3 月 9 日\n\n## 是什么?\n\nK-Mean 算法是一个聚类算法, 属于非监督学习算法.\n\n给定一组数据, 在有限次数的迭代以后, 将其分为 $k$ 个聚类 (cluster).\n\n## 如何运作?\n\n**第一步**:\n\n随机挑选 $k$ 个对象作为初始聚类中心.\n\n**第二步**:\n\n计算每个对象与聚类中心的距离, 将每个对象分配给离它最近的聚类中心.\n\n获得 $k$ 个聚类.\n\n**第三步**:\n\n对于每个聚类, 计算它的中心并更新聚类中心.\n\n**第四步**:\n\n重复第二步, 第三步, 直到聚类中心不再更新.\n\n## 参考资料\n\n[K均值聚类算法-百度百科](https://baike.baidu.com/item/K%E5%9D%87%E5%80%BC%E8%81%9A%E7%B1%BB%E7%AE%97%E6%B3%95/15779627)\n\n"
    },

    {
        "id": "c870390f-c007-4106-9569-5e7403f36bd6",
        "title": "广义线性模型 (一) - 基本概念 ",
        "category": "机器学习",
        "date": { "year": 2022, "month": 3, "day": 2 },
        "peek": "顾名思义, 这是一个广义的线性模型. 我的理解就是在原来的简单线性模型的基础上, 再外包了一层函数, 使得实用性更广泛",
        "content": "> 2022 年 2 月 28 日\n>\n> 更新于 2022 年 3 月 13 日\n\n## 广义线性模型是什么?$^1$\n\n广义线性模型, 英文为 **generalized linear model**, 是一种应用灵活的线性回归模型. \n\n> 为方便编写, 用 glm 来表示广义线性模型.\n\n## 数学表达$^1$\n\n假设观测的数据 $Y$ 服从某个指数族分布.该分布的平均数 $\\boldsymbol{\\mu}$  可由与该点独立的 $\\boldsymbol{X}$ 解释.\n$$\n\\operatorname {E}({\\boldsymbol  {y}})={\\boldsymbol  {\\mu }}=g^{{-1}}({\\mathbf  {X}}{\\boldsymbol  {\\beta }})\n$$\n\n> 其中 $\\boldsymbol{\\beta}$ 是未知参数. \n\n## 组成部分$^1$\n\n由数学表达可以提取出 **glm 包含的三个部分**:\n\n1. 随机分量 Random Component.$^2$\n2. 线性预测子 $\\boldsymbol{\\eta} = \\boldsymbol{X\\beta} $.\n3. 链接函数 $g$ 使得 $E[Y | X] = \\boldsymbol{\\mu} = g^{-1}(\\boldsymbol{\\eta})$\n\n### 随机分量 Random Component$^2$\n\n- 用于定义响应变量 $Y$.\n\n- 服从来自指数族的分布. 如, 二项分布, 泊松分布, 正态分布...\n\n### 线性预测子$^1$\n\n线性预测子是用将独立变量经由线性组合来寻模式所能提供之资讯的计量变量.\n\n### 链接函数\n\n链接函数解释了线性预测子和分布期望值之间的关系.$^1$\n\n#### 例子$^2$\n\n线性回归: $g(\\mu) = \\mu$.\n\nlogit 链接: $g(\\mu) = \\log(\\dfrac \\mu {1 - \\mu})$.\n\nlog 链接: $g(\\mu) = \\log(\\mu)$.\n\n## 简单理解\n\n顾名思义, 这是一个广义的线性模型. 我的理解就是在原来的简单线性模型的基础上, 再外包了一层函数, (也就是链接函数, ) 使得实用性更广泛.\n\n## Canonical Link\n\nCanonical link 可以将响应变量的分布转换为指数族分布的一般形式.\n\n指数族分布一般形式:\n$$\nf(y;\\theta) = a(\\theta)\\,b(y)\\,\\exp\\big[\\,yQ(\\theta)\\,\\big]\n$$\n其中 $Q(\\theta)$ 是 natural parameter. \n\nCanonical link 是 $g(\\mu) = Q(\\theta)$. 其目的在于将 mean 转换为自然参数.\n\n### 例子\n\n独立的伯努利试验\n$$\n\\begin{aligned}\nf(y;\\pi) &= \\pi^y(1 - \\pi)^{1-y} \\\\\n& = y^0\\cdot(1 - \\pi)^1\\cdot\\pi^y\\cdot(1-\\pi)^{-y}\\\\\n& = (1 - \\pi) \\cdot \\dfrac{\\pi^y}{(1-\\pi)^y}\\\\\n& = (1 - \\pi) \\cdot \\exp\\Big[\\log(\\dfrac{\\pi^y}{(1-\\pi)^y})\\Big]\\\\\n& = (1 - \\pi) \\cdot \\exp\\Big[{y\\cdot\\log}(\\dfrac \\pi{1 - \\pi})\\Big]\n\\end{aligned}\n$$\n独立的 Poisson Process\n$$\n\\begin{aligned}\nf(y;\\mu) & = \\dfrac{e^{-\\mu}\\mu^y}{y!}\\\\\n&= e^{-\\mu} \\cdot\\dfrac 1 {y!}\\cdot\\exp\\big[\\log(\\mu^y)\\big]\\\\\n\n&= e^{-\\mu}(\\dfrac 1{y!})\\exp\\big[y\\log(\\mu)\\big]\n\\end{aligned}\n$$\n\n\n## 参考资料\n\n1. [廣義線性模型- 维基百科](https://zh.wikipedia.org/zh/廣義線性模型)\n2. SDSC 8013 课件"
    },

    {
        "id": "4a4d810d-2daf-487f-995d-d54f8932b46a",
        "title": "逻辑斯蒂回归  Logistic Regression",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 28 },
        "peek": "逻辑斯蒂回归是一种对数几率模型. 虽然它名为回归, 但是用的多的却是分类的场景.",
        "content": "> 2022 年 2 月 28 日\n>\n> 更新于 2022 年 3 月 15 日\n\n## 是什么?$^1$\n\n逻辑斯蒂回归是一种对数几率模型. 虽然它名为回归, 但是用的多的却是分类的场景.\n\n## 数学原理\n\n### Sigmoid 函数$^3$\n\nSigmoid 函数:\n$$\nS(x)= \\dfrac 1 {1 + e^{-x}}\n$$\n这里给到公式的图像:$^1$\n\n![Logistisch](img/articles/Logistisch.svg)\n\n可以观察到, Sigmoid 函数将值控制在 $(0, 1)$ 之间.\n\n## 用于分类\n\n逻辑斯蒂回归可以用于作为分类模型. 在这里讨论二分类问题.\n\n首先线性模型为\n$$\n\\alpha + \\beta x\n$$\n将线性模型代入 Sigmoid 函数中:\n$$\n\\pi(x) = \\dfrac1{1 + e^{-(\\alpha + \\beta x)}}\n$$\n那么, 分类器如下:\n$$\nc = \\begin{cases}\n0 &\\text{if}\\,\\,\\pi(x) < 0.5\\\\\n1 &\\text{otherwise}\n\\end{cases}\n$$\n(这里的 $0.5$ 即是阈值, 可以是其他$(0, 1)$之间的数值, 但通常为 $0.5$. )\n\n\n\n## 模型参数\n\n模型的参数有 $\\alpha$  和 $\\beta$. 可以用[**最大似然估计**](https://darin1123.github.io/myblog/#/article/f84453fb-b134-4113-908d-b97766aff1be)求得参数.\n\n## 性质$^4$\n\n### 单调性\n\n- 当 $\\beta > 0$, $\\pi(x)$ 随着 $x$ 单调递增.\n- 当 $\\beta < 0$, $\\pi(x)$ 随着 $x$ 单调递减.\n\n> 当 $\\beta = 0$, $\\pi(x) = \\dfrac {e^\\alpha}{1 + e^\\alpha}$, 是一个常数.\n\n### 斜率公式\n\n 给定 $x$ 并计算出 $\\pi(x)$, 斜率可以由如下公式求得\n$$\n\\text{slope} = \\beta \\cdot\\pi(x)\\cdot[1 - \\pi(x)]\n$$\n\n### Median effective level\n\n- 当 $\\pi (x) = 0.5$, 有 $x = -\\alpha/\\beta$.\n\n## 参数分析$^4$\n\n### 比值\n\n已知 $\\ln (\\dfrac{\\pi}{1 - \\pi}) = \\alpha + \\beta x$, (logit 链接函数, ) 那么比值为\n$$\n\\dfrac \\pi {1 - \\pi} = \n\\begin{cases}\ne^{\\alpha + \\beta x} &\\text{at}\\, x\\\\\ne^{\\alpha + \\beta(x+1)} = e^\\beta\\cdot e^{\\alpha+\\beta x} &\\text{at}\\, x+1.\n\\end{cases}\n$$\n由此可得\n$$\n\\implies \\dfrac{\\text{odds at} \\,(x+1)}{\\text{adds at}\\, x} = e^\\beta.\n$$\n更加 general 的写法\n$$\n\\dfrac{\\text{odds at} \\,(x+\\Delta x)}{\\text{adds at}\\, x} = e^{\\beta \\Delta x}\n$$\n这意味着, 当 $x$ 增大一个单位时, 对数比值增大 $\\beta$ 个单位.\n\n\n## 参考资料\n\n1. [逻辑回归 - 维基百科](https://zh.wikipedia.org/wiki/%E9%82%8F%E8%BC%AF%E8%BF%B4%E6%AD%B8)\n2. [逻辑斯蒂回归 - CSDN - 了不起的赵队](https://blog.csdn.net/zhaojc1995/article/details/81592567)\n3. [Sigmoid 函数 - 百度百科](https://baike.baidu.com/item/Sigmoid%E5%87%BD%E6%95%B0/7981407)\n4. SDSC 8013 课件"
    },

    {
        "id": "f84453fb-b134-4113-908d-b97766aff1be",
        "title": "最大似然估计",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 28 },
        "peek": "最大似然估计, 英文为 Maximum Likelihood Estimation. 简称 MLE, 是用来 估计一个概率模型的参数的 一种方法",
        "content": "> 2022 年 2 月 28 日\n> \n> 更新于 2022 年 4 月 2 日\n\n## 是什么?$^1$\n\n**最大似然估计**, 英文为 Maximum Likelihood Estimation. 简称 MLE, **是**用来 *估计一个概率模型的参数的* **一种方法**.\n\n## 怎么运作?$^{1, 2}$\n\n给定如下信息:\n\n- 一个概率分布 $D$, 那么有它的概率密度函数 (p.d.f) $f_D$.\n- 一个分布参数 $\\theta$.\n\n从这个分布中取出 $n$ 个采样, $X_1,X_2,\\dots,X_n$. 然后使用概率密度函数来得到似然函数\n$$\n{\\displaystyle {\\text{L}}(\\theta \\mid x_{1},\\dots ,x_{n})=f_{\\theta }(x_{1},\\dots ,x_{n}).}\n$$\n在 $\\theta$  的取值范围内, 找到一个合适的值使得似然函数的值最大化.\n\n## 例子\n\n### 离散分布 - 扔硬币$^1$\n\n#### 情形描述\n\n扔一枚不公平的硬币 $80$ 次. 正面的次数记为 $H$, 反面的次数记为 $T$. \n\n假设我们得到 $H = 49, T = 31$.\n\n我们想要知道这个硬币抛出正面的概率 $p$ 为多少. \n\n> (这里的概率 $p$ 即是之前提到的 $\\theta$. )\n\n这枚硬币是从一个装有三个硬币的盒子中取出来的. 而且已知盒子中的三枚硬币抛出正面的概率分别为 $\\frac 13, \\frac 12, \\frac 23$. \n\n> 这里便是给到了 $\\theta$ 的取值空间.\n\n#### 计算\n\n首先根据二项分布的公式, 得到似然函数\n$$\nL(p | H, T) = {N \\choose H}p^H(1-p)^T\n$$\n\n> 其中 $N$ 为总次数. 在这个例子中为 $80$.\n\n然后将观测到的数据分别代入.\n\n当 $p=\\frac 13$ 时,\n$$\nL(p = 1/3 | H, T) = {80 \\choose 49}(1/3)^{49}(1-1/3)^{31} \\approx 2.08\\times10^{-7}.\n$$\n当 $p=\\frac 12$ 时,\n$$\nL(p = 1/2 | H, T) = {80 \\choose 49}(1/2)^{49}(1-1/2)^{31} \\approx 0.012.\n$$\n当 $p=\\frac 23$ 时,\n$$\nL(p = 2/3 | H, T) = {80 \\choose 49}(2/3)^{49}(1-2/3)^{31} \\approx 0.054.\n$$\n\n#### 结论\n\n因此可以得出结论, 在这三枚硬币中, 我们抛的最有可能是 $p=\\frac 23$ 的那一枚硬币.\n\n### 线性模型的 mle$^3$\n\n已知线性回归\n$$\ny^{(i)} = h_w(x^{(i)}) - \\epsilon^{(i)}.\n$$\n\n> $y^{(i)}$ 为真实观测值\n>\n> $h_w(x^{(i)})$ 为预测值\n>\n> $\\epsilon^{(i)}$ 为误差\n\n那么有\n$$\n\\begin{aligned}\n\\epsilon^{(i)} = & \\, y^{(i)} - h_w(x^{(i)})\\\\\np(\\epsilon^{(i)}) = & \\,\\dfrac 1 {\\sigma \\sqrt{2\\pi}}\ne^{-\\dfrac {{\\epsilon^{(i)}}^2}{2\\sigma^2}}\\\\\np\\left[y^{(i)}\\,|\\,h_w(x^{(i)})\\right]= & \\, \\dfrac 1 {\\sigma \\sqrt{2\\pi}}\ne^{-\\tfrac {{y^{(i)} - h_w(x^{(i)})}^2}{2\\sigma^2}}\\\\\n\\end{aligned}\n$$\n就可以得到似然函数\n$$\n\\begin{aligned}\nL\\Big(h_w(x^{(i)})\\Big) & =\\, \\prod_{i =  1} ^ m \\, p\\Big(y^{(i)}\\,|\\,h_w(x^{(i)})\\Big)\\\\\n&=\\, \\prod_{i =  1} ^ m\\,\\dfrac 1 {\\sigma \\sqrt{2\\pi}}\ne^{-\\tfrac {{y^{(i)} - h_w(x^{(i)})}^2}{2\\sigma^2}}\n\\end{aligned}\n$$\n\n\n## 总结\n\n最大似然估计是一种计算模型参数的方法. 他的运作基于某些分布模型. 通过得到似然函数并将其最大化来计算模型的最佳参数.\n\n这里画了一张图方便理解.\n\n![mle](img/articles/mle.png)\n\n## 参考资料\n\n1. [最大似然估计- 维基百科](https://zh.wikipedia.org/zh-hans/最大似然估计)\n1. [最大似然估计 - 百度百科](https://baike.baidu.com/item/%E6%9C%80%E5%A4%A7%E4%BC%BC%E7%84%B6%E4%BC%B0%E8%AE%A1/4967925?fr=aladdin)\n3. [线性回归最小二乘法和最大似然估计](https://blog.csdn.net/lt793843439/article/details/91392646)\n\n"
    },

    {
        "id": "62002874-a281-4bb1-a87e-72144f57bb63",
        "title": "R - 数据框",
        "category": "R",
        "date": { "year": 2022, "month": 2, "day": 27 },
        "peek": "本文介绍了 R 语言中的数据框",
        "content": "> 2022 年 2 月 27 日\n\n可以理解为表格.\n\n每一列有一个唯一的列名, 同一列的数据类型相同, 不同列的数据类型可以不同.\n\n## 例子\n\n~~~r\ntable = data.frame(\n\tname = c(\"Alice\", \"Bob\"),\n  eid = c(\"001\", \"002\"),\n  salary = c(1000, 2000)\n)\n\nprint(table)\n~~~\n\n输出\n\n~~~text\n   name eid salary\n1 Alice 001   1000\n2   Bob 002   2000\n~~~\n\n## 使用 `summary` 函数\n\n`summary` 函数用于获得数据框的概要信息.\n\n~~~bash\n     name               eid                salary\n Length:2           Length:2           Min.   :1000\n Class :character   Class :character   1st Qu.:1250\n Mode  :character   Mode  :character   Median :1500\n                                       Mean   :1500\n                                       3rd Qu.:1750\n                                       Max.   :2000\n~~~\n\n## 提取某个列\n\n可以使用 `$` 来获取某个列.\n\n~~~r\ntable$name\n~~~\n\n输出\n\n~~~text\n[1] \"Alice\" \"Bob\"\n~~~\n\n## 按行和列取数据\n\n~~~r\ntable = data.frame(\n    name = c(\"张三\", \"李四\",\"王五\"),\n    eid = c(\"001\",\"002\",\"003\"),\n    salary = c(1000, 2000,3000)\n)\n# 读取第 2 、3 行的第 1 、2 列数据：\nresult <- table[c(2,3),c(1,2)]\nprint(result)\n~~~\n\n输出\n\n~~~text\n  name eid\n2 李四  002\n3 王五  003\n~~~\n\n## 拓展列\n\n~~~r\ntable$department <- c(\"运营\",\"技术\",\"编辑\")\n~~~\n\n输出\n\n~~~text\n  name eid salary department\n1 张三 001   1000       运营\n2 李四 002   2000       技术\n3 王五 003   3000       编辑\n~~~\n\n## `cbind` 函数\n\n该函数可以将多个向量合并成数据框.\n\n~~~r\n# 创建向量\nsites <- c(\"Google\",\"Runoob\",\"Taobao\")\nlikes <- c(222,111,123)\nurl <- c(\"www.google.com\",\"www.runoob.com\",\"www.taobao.com\")\n\n# 将向量组合成数据框\naddresses <- cbind(sites,likes,url)\n\n# 查看数据框\nprint(addresses)\n~~~\n\n输出\n\n~~~text\n     sites    likes url\n[1,] \"Google\" \"222\" \"www.google.com\"\n[2,] \"Runoob\" \"111\" \"www.runoob.com\"\n[3,] \"Taobao\" \"123\" \"www.taobao.com\"\n~~~\n\n## `rbind` 函数\n\n该函数可以对数据框进行合并.\n\n~~~r\ntable = data.frame(\n    姓名 = c(\"张三\", \"李四\",\"王五\"),\n    工号 = c(\"001\",\"002\",\"003\"),\n    月薪 = c(1000, 2000,3000)\n)\nnewtable = data.frame(\n    姓名 = c(\"小明\", \"小白\"),\n    工号 = c(\"101\",\"102\"),\n    月薪 = c(5000, 7000)\n)\n# 合并两个数据框\nresult <- rbind(table,newtable)\nprint(result)\n~~~\n\n输出\n\n~~~text\n姓名 工号 月薪\n1 张三  001 1000\n2 李四  002 2000\n3 王五  003 3000\n4 小明  101 5000\n5 小白  102 7000\n~~~\n\n\n\n## 参考资料\n\n1. [R 数据框 | 菜鸟教程](https://www.runoob.com/r/r-data-frame.html)"
    },

    {
        "id": "729d5353-663d-4402-98a1-96466c523fae",
        "title": "卡方检验 Chi Square Test",
        "category": "统计",
        "date": { "year": 2022, "month": 2, "day": 27 },
        "peek": "卡方测验是一种假设验证方法",
        "content": "> 2022 年 2 月 27 日\n\n## 卡方检验是什么?$^{1, 2}$\n\n卡方测验是一种 [假设验证](https://darin1123.github.io/myblog/#/article/af8c71a0-3032-4538-8815-95998b89d9f8) 方法. \n\n具体地, 设定为: 有了观测数据以后, 我们希望将他们分成若干互斥的分类. 并使用一套理论值来说明每个观测数据落入不同类别的概率分布模型. 卡方检验在这个设定的作用是去衡量这个假设对观察结果的反应程度.\n\n## 如何运作?$^2$\n\n1. 建立零假设.\n2. 确定数据间的实际差异, 即求出卡方值.\n3. 如果卡方值大于某特定的概率标准下的理论值, 则拒绝零假说.\n\n### 皮尔森卡方检验$^2$\n\n$n$ 个观察值, $k$ 个互斥的类. 然后每个类都有一个**观察次数** $x_i \\,\\,(i= 1,2,\\dots, k)$. \n\n假设每个观测值落入第 $i$ 个分类的概率为 $p_i$. (零假设) 因此有每个类的**理论期望次数**为 $m_i = np_i$.\n\n> 限制条件如下:\n>\n> 1. $\\sum_{i=1}^k\\,p_i = 1$\n>\n> 2. $\\sum_{i=1}^k\\,x_i = n$    ($x_i$ : 观测次数)\n> 3. $\\sum_{i=1}^k\\,m_i = n$     ($m_i$ : 期望次数)\n\n当上述零假设成立且 $n$ 接近 $\\infty$ 时, 以下统计量的极限分布趋向 $\\chi^2$ 分布.\n$$\n{\\displaystyle \\chi^{2}=\\sum _{i=1}^{k}{\\frac {(x_{i}-m_{i})^{2}}{m_{i}}}=\\sum _{i=1}^{k}{\\frac {x_{i}^{2}}{m_{i}}}-n}\n$$\n\n## 例子$^3$\n\n假设有下面的观测数据, 以列联表的形式展示. 我们想要了解 \"喝牛奶\" 和 \"感冒\" 之间的有没有关系.\n\n首先提出零假设: 喝牛奶和感冒有关系.\n\n|                | 感冒人数 | 未感冒人数 | 合计 | 感冒率 |\n| -------------- | -------- | ---------- | ---- | ------ |\n| **喝牛奶组**   | 43       | 96         | 139  | 30.94% |\n| **不喝牛奶组** | 28       | 84         | 112  | 25.00% |\n| **合计**           | 71       | 180        | 251  | 28.29% |\n\n根据最后一列 \"感冒率\", 我们得到**理论表格**:\n\n|              | 感冒人数            | 未感冒人数                | 合计 |\n| ------------ | ------------------- | ------------------------- | ---- |\n| **喝牛奶组** | $139 \\times 0.2829$ | $139 \\times (1 - 0.2829)$ | 139  |\n| **不喝牛奶组**   | $112 \\times 0.2829$ | $112 \\times (1 - 0.2829)$ | 112  |\n| **合计**     | 71                  | 180                       | 251  |\n\n计算后为:\n\n|                | 感冒人数 | 未感冒人数 | 合计 |\n| -------------- | -------- | ---------- | ---- |\n| **喝牛奶组**   | $39.32$  | $99.68$    | 139  |\n| **不喝牛奶组** | $31.68$  | $80.32$    | 112  |\n| **合计**       | 71       | 180        | 251  |\n\n然后根据卡方检验的公式求得卡方值.\n\n$\\chi^2 = 0.34 + 0.14 + 0.43 + 0.17 = 1.08$\n\n得到值后和分布进行比对. \n\n在这里的自由度为 $(2 - 1) \\times (2 - 1) = 1$. 查得临界值为 $3.84$.\n\n因为 $1.08 < 3.84$, (卡方值小于临界值) 所以不拒绝零假设.\n\n## 参考资料\n\n1. [卡方检验 - 百度百科](https://baike.baidu.com/item/%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C/2591853?fr=aladdin)\n2. [卡方检验 - 维基百科](/article/af8c71a0-3032-4538-8815-95998b89d9f8)\n\n3. [卡方检验（详解）](https://blog.csdn.net/ludan_xia/article/details/81737669)"
    },

    {
        "id": "4221b07b-d95d-4262-a64d-fa30f0b0cf84",
        "title": "R - rep 函数",
        "category": "R",
        "date": { "year": 2022, "month": 2, "day": 27 },
        "peek": "`rep` 函数用于生成重复的数据",
        "content": "> 2022 年 2 月 27 日\n\n## 作用\n\n`rep` 函数用于生成重复的数据.\n\n## 参数列表$^1$\n\n~~~r\nrep(x, ...)\n~~~\n\n`x`: 想要复制的对象\n\n`time`: 复制的次数\n\n`length.out`: 非负整数类型. 返回的向量的长度\n\n`each`: 非负整数类型. 对向量中每个元素复制的次数\n\n## 使用示例$^2$\n\n~~~r\nrep(1:4, 2)\n~~~\n\n输出: [1] 1 2 3 4 1 2 3 4\n\n~~~r\nrep(1:4, each=2)\n~~~\n\n输出: [1] 1 1 2 2 3 3 4 4\n\n~~~r\nrep(1:4, each=2, length.out=4)\n~~~\n\n输出: [1] 1 1 2 2\n\n~~~r\nrep(1:4, c(2,1,2,1))\n~~~\n\n输出: [1] 1 1 2 3 3 4\n\n~~~r\nrep(1:4, each = 2, len = 13)\n~~~\n\n输出: [1] 1 1 2 2 3 3 4 4 1 1 2 2 3\n\n## 参考资料\n\n1. [R 官方文档 - rep](https://www.rdocumentation.org/packages/base/versions/3.6.2/topics/rep)\n2. [R语言：rep函数解析](https://blog.csdn.net/qq_27586341/article/details/91364510)\n\n"
    },

    {
        "id": "faca4637-8cca-4c6c-a7a1-84840e08bdd1",
        "title": "赤池信息量准则 AIC",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 24 },
        "peek": "赤池信息量准则, 英文为 Akaike information criterion. 其中 Akaike 是创立者的名字.",
        "content": "> 2022 年 2 月 24 日\n\n## 赤池信息量准则是什么?\n\n赤池信息量准则, 英文为 Akaike information criterion. 其中 Akaike 是创立者的名字.\n\n是 *评估统计模型的复杂度* 和 *衡量统计模型 \"拟合\" 资料之优良性* 的一种**标准**$^1$.\n\n\n\n## 如何运算$^1$\n\n假设模型的误差服从正态分布的情况下,\n$$\nAIC = 2k - 2\\ln (L)\n$$\n\n> 其中 $k$ 是参数的数量, $L$ 是似然函数.\n\n## 参考资料\n\n1. [赤池信息量准则 - 维基百科](https://zh.wikipedia.org/wiki/%E8%B5%A4%E6%B1%A0%E4%BF%A1%E6%81%AF%E9%87%8F%E5%87%86%E5%88%99)\n\n"
    },

    {
        "id": "d27bb1e1-f01a-4141-b35d-7a288bda656a",
        "title": "科克霍夫原则",
        "category": "密码学",
        "date": { "year": 2022, "month": 2, "day": 22 },
        "peek": "科克霍夫原则说的是: 即使密码系统的任何细节已为人悉知, 只要密匙 (key, 又称密钥或密钥) 未泄漏, 它也应是安全的",
        "content": "> 2022 年 2 月 22 日\n\n## 描述$^1$\n\n科克霍夫原则 (英文: Kerckhoff's principle) 说的是: 即使密码系统的任何细节已为人悉知, 只要密匙 (key, 又称密钥或密钥) 未泄漏, 它也应是安全的.\n\n## 理解\n\n科克霍夫原则给出了一个设计密码系统的基本要求: 评判一个密码系统是否安全不能单靠系统内部的运作方式. 因为攻击者往往能够破解出这个系统的内部原理. 正如该原则描述的, 只要密匙没有泄露, 攻击者便无法破解系统, (即使攻击者了解该密码系统的全部细节,) 那么这样的系统可以认为是安全的.\n\n## 参考资料\n\n1. [科克霍夫原则-维基百科](https://zh.wikipedia.org/wiki/%E6%9F%AF%E5%85%8B%E9%9C%8D%E5%A4%AB%E5%8E%9F%E5%89%87)\n2. Kerckhoff's principle, Real-World Crytopraphy, Manning, David Wong\n\n"
    },

    {
        "id": "9a715a7b-e08e-418c-ab25-585c320006c0",
        "title": "对等加密",
        "category": "密码学",
        "date": { "year": 2022, "month": 2, "day": 21 },
        "peek": "对等加密, 英文为 symmetric cryptography. 它包含两个部分: 加密, 解密",
        "content": "> 2022 年 2 月 21 日\n\n## 简介\n\n对等加密, 英文为 symmetric cryptography. 它包含两个部分: 加密, 解密. \n\n对等加密之所以叫做 \"对等\", 是因为加密和解密使用的是相同的密码.\n\n## 加密和解密\n\n假设 A 和 B 之间需要传达信息 M, 但是出于某些原因他们不能够直接交换信息而是需要一个第三方途径 C 来传达. 因为这条信息中包含一些敏感信息, 所以 A 和 B 不希望 C 能够直接读取他们的交流信息. 于是, A 在把信息 M 交给 C 之前, 需要使用 A 和 B 达成共识的一个密码 S 来对这条信息进行加密. 在加密后, 原来的明文 M 就变成了一系列看似随机地暗文 M'. C 无法从中获取任何有价值的信息. 在 C 把暗文传达给 B 之后, S 使用相同的密码 S 把暗文解密得到原来的的明文 M.\n\n~~~text\n M ->  M' -> M\n(A)  ( C )  (B)\n~~~\n\n## 参考资料\n\n1. Read-World Cryptography, Manning, David Wong\n\n"
    },

    {
        "id": "e5c83c1e-624f-404d-923f-abf2a157f864",
        "title": "图论 - 中心性",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 17 },
        "peek": "本文主要介绍了三个中心性的计算方式",
        "content": "> 2022 年 2 月17 日\n\n## 简介\n\n本文主要介绍了三个中心性的计算方式: \n\n1. 特征向量中心性\n2. Katz 中心性\n3. PageRank 中心性\n\n## 1. 特征向量中心性\n\n特征向量中心性, 英文为 eigenvector centrality, 是测量**结点对网络的影响**的一种方式.\n\n### 数学定义$^1$\n\n给定一个节点集合为 ${\\displaystyle |V|}$ 的图 ${\\displaystyle G=(V,E)}$, 定义其邻接矩阵为 $A= (a_{v,t})$, 当 $v$ 与 $t$ 相连时, $a_{}v, t = 1$, 否则为 $0$. 则结点 $v$ 中心性 $x$ 的分数其求解公式为:\n$$\n{\\displaystyle x_{v}={\\frac {1}{\\lambda }}\\sum _{t\\in M(v)}x_{t}={\\frac {1}{\\lambda }}\\sum _{t\\in G}a_{v,t}x_{t}}\n$$\n 其中 $M(v)$ 是结点 $v$ 的相邻接点集合, $\\lambda$ 是一个常数.\n\n以上公式等价于:\n$$\n{\\displaystyle \\mathbf {Ax} =\\lambda \\mathbf {x} }.\n$$\n\n### 例子$^4$\n\n有以下一个简单的无向图.\n\n![特征向量中心性](img/articles/特征向量中心性.svg)\n\n那么它的邻接矩阵为:\n$$\nA = \n\\begin{bmatrix}\n0 &1 &0\\\\\n1 &0 &1\\\\\n0 &0 &1\n\\end{bmatrix}\n$$\n计算 $\\bold{x}$.\n$$\n\\mathbf {Ax} =\\lambda \\mathbf {x}  \\implies (\\mathbf{A} - \\lambda \\mathbf{I})\\mathbf{x} = \\mathbf{0}\n$$\n计算 $\\det (\\mathbf{A} - \\lambda \\mathbf{I}) = 0$ :\n$$\n\\begin{vmatrix}\n0 - \\lambda &1 &0\\\\\n1 &0 - \\lambda &1\\\\\n0 &1 &0 - \\lambda\n\\end{vmatrix}\n = 0\n$$\n得到 $\\lambda(2 - \\lambda^2) = 0$, 于是 $\\lambda = \\{0, -\\sqrt{2}, \\sqrt{2}\\}$. \n\n取最大的, 所以, $\\lambda = \\sqrt{2}$.\n\n那么有,\n$$\n\\begin{bmatrix}\n0 - \\sqrt{2} &1 &0\\\\\n1 &0 - \\sqrt{2} &1\\\\\n0 &1 &0 - \\sqrt{2}\n\\end{bmatrix}\n\\begin{bmatrix}\nu_1\\\\\nu_2\\\\\nu_3\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0\\\\\n0\\\\\n0\n\\end{bmatrix}\n$$\n得到 $u_1 = \\frac 1 {\\sqrt{2}}u_2, u_2 = \\sqrt{2} u_3$.\n\n最终得到特征向量中心性,\n$$\n\\begin{bmatrix}\n1/2\\\\\n\\sqrt{2}/2\\\\1/2\n\\end{bmatrix}.\n$$\n\n\n\n## 2. Katz 中心性\n\nKatz 中心性是**衡量节点在网络中的中心性**的一种方法$^2$.\n\n它和 PageRank, 特征向量中心性有相似之处$^2$.\n\n### 计算方式$^4$\n\n$$\nC_{Katz}(v_i)= \\alpha\\sum_{j=1}^n\\,A_{j,i}C_{Katz}(v_j)+ \\beta\n$$\n\n> 其中 $\\alpha\\sum_{j=1}^n\\,A_{j,i}C_{Katz}(v_j)$ 就是特征向量中心性.\n>\n> 所以, Katz 中心性就是在特征向量中心性的基础上, 添加了一个偏量项 (Bias term).\n\n### 应用$^{3,4}$\n\nKatz可以应用于**有向图**. (因为特征向量中心性可能会有中心性为 0 的节点出现的可能.)\n\n### Katz 中心性的问题$^4$\n\nKatz中心性存在的一个问题是一个高中心性的节点会把它的高中心性沿着向外的链接传传播.\n\n\n\n## 3. PageRank\n\nPageRank 是一种网页排名算法$^3$. \n\nPageRank 用于计量一个网页的重要性. 它的基本假设是: \"更重要的页面往往被更多的其他页面引用.\"$^3$\n\n### 计算方式$^4$\n\n$$\nC_{p}= \\beta\\,\\left(\\mathbf{I} - \\alpha A^\\top D^{-1}\\right)^{-1}\\cdot\\mathbf{1}\n$$\n\n其中 $\\alpha < \\dfrac 1{\\lambda}$, $\\lambda$ 是 $A^\\top D^{-1}$ 的最大特征值. $D = \\text{diag}(d_1^{out}, \\dots,d_n^{out})$.\n\n\n\n## 参考资料\n\n1. [特征向量中心性- 维基百科](https://zh.wikipedia.org/zh-hans/特征向量中心性)\n2. [Katz Centrality - Wikipedia](https://en.wikipedia.org/wiki/Katz_centrality)\n3. [PageRank - 维基百科](https://zh.wikipedia.org/wiki/PageRank)\n4. SDSC 8009 课件"
    },

    {
        "id": "ac94f383-6256-4b71-9b56-7bc2f0c43e73",
        "title": "游戏王 - 闪刀姬卡组攻略",
        "category": "游戏王",
        "date": { "year": 2022, "month": 2, "day": 13 },
        "peek": "本文将介绍一些闪刀姬卡组的对战技巧",
        "content": "> 2022 年 2 月 13 日\n> \n> 更新于 2022 年 2 月 14 日\n\n<img src=\"img/articles/闪刀姬-封面.jpeg\" alt=\"sky-striker-art\" style=\"width:100%\" />\n\n## 简介\n\n本文将介绍闪刀姬卡组的构筑和一些对战技巧.\n\n**闪刀姬卡组**\n\n闪刀姬卡组是一副主打 Link 召唤, 灵活运用大量魔法卡来获取优势的卡组. 其中在我方墓地的魔法卡数量大于三张时, 几乎所有本家的魔法卡都会带来额外的收益. 在场上有 **[闪刀机关-多任务战刀机]** 存在的时候, 更是可以回收在墓地的的本家魔法!\n\n## 卡片介绍$^1$\n\n### 怪兽卡\n\n![img/articles/闪刀姬-零衣.webp](img/articles/闪刀姬-零衣.webp)\n\n中文名：闪刀姬-零衣\n\n英文名：Sky Striker Ace - Raye\n\n卡片种类：效果怪兽\n\n星级：4\n\n属性：暗\n\n种族：战士\n\n攻击力：1500\n\n守备力：1500\n\n效果：这个卡名的①②的效果1回合各能使用1次。\n\n①：把这张卡解放才能发动。从额外卡组把1只「闪刀姬」怪兽在额外怪兽区域特殊召唤。这个效果在对方回合也能发动。\n\n②：这张卡在墓地存在的状态，自己场上的「闪刀姬」连接怪兽因对方的效果从场上离开的场合或者被战斗破坏的场合才能发动。这张卡特殊召唤。\n\n> **闪刀姬核心怪兽**. \n>\n> ①效果在连锁, 战斗阶段中都非常实用. 此外, 在对方回合使用可以召唤相应的 Link 怪兽来应对不同的场面.\n>\n> ②效果可以形成循环, 使自己场上总有 [闪刀姬] 的怪兽.\n>\n> 入三.\n\n![img/articles/闪刀姬-露世.webp](img/articles/闪刀姬-露世.webp)\n\n## 对战技巧\n\n### 技巧一\n\n在条件允许的情况下, 我方场上有 **[闪刀姬 - 零衣]** 的场合, 可以让 **[零衣]** 先完成攻击后发动其效果来召唤新的闪刀并进行追加攻击.\n\n> 如果在对方空场的情况下顺利进行, 可以打出 3000 点以上的伤害.\n\n![img/articles/闪刀姬技巧-连击.png](img/articles/闪刀姬技巧-连击.png)\n\n\n\n### 技巧二\n\n我方场上有 **[空域]** 和 **[零衣]**, 发动 **[空域]** 效果选择 **[零衣]**, **[零衣]** 效果连锁发动. 处理: Link特召, **[空域]** 找牌.\n\n![闪刀姬技巧-零域零衣连锁检索.png](img/articles/闪刀姬技巧-零域零衣连锁检索.png)"
    },

    {
        "id": "b29bdab0-da80-477e-b80a-d70653f13f72",
        "title": "超参数",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 13 },
        "peek": "超参数是在机器学习开始学习过程之前设置的参数",
        "content": "> 2022 年 2 月 13 日\n\n## 简介$^1$\n超参数是在机器学习开始学习过程之前设置的参数.\n\n## 一些例子$^1$\n1. 树的数量或树的深度\n2. k均值聚类中的簇数\n\n## 参考资料\n1. [超参数 - 百度百科](https://baike.baidu.com/item/%E8%B6%85%E5%8F%82%E6%95%B0/3101858?fr=aladdin)"
    },

    {
        "id": "ebeedc96-7057-4521-830b-2c95d272ee5b",
        "title": "KNN 算法",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 13 },
        "peek": "KNN 算法, 即是 k 近邻算法, 是分类算法的一种",
        "content": "> 2022 年 2 月13 日\n\n## KNN 简介\n\nKNN 算法, 即是 k 近邻算法, 是分类算法的一种. 他的基本原理就是, 给定一个点 $x$ 后, 找到数据集中 k 个和 $x$ 距离最近的点, 然后取这些点中数量最多的那个类别.\n\n## Python 实现\n\n这里给出一个暴力法的实现.\n\n~~~python\nfrom collections import Counter\n\ndef dist(a, b, p=1):\n  \"\"\"\n  计算两个点之间的距离.\n  \"\"\"\n  d = 0\n  for i in range(len(a)):\n    d += abs(a[i] - b[i]) ** p\n  return d ** (1/p)\n\nclass KNN:\n  \"\"\"\n  暴力法KNN, 无需训练.\n  \"\"\"\n  def __init__(self, X, y, k=5):\n    self.__k = k\n    self.__X = X\n    self.__y = y\n\n  def predict(self, X):\n    dists = []\n    for i in range(len(self.__X)):\n      dists.append((dist(X, self.__X[i], p=2), self.__y[i]))\n    ys = [item[1] for item in sorted(dists, key=lambda a: a[0])][0:self.__k]\n    return Counter(ys).most_common()[0][0]\n~~~\n\n"
    },

    {
        "id": "e215f3da-d449-46be-8537-2dbb9164ac4c",
        "title": "设计模式 - 单例模式",
        "category": "设计模式",
        "date": { "year": 2022, "month": 2, "day": 11 },
        "peek": "有些时候, 我们需要某一个类的实例在全局中只有最多一个, 这个时候就需要用到单例模式",
        "content": "\n\n> 2022 年 2 月 11 日\n\n## 简介\n\n单例模式, 英文为 Singleton pattern. 有些时候, 我们需要某一个类的实例在全局中只有最多一个, 这个时候就需要用到单例模式. 再一次, 单例模式保证一个类仅有一个实例, 并提供了一个访问它的全局访问点$^1$.\n\n## UML 图\n\n![img/articles/单例模式.svg](img/articles/单例模式.svg)\n\n## 简单的实现\n\n`Singleton.java`\n\n~~~java\npublic class Singleton {\n    private static Singleton instance;\n    private Singleton() {}\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n}\n~~~\n\n`Client.java`\n\n~~~java\npublic class Client {\n\n    public static void main(String[] args) {\n        Singleton theOnlyOne = Singleton.getInstance();\n        Singleton theOne = Singleton.getInstance();\n        System.out.println(theOne == theOnlyOne);\n    }\n}\n~~~\n\n打印输出\n\n~~~text\ntrue\n~~~\n\n> 这里输出 `true` 是因为两个指向的是同一个实例, 所以他们的地址必然是一样的.\n\n### 简单实现存在的问题\n\n像这样简单实现的单例模式在多线程环境中是不可取的, 因为当多个线程访问 `getInstance` 方法时, 有可能会生成多个实例.\n\n~~~java\npublic class Client {\n\n    public static void main(String[] args) {\n        Thread[] ts = new Thread[10];\n\n        for (int i = 0; i < 10; i++) {\n            ts[i] = new Thread(() -> {\n                System.out.println(Singleton.getInstance());\n            });\n        }\n\n        for (int i = 0; i < 10; i++) {\n            ts[i].start();\n        }\n    }\n}\n~~~\n\n打印输出\n\n~~~text\nsingleton.Singleton@6628122c\nsingleton.Singleton@6628122c\nsingleton.Singleton@6628122c\nsingleton.Singleton@6628122c\nsingleton.Singleton@6628122c\nsingleton.Singleton@6628122c\nsingleton.Singleton@6628122c\nsingleton.Singleton@6628122c\nsingleton.Singleton@376feed8\nsingleton.Singleton@6628122c\n~~~\n\n可以观察到, 倒数第二个的地址和其他的不一样.\n\n## 在并发环境下的单例模式\n\n我们可以通过加锁来解决问题.\n\n`SafeSingleton.java`\n\n~~~java\npublic class SafeSingleton {\n    private static SafeSingleton instance;\n    private SafeSingleton() {}\n    public static SafeSingleton getInstance() {\n        synchronized (SafeSingleton.class) {\n            if (instance == null) {\n                instance = new SafeSingleton();\n            }\n            return instance;\n        }\n    }\n}\n~~~\n\n但是这样的实现会带来性能的问题: 每一次访问 `getInstance` 方法都要加锁同步, 造成开销.\n\n## 线程安全且不影响性能的单例模式\n\n`UltimateSingleton.java`\n\n~~~java\npublic class UltimateSingleton {\n    private static UltimateSingleton instance;\n    private UltimateSingleton() {}\n    public static UltimateSingleton getInstance() {\n        if (instance == null) {\n            synchronized (SafeSingleton.class) {\n                if (instance == null) {\n                    instance = new UltimateSingleton();\n                }\n            }\n        }\n        return instance;\n    }\n}\n~~~\n\n## 参考资料\n\n1. 大话设计模式, 第 21 章, 单例模式"
    },

    {
        "id": "8fbef4ee-3e4f-4e62-a869-c8bf6b126c0e",
        "title": "游戏王 - 指定 & 非指定",
        "category": "游戏王",
        "date": { "year": 2022, "month": 2, "day": 11 },
        "peek": "在众多卡牌对战游戏中, 游戏王的规则可以说是并不简单. 在这里介绍其中的一条: 什么是 [指定] / [非指定]",
        "content": "\n> 2022 年 2 月 11 日\n\n在众多卡牌对战游戏中, 游戏王的规则可以说是并不简单. 而在其中, 有几条规则更是难以理解. 在这里介绍其中的一条: 什么是 [指定] / [非指定], 以及为什么要了解这条规则.\n\n## 定义$^1$\n\n**指定 / 非指定是属于效果的一种类别**. 所以, 可以说 \"这个效果是指定效果\", \"那个效果是非指定效果\". 要分辨两者, 要注意到有一个非常重要的时刻: **发动时机** 以及一个动作: **选择**.\n\n**如果在发动的瞬间做了选择, 那么这就是指定, 否则就是非指定效果.**\n\n## 例子\n\n光看定义可能还是很抽象, 通过几个具体的例子应该可以更容易理解.\n\n### 例一: 死者苏生$^2$\n\n![img/articles/死者苏生.webp](img/articles/死者苏生.webp)\n\n卡名: 死者苏生\n\n卡片种类：通常魔法\n\n效果：①：以自己或者对方的墓地1只怪兽为对象才能发动。那只怪兽在自己场上特殊召唤。\n\n> 这是指定效果. \"以...为对象才能发动\", 可以看到, 在发动的瞬间就选好了对象.\n\n### 例二: 冰结界的龙三叉龙$^3$\n\n![img/articles/冰结界之龙-三叉龙.webp](img/articles/冰结界之龙-三叉龙.webp)\n\n卡名: 冰结界之龙三叉龙\n\n卡片种类：同调/效果怪兽\n\n种族：龙\n\n属性：水\n\n等级：9\n\n攻击力：2700\n\n守备力：2000\n\n同调/效果：调整+调整以外的怪兽2只以上\n\n①：这张卡同调召唤成功时才能发动。对方的手卡·场上·墓地的卡可以各选最多1张除外（从手卡是随机选）。\n\n> 这是非指定效果, 因为选择的动作发生在发动的瞬间之后.\n\n## 为什么要了解这条规则$^1$?\n\n### 1. 有指定抗性的怪兽\n\n有指定抗性的怪兽通常有如下描述: \"不会成为卡片效果的对象\". 如果遇到这类有指定抗性的怪兽, 那么就要使用非指定效果去解了.\n\n### 2. 会有失去对象的问题\n\n在连锁发动的生效过程中, 因为是后者先处理的原则, 所以有一些先发动的指定效果就会有失去对象的可能性, 这个时候这个指定效果就不会生效.\n\n## 参考资料\n\n1. [指定(取對象)和非指定(不取對象)怎麼看?](https://immortalnova.hatenablog.com/entry/2016/05/16/173349)\n2. [*死者苏生* - 百度百科](http://www.baidu.com/link?url=vuSZzKPOef9vous0b__oKrmlFpyj1bTc628Yvy8-bdSSUQnXZ1OXt1QcenjbruDI85mfPBnM-u7O_wx8ciCgPCCgB-2V9kc9k40ISY2Ph4J7Tk3rU6nJiaU2VlK_8BQ7&wd=&eqid=aa69527c00044de8000000066205f997)\n3. [*冰结界*的*龙三叉龙* - 百度百科](http://www.baidu.com/link?url=AV9cWex-L5HFq4RQGh_7ZyqxUycm-Ix7O366KqHyidC3y6wzllAHIz3sg5ODpDW1mvR7dJjO6MCB3H4wflidrOEBs5lkos_0gUnOq25Dskj8GFeO4FMwvhbmzvsdQ_swbSNEArjnsZ-Ii_clA_Y0DZzFUxZm2cPylFnKGWtLfSFwr4V9vUm3Cz-YLyjkZql4&wd=&eqid=ded4f6eb00049eac000000066205f982)"
    },

    {
        "id": "0925844c-9676-40cd-a07c-261339e6a3a2",
        "title": "P 值",
        "category": "统计",
        "date": { "year": 2022, "month": 2, "day": 10 },
        "peek": "本文介绍了什么是 P 值. 用一个简单的例子说明了什么是 p 值, 并描述了 p 值的作用",
        "content": "\n> 2022 年 2 月 10 日\n\n## 简介\n\n本文介绍了什么是 P 值. 用一个简单的例子说明了什么是 p 值, 并描述了 p 值的作用.\n\n## 什么是 P 值$^1$?\n\n\"*A p-value is the probability that random chance generated the data, or something else that is equal or rarer.*\"\n\n**在同一背景下, P 值是发生一个事件概率, 以及同等概率会发生的事件的概率, 和相对更小概率发生的事件的概率 的总和.** \n\n拆分开来看, 其中有三个部分:\n\n1. 某一事件 E\n2. 发生概率和发生 E 概率相同的事件\n3. 发生概率比发生 E 概率更小的事件\n\nP 值即是这三者的概率的总和.\n\n用一个扔硬币的例子来说明. \n\n扔一个硬币两次:\n\n- **两次都是正面的概率**是 $0.5 \\times 0.5 = 0.25$.\n\n那么, 两次都是正面的 P 值就等于\n\n- 两次都是正面\n- 和两次都是正面概率一样的事件: 两次都是反面\n- 比两次都是正面概率更低的事件: 无\n\n> 为什么比两次都是正面概率更低的事件是无? 因为剩下的两种情况分别是:\n>\n> 1. 一正一反\n> 2. 一反一正\n>\n> 虽然两者顺序不同, 但是在这里视为同一情况, 都是 \"一正一反\". 它的概率是 0.5.\n\n的概率总和. 所以, **两次都是正面的 P 值**就是 $0.25 + 0.25 = 0.5$.\n\n可以观察到, 对于同一个事件, 他的发生概率和 P 值不一定是相同的.\n\n**对于连续的值, 我们使用概率密度函数来计算. (逐个枚举是不可能的.)**\n\n## 为什么要计算 P 值$^2$?\n\n**p 值可以用于在假设检验中**. \n\n维基百科: \n\n- p值是假设检验中假设零假设为真时观测到至少与实际观测样本相同极端的样本的概率。\n- 如果p值很小, 说明在原假设下极端观测结果的发生概率很小. 而如果出现了, 根据小概率原理, 就有理由拒绝原假设; p值越小, 拒绝原假设的理由越充分.\n\n## 相关文章\n\n1. [假设验证](https://darin1123.github.io/myblog/#/article/af8c71a0-3032-4538-8815-95998b89d9f8)\n\n## 参考资料\n\n1. [StatQuest: P Values, clearly explained](https://youtu.be/5Z9OIYA8He8)\n2. [维基百科 - p 值](https://zh.wikipedia.org/wiki/P%E5%80%BC)\n\n"
    },

    {
        "id": "cfb736ea-165e-4806-9d94-4d9050882227",
        "title": "比值比 Odds Ratio",
        "category": "统计",
        "date": { "year": 2022, "month": 2, "day": 10 },
        "peek": "本文介绍了 \"比值\" 和 \"比值比\" 分别是什么",
        "content": "> 2022 年 2 月 10 日\n\n## 比值 Odds\n\n用一个具体的例子说明, 假设抛一枚硬币 10 次, 其中 正面 7 次, 反面 3 次, 那么正面的比值就是 $\\dfrac73$.\n\n所以, 一个事件比值就是: $\\dfrac{该事件发生的次数}{该事件没有发生的次数}$\n\n## 比值比 Odds Ratio\n\n比值比就是两个比值的比率. \n\n问题是, **这个比值比有什么用处**? 具体地通过举个例子来说明,\n\n<table style=\"text-align: center\">\n  <tr>\n    <td rowspan=2 colspan=2>\n    </td>\n    <td colspan=2>\n      患有癌症\n    </td>\n  </tr>\n  <tr>\n  \t<td>是</td>\n    <td>否</td>\n  </tr>\n  <tr>\n  \t<td rowspan=2 style='width: 100px'>\n    \t基因改造\n    </td>\n    <td>\n    \t是\n    </td>\n    <td>\n    \t23\n    </td>\n    <td>\n    \t117\n    </td>\n  </tr>\n  <tr>\n  \t<td>\n    \t否\n    </td>\n    <td>\n    \t6\n    </td>\n    <td>\n    \t210\n    </td>\n  </tr>\n</table>\n\n**答案是: 可以使用比值比来确定两个变量之间是否存在关联**. \n\n在这个例子中, 我们要观察 \"\"基因的改造\"\" 和 \"癌症的引发\" 之间的关系.\n\n如果基因被改造, 那么患有癌症的比值为 $\\dfrac{23}{117}$.\n\n如果基因没有被改造, 此时患有癌症的比值为 $\\dfrac{6}{210}$.\n\n那么以上两者的比值比为 $\\dfrac{23/117}{6/210} = 6.88$.\n\n这里的得到的数值可以决定 \"基因改造\" 是否能够有效地预测 \"含有癌症\". 数值越大, 则越有关联; 数值越小, 则关联也小.\n\n**那么这里的数值, 怎么样才算是 \"大\", 怎么样才算是 \"小\" 呢? 可以用以下方法决定:**\n\n1. 费希尔精确测验 Fisher's exact Test\n2. [卡方测验 Chi-square Test](https://darin1123.github.io/myblog/#/article/729d5353-663d-4402-98a1-96466c523fae)\n3. 沃尔德测验 The Wald Test\n\n## 参考资料\n\n1. [Odds Ratios and Log(Odds Ratios)](https://www.youtube.com/watch?v=8nm0G-1uJzA&t=381s&ab_channel=StatQuestwithJoshStarmer)\n\n"
    },

    {
        "id": "68e0a237-160e-4737-9557-68fe3e3c7711",
        "title": "列联表",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 9 },
        "peek": "列联表, 英文为 Contingency Table,是一个矩阵形式的表格. 用于展示变量的频率分布",
        "content": "> 2022 年 2 月 9 日\n\n列联表, 英文为 Contingency Table,是一个矩阵形式的表格. 用于展示变量的频率分布. \n\n## 一些计算\n\n| 名称                             | 符号                 | 含义                                                         | 计算方式                                                     |\n| -------------------------------- | -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |\n| 总数量                           | $n$                  | 所有格数值的总和                                             | -                                                            |\n| 格计数 Cell Count                | $n_{ij}$             | 表示 $i$ 行 $j$ 列的数值                                     | -                                                            |\n| 样本份额 Sample proportion       | $p_{ij}$             | 表示 $i$ 行 $j$ 列在总和中的占比                             | $p_{ij} = \\dfrac {n_{ij}}{n}$                                |\n| 联合概率 Joint probability       | $\\pi_{ij}$           | 和样本份额相同                                               | $\\pi_{ij} = \\dfrac {n_{ij}}{n}$                              |\n| 边际概率 Marginal probability    | $\\pi_{i+}, \\pi_{+j}$ | $\\pi_{i+}$ 即是 $i$ 行的概率的总和<br/>$\\pi_{+j}$ 即是 $j$ 列的概率的总和 | $\\begin{aligned}\\pi_{i+} &=\\sum_j\\,\\pi_{ij}\\\\\\pi_{+j} &=\\sum_i\\,\\pi_{ij}\\end{aligned}$ |\n| 条件概率 Conditional probability | $\\pi_{j\\vert i}$     | -                                                            | $\\begin{aligned}\\pi_{j\\vert i}&=\\dfrac{\\pi_{ij}}{\\pi_{i+}}\\\\\\pi_{i\\vert j}&=\\dfrac{\\pi_{ij}}{\\pi_{+j}}\\end{aligned}$ |\n\n一个简单的例子: 阿司匹林的使用和心脏梗死的关系.\n\n<table style=\"text-align: center\">\n  <tr>\n    <td rowspan=2 colspan=2>\n    </td>\n    <td colspan=\"2\">\n      心肌梗死\n    </td>\n    </tr>\n    <tr>\n      <td>\n        是\n      </td>\n      <td>\n        否\n      </td>\n    </tr>\n  <tr>\n    <td rowspan=2 style='width: 72px'>\n    \t治疗方式\n    </td>\n    <td style=\"width: 100px\">\n      安慰剂\n    </td> \n    <td>\n      189\n    </td> \n    <td>\n      10,845\n    </td>\n  </tr>\n  <tr>\n    <td style=\"width: 100px\">\n      阿司匹林\n    </td> \n    <td>\n      104\n    </td> \n    <td>\n      10,933\n    </td>\n  </tr>\n</table>\n\n\n在例子中. 我们有:\n\n**格计数**: \n\n$n_{11} = 189$\n\n$n_{22} = 10,933$\n\n$n_{1+} = n_{11} + n_{12} = 189 + 10,845 = 11,034$\n\n**总数量**:\n\n$n = 22,071$\n\n"
    },

    {
        "id": "290fb2a9-de72-46c1-9704-e68a863c0f2a",
        "title": "设计模式 -  状态模式",
        "category": "设计模式",
        "date": { "year": 2022, "month": 2, "day": 8 },
        "peek": "当一个对象的内在状态发生改变时允许改变其行为, 这个对象看起来像是改变了其类",
        "content": "> 2022 年 2 月 8 日\n\n## 简介$^1$\n\n**当一个对象的内在状态发生改变时允许改变其行为, 这个对象看起来像是改变了其类.**\n\n## 理解\n\n这个设计模式有两个部分: `Context` 和 `State`. 其中, `Context` 为主体, `State` 代表 `Context` 的状态. `Context` 在不同的状态下会有不同的行为. \n\n状态的改变信息直接在状态中编码. 这样可以避免复杂且难以维护的 `if` 语句.\n\n## UML 图$^1$\n\n![img/articles/state.svg](img/articles/state.svg)\n\n## 抽象代码\n\n`Context.java`\n\n~~~java\npublic class Context {\n    private State state;\n    public Context(State state) {\n        this.state = state;\n    }\n\n    public State getState() {\n        return state;\n    }\n\n    public void setState(State state) {\n        this.state = state;\n    }\n\n    public void request() {\n        state.handle(this);\n    }\n}\n~~~\n\n`State.java`\n\n~~~java\npublic interface State {\n  \t// 这里将 Context 作为参数是为了改变状态用\n    void handle(Context context);\n}\n\n~~~\n\n`ConcreteStateA.java`\n\n~~~java\npublic class ConcreteStateA implements State {\n    @Override\n    public void handle(Context context) {\n        System.out.println(\"State A\");\n        context.setState(new ConcreteStateB());\n    }\n}\n~~~\n\n`ConcreteStateB.java`\n\n~~~java\npublic class ConcreteStateB implements State {\n    @Override\n    public void handle(Context context) {\n        System.out.println(\"State B\");\n    }\n}\n~~~\n\n`Client.java`\n\n~~~java\npublic class Client {\n\n    public static void main(String[] args) {\n        Context context = new Context(new ConcreteStateA());\n        context.request();\n        context.request();\n        context.request();\n    }\n}\n~~~\n\n客户端打印输出\n\n~~~text\nState A\nState B\nState B\n~~~\n\n\n\n## 参考资料\n\n1. 大话设计模式, 第 16 章, 状态模式"
    },

    {
        "id": "c7256675-ddae-4d28-b019-5ee65ee3ffe5",
        "title": "Python - 切片",
        "category": "Python",
        "date": { "year": 2022, "month": 2, "day": 7 },
        "peek": "本文介绍 Python 中的切片. 切片即是从一个数组中截取其中的一部分",
        "content": "> 2022 年 2 月 7 日\n\n# 简介\n\n本文介绍 Python 中的切片. 切片即是从一个数组中截取其中的一部分.\n\n# 具体做法\n\n假设我们有以下列表\n\n~~~python\nmy_list = ['a', 'b', 'c', 'd', 'e']\n~~~\n\n**获取前 3 个元素**\n~~~python\nmy_list[0:3]  # 输出 ['a', 'b', 'c']\n~~~\n注意这里的 3 表示到索引 3 为止, 并不包含索引 3.\n\n**获取第 2 个到第 4 个元素**\n~~~python\nmy_list[1:4]  # 输出 ['b', 'c', 'd']\n~~~\n\n**获取最后 3 个元素**\n~~~python\nmy_list[-3:]  # 输出 ['c', 'd', 'e']\n~~~\n\n## 参考资料\n1. [廖雪峰 - Python 切片](https://www.liaoxuefeng.com/wiki/1016959663602400/1017269965565856)\n\n"
    },

    {
        "id": "a8e47674-10a1-42f9-b254-d1362fc9098c",
        "title": "凸优化 - 凸包",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 4 },
        "peek": null,
        "content": "> 2022 年 2 月 4 日\n\n## 凸集 Convex Set\n\n如果**一个集 $C$ 中任意两点相连的线段也包含在 $C$ 中**, 那么我们说这个集是**凸**的.\n\n换句话说, 也就是对于任何两点 $x_1, x_2 \\in C$ 和一个 $\\theta$ , $0 \\leq \\theta \\leq 1$, 我们有\n$$\n\\theta x_1 + (1 - \\theta x_2) \\in C.\n$$\n\n## 凸包 Convex Hull\n\n一个集合 $C$ 的凸包, 用 $\\bold{conv}\\,\\, C$ 表示, 是所有 $C$ 中点的凸组合构成的集合.\n$$\n\\bold{conv} \\,\\,C = \\{\\theta_1x_1 + \\cdots + \\theta_kx_k\\,|\\,x_i \\in C, \\theta_i \\geq0, i = 1, \\dots, k, \\theta_1 + \\cdots + \\theta_k = 1\\}\n$$\n\n## 参考资料\n\n1. 凸优化\n\n"
    },

    {
        "id": "f2c274a0-7550-4498-99ef-1e1598b7785d",
        "title": "支持向量机",
        "category": "机器学习",
        "date": { "year": 2022, "month": 2, "day": 3 },
        "peek": "简单地说, SVM 尝试寻找一个平面使得包含两个类别的数据被分割为两个空间. 每一个空间代表一个类别",
        "content": "> 2022 年 2 月 1 日\n>\n> 更新于 2022 年 2 月 3 日\n\n\n## 什么是支持向量机?\n\n支持向量机是一个二类分类器. \n\n## 如何运作\n\n简单地说, SVM 尝试寻找一个平面使得包含两个类别的数据被分割为两个空间. 每一个空间代表一个类别. \n\n具体地, 如果数据是二维的, 那就是找到一条线; 如果数据是三维的, 那就是寻找一个平面.\n\n## 数学原理$^1$\n\n### 基本设置\n\n假设我们有如下的设置: \n$$\n\\bold{x} = \\begin{bmatrix}x_{11} & x_{21} &\\cdots &x_{n1}\\\\x_{12} &x_{22} &\\cdots &x_{n2}\\\\ \\vdots &\\vdots & &\\vdots\\\\x_{1p} &x_{2p} &\\cdots &x_{np}\\end{bmatrix}, \\quad y_i \\in \\{1, -1\\}.\n$$\n\n> 其中 $\\bold{x}_i = (x_{i1}, x_{i2}, \\dots, x_{ip})^{\\top}$ ($\\textbf{x}$ 的第 $i$ 列)\n\n定义*超平面* :\n\n$\\bold{w}^{\\top}\\bold{x} + b = 0$\n\n如果这个超平面可以将数据完美分类, 那么有:\n\n$$\n\\begin{cases}\n\\bold{w}^{\\top}\\bold{x}_i + b > 0 &\\text{if}\\,\\, y_i = 1\\\\\n\\bold{w}^{\\top}\\bold{x}_i + b < 0 &\\text{if}\\,\\, y_i = -1\n\\end{cases}\n$$\n或者, 简单合并后\n$$\ny_i(\\bold{w}^{\\top}\\bold{x}_i + b) > 0 \\tag{1}\n$$\n### 计算超平面\n\n在数据集线性可分的情况下, 这样的可以分割两类数据的面存在无数个. 那么应该如何选择这样的一个超平面呢? \n\n答案是: 找到一个**最大化间隔的平面**. \n\n请看下图$^2$, 在这个二维的例子中, 图中的线使得其到两类点之间的间隔最大:\n\n\n\n![最大化间隔](img/articles/svm_max_margin.png)\n\n<div style='width: 100%; display: flex; justify-content: center; font-family: times;'>图1. 最大化间隔</div>\n\n#### SVM 数学表达\n\n已知一个超平面的表达式如下,\n$$\n\\bold{w}^{\\top}\\bold{x} + b = 0.\n$$\n因此, 最大化间隔也就是在满足限制条件 $(1)$ 的同时, 找到最佳的 $\\bold{w}^*$ 和 $b^*$, 使得间隔最大化:\n$$\n\\begin{align*}\n\\min\\limits_{\\bold{b}, \\bold{w}, \\Vert \\bold{w}\\Vert = 1} \\quad&\\dfrac12\\Vert\\bold{w}\\Vert_2^2\\\\\n\\text{subject to} \\quad&y_i(\\bold{w}^{\\top}\\bold{x}_i + b) > 1.\n\\end{align*} \\tag{2}\n$$\n\n### 硬间隔支持向量机\n\n硬间隔的支持向量机只能处理线性可分割的数据集. 详见图1所示的情况. 数学表达即是 $(2)$.\n\n### 软间隔支持向量机\n\n在硬间隔支持向量机的基础上, 添加松弛变量 $\\mathbf{\\xi}$ 即可.\n$$\n\\begin{align*}\n\\min\\limits_{\\bold{b}, \\bold{w}, \\Vert \\bold{w}\\Vert = 1}\n\n\\quad&\\dfrac12\\Vert\\bold{w}\\Vert_2^2 + C\\sum_i\\,\\xi_i\\\\\n\n\\text{subject to} \n\n\\quad&y_i(\\bold{w}^{\\top}\\bold{x}_i + b) \\geq 1-\\xi_i,\\,\\,\\,\\xi_i \\geq 0\n\\end{align*} \\tag{3}\n$$\n\n## 参考资料\n\n1. SDSC 6001 课件\n2. [维基百科 - 支持向量机](https://zh.wikipedia.org/wiki/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA)"
    },

    {
        "id": "30ccfe77-cb25-466d-96ea-e3b2d5c259f9",
        "title": "设计模式 - 桥接模式",
        "category": "设计模式",
        "date": { "year": 2022, "month": 2, "day": 3 },
        "peek": "桥接模式, 将抽象部分和它的实现部分分离, 使他们可以独立地变化",
        "content": "> 2022 年 2 月 3 日\n\n## 简介\n\n桥接模式, 将抽象部分和它的实现部分分离, 使他们可以独立地变化$^1$. 这句话是桥接模式的精髓, 但是并不是一个能够轻松被理解的句子. \n\n## 理解\n\n可以观察到, 其中提及到两个主体: *\"抽象\"* 和 *\"实现\"*. 在进行深度阅读以后, 我的理解是: 这里的 \"抽象\" 指的是 \"灵魂\", \"实现\" 指的是肉体. \n\n桥接模式即是在 \"灵魂\" 和\" 肉体\" 之间建立了一个桥梁, 使得 \"灵魂\" 和 \"肉体\" 在连接的同时可以相互独立, 让各自的变化不会影响到另一方 (, 这样也解释了为什么叫作 \"桥接\" 模式). \n\n在实现方面, \"灵魂\" 和 \"肉体\" 之间存在一种**聚合**的关系, \"灵魂\" 拥有 \"肉体\". \"灵魂\" 有思想, 想要做一些事情, \"肉体\" 则可以真实做到这些事情.\n\n## UML 图$^1$\n\n![bridge](img/articles/bridge.svg)\n\n## 抽象代码\n\n`Abstraction.java`\n\n~~~java\npublic abstract class Abstraction {\n    protected Implementor implementor;\n\n    // 获取肉体\n    public void setImplementor(Implementor implementor) {\n        this.implementor = implementor;\n    }\n\n    // 通过肉体执行意愿\n    public void operation() {\n        implementor.operation();\n    }\n}\n~~~\n\n`RefineAbstraction.java`\n\n~~~java\npublic class RefineAbstraction extends Abstraction {\n\n     // 修改 \"灵魂\" 没有影响到 \"肉体\".\n    @Override\n    public void operation() {\n        super.implementor.operation();\n    }\n}\n~~~\n\n`Implementor.java`\n\n~~~java\npublic interface Implementor {\n    void operation();\n}\n~~~\n\n`ConcreteImplementorA.java`\n\n~~~java\npublic class ConcreteImplementorA implements Implementor {\n\n    // \"肉体\" 的变幻没有影响到 \"灵魂\"\n    @Override\n    public void operation() {\n        System.out.println(\"具体实现 - A\");\n    }\n}\n~~~\n`ConcreteImplementorB.java`\n\n~~~java\npublic class ConcreteImplementorB implements Implementor {\n\n    // \"肉体\" 的变幻没有影响到 \"灵魂\"\n    @Override\n    public void operation() {\n        System.out.println(\"具体实现 - B\");\n    }\n}\n~~~\n\n客户端代码\n\n`Client.java`\n\n~~~java\npublic class Client {\n    public static void main(String[] args) {\n        Abstraction ab = new RefineAbstraction();\n        ab.setImplementor(new ConcreteImplementorA());\n        ab.operation();\n\n        ab.setImplementor(new ConcreteImplementorB());\n        ab.operation();\n    }\n}\n~~~\n\n\n\n\n## 参考资料\n\n1. 大话设计模式, 第 22 章, 桥接模式"
    },

    {
        "id": "e1c78405-d81c-4054-a277-2d19e3739ba1",
        "title": "LaTeX 数学符号",
        "category": "LaTeX",
        "date": { "year": 2022, "month": 2, "day": 1 },
        "peek": "LaTeX 数学符号大合集",
        "content": "> 2022 年 2 月 1 日\n>\n> 更新于 2022 年 2 月 4 日\n\n## 基本\n\n指数和下标可以用 `^` 和_后加相应字符来实现. 比如: \n\n~~~latex\na_1\\qquad x^2\\qquad e^{-\\alpha t} \\qquad a^3_{ij}\n~~~\n\n$$\na_1\\qquad x^2\\qquad e^{-\\alpha t} \\qquad a^3_{ij}\n$$\n\n平方根（square root）的输入命令为: `\\sqrt`，$n$ 次方根相应地为: `\\sqrt[n]`。方根符号的大小由LATEX自动加以调整。也可用 `\\surd` 仅给出\n符号. 比如:\n\n~~~latex\n\\sqrt{x} \\qquad \\sqrt{x^2 + \\sqrt{y}} \\qquad \\sqrt[3]{2} \\qquad \\surd[x^2 + y^2]\n~~~\n\n$$\n\\sqrt{x} \\qquad \\sqrt{x^2 + \\sqrt{y}} \\qquad \\sqrt[3]{2} \\qquad \\surd[x^2 + y^2]\n$$\n\n命令 `\\overline` 和 `\\underline` 在表达式的上, 下方画出水平线. 比如:\n\n~~~latex\n\\overline{m + n} \\qquad \\underline{m+n}\n~~~\n\n$$\n\\overline{m + n} \\qquad \\underline{m+n}\n$$\n\n命令 `\\overbrace` 和 `\\underbrace` 在表达式的上, 下方给出一水平的大括号.\n\n~~~latex\n\\underbrace{a + b +\\cdots + x}_{26}\n~~~\n\n$$\n\\underbrace{a + b +\\cdots + x}_{26}\n$$\n\n向量 (Vectors) 通常用上方有小箭头 (arrow symbols) 的变量表示。这可由 `\\vec` 得到。另两个命令 `\\overrightarrow` 和 `\\overleftarrow` 在定义从A 到B 的向量时非常有用.\n\n~~~latex\n\\vec a \\qquad \\overrightarrow{AB}\n~~~\n\n$$\n\\vec a \\qquad \\overrightarrow{AB}\n$$\n\n分数使用 `\\frac{...}{...}` 排版。一般来说，1/2 这种形式更受欢迎，因为对于少量的分式，它看起来更好些。\n\n~~~latex\n1\\frac12 \\,\\,\\text{hours}\n~~~\n\n$$\n1\\frac12 \\,\\,\\text{hours}\n$$\n\n积分运算符用 `\\int` 来生成. 求和运算符由 `\\sum` 生成. 乘积运算符由 `\\prod` 生成. 上限和下限用 `^` 和 `_` 来生成, 类似于上标和下标.\n\n~~~latex\n\\sum_{i=1}^n \\qquad \\int_0^{\\frac\\pi 2} \\qquad \\prod_\\epsilon\n~~~\n\n$$\n\\sum_{i=1}^n \\qquad \\int_0^{\\frac\\pi 2} \\qquad \\prod_\\epsilon\n$$\n\n## 希腊字母\n\n### 小写希腊字母\n\n| 符号          | 代码          | 符号        | 代码        | 符号        | 代码       | 符号       | 代码      |\n| ------------- | ------------- | ----------- | ----------- | ----------- | ---------- | ---------- | --------- |\n| $\\alpha$      | `\\alpha`      | $\\theta$    | `\\theta`    | $o$         | `o`        | $\\upsilon$ | `upsilon` |\n| $\\beta$       | `\\beta`       | $\\vartheta$ | `\\vartheta` | $\\pi$       | `\\pi`      | $\\phi$     | `\\phi`    |\n| $\\gamma$      | `\\gamma`      | $\\iota$     | `\\iota`     | $\\varpi$    | `\\varpi`   | $\\varphi$  | `\\varphi` |\n| $\\delta$      | `\\delta`      | $\\kappa$    | `\\kappa`    | $\\rho$      | `\\rho`     | $\\chi$     | `\\chi`    |\n| $\\epsilon$    | `\\epsilon`    | $\\lambda$   | `\\lambda`   | $\\varrho$   | `\\varrho`  | $\\psi$     | `\\psi`    |\n| $\\varepsilon$ | `\\varepsilon` | $\\mu$       | `\\mu`       | $\\sigma$    | `\\sigma`   | $\\omega$   | `\\omega`  |\n| $\\zeta$       | `\\zeta`       | $\\nu$       | `\\nu`       | $\\varsigma$ | `varsigma` |            |           |\n| $\\eta$        | `\\eta`        | $\\xi$       | `\\xi`       | $\\tau$      | `\\tau`     |            |           |\n\n### 大写希腊字母\n\n| 符号     | 代码     | 符号      | 代码      | 符号       | 代码       | 符号     | 代码     |\n| -------- | -------- | --------- | --------- | ---------- | ---------- | -------- | -------- |\n| $\\Gamma$ | `\\Gamma` | $\\Lambda$ | `\\Lambda` | $\\Sigma$   | `\\Sigma`   | $\\Psi$   | `\\Psi`   |\n| $\\Delta$ | `\\Delta` | $\\Xi$     | `\\Xi`     | $\\Upsilon$ | `\\Upsilon` | $\\Omega$ | `\\Omega` |\n| $\\Theta$ | `\\Theta` | $\\Pi$     | `\\Pi`     | $\\Phi$     | `\\Phi`     |          |          |\n\n## 二元关系符\n\n| 符号          | 代码           | 符号          | 代码             | 符号      | 代码            |\n| ------------- | -------------- | ------------- | ---------------- | --------- | --------------- |\n| $<$           | `<`            | $>$           | `>`              | $=$       | `=`             |\n| $\\leq$        | `\\leq` or `le` | $\\geq$        | `\\qeq` or `ge`   | $\\equiv$  | `\\equiv`        |\n| $\\ll$         | `\\ll`          | $\\gg$         | `\\gg`            | $\\doteq$  | `\\doteq`        |\n| $\\prec$       | `\\prec`        | $\\succ$       | `\\succ`          | $\\sim$    | `sim`           |\n| $\\preceq$     | `\\preceq`      | $\\succeq$     | `\\succeq`        | $\\simeq$  | `\\simeq`        |\n| $\\subset$     | `\\subset`      | $\\supset$     | `\\supset`        | $\\approx$ | `\\approx`       |\n| $\\subseteq$   | `\\subseteq`    | $\\supseteq$   | `\\supseteq`      | $\\cong$   | `\\cong`         |\n| $\\sqsubset$   | `\\sqsubset`    | $\\sqsupset$   | `\\sqsupset`      | $\\Join$   | `\\Join`         |\n| $\\sqsubseteq$ | `\\sqsubseteq`  | $\\sqsupseteq$ | `\\sqsupseteq`    | $\\bowtie$ | `\\bowtie`       |\n| $\\in$         | `\\in`          | $\\ni$         | `\\ni` or `\\owns` | $\\propto$ | `\\propto`       |\n| $\\vdash$      | `\\vdash`       | $\\dashv$      | `\\dashv`         | $\\models$ | `\\models`       |\n| $\\mid$        | `\\mid`         | $\\parallel$   | `\\parallel`      | $\\perp$   | `\\perp`         |\n| $\\smile$      | `\\smile`       | $\\frown$      | `\\frown`         | $\\asymp$  | `\\asymp`        |\n| :             | `:`            | $\\notin$      | `\\notin`         | $\\neq$    | `\\neq` or `\\ne` |\n\n## 二元运算符\n\n| 符号             | 代码             | 符号               | 代码                | 符号             | 代码             |\n| ---------------- | ---------------- | ------------------ | ------------------- | ---------------- | ---------------- |\n| $+$              | `+`              | $-$                | `-`                 |                  |                  |\n| $\\pm$            | `\\pm`            | $\\mp$              | `\\mp`               | $\\triangleleft$  | `\\triangleleft`  |\n| $\\cdot$          | `\\cdot`          | $\\div$             | `\\div`              | $\\triangleright$ | `\\triangleright` |\n| $\\times$         | `\\times`         | $\\setminus$        | `setminus`          | $\\star$          | `\\star`          |\n| $\\cup$           | `\\cup`           | $\\cap$             | `\\cap`              | $\\ast$           | `\\ast`           |\n| $\\sqcup$         | `\\sqcup`         | $\\sqcap$           | `\\sqcap`            | $\\circ$          | `\\circ`          |\n| $\\vee$           | `\\vee` or `\\lor` | $\\wedge$           | `\\wedge` or `\\land` | $\\bullet$        | `\\bullet`        |\n| $\\oplus$         | `\\oplus`         | $\\ominus$          | `\\ominus`           | $\\diamond$       | `\\diamond`       |\n| $\\odot$          | `\\odot`          | $\\oslash$          | `\\obashslash`       | $\\uplus$         | `\\uplus`         |\n| $\\otimes$        | `\\otimes`        | $\\bigcirc$         | `\\bigcirc`          | $\\amalg$         | `\\amag`          |\n| $\\bigtriangleup$ | `\\bigtriangleup` | $\\bigtriangledown$ | `\\bigtriangledown`  | $\\dagger$        | `\\dagger`        |\n| $\\lhd$           | `\\lhd`           | $\\rhd$             | `\\rhd`              | $\\ddagger$       | `\\ddagger`       |\n| $\\unlhd$         | `\\unlhd`         | $\\unrhd$           | `\\rhdeq`            | $\\wr$            | `\\wr`            |\n\n## 箭头\n\n| 符号                 | 代码                    | 符号                  | 代码                  | 符号           | 代码           |\n| -------------------- | ----------------------- | --------------------- | --------------------- | -------------- | -------------- |\n| $\\leftarrow$         | `\\leftarrow` or `\\gets` | $\\longleftarrow$      | `\\longleftarrow`      | $\\uparrow$     | `\\uparrow`     |\n| $\\rightarrow$        | `\\rightarrow` or `\\to`  | $\\longrightarrow$     | `\\longrightarrow`     | $\\downarrow$   | `\\downarrow`   |\n| $\\leftrightarrow$    | `\\leftrightarrow`       | $\\longleftrightarrow$ | `\\longleftrightarrow` | $\\updownarrow$ | `\\updownarrow` |\n| $\\Leftarrow$         | `\\Leftarrow`            | $\\Longleftarrow$      | `\\Longleftarrow`      | $\\Uparrow$     | `\\Uparrow`     |\n| $\\Rightarrow$        | `\\Rightarrow`           | $\\Longrightarrow$     | `\\Longrightarrow`     | $\\Downarrow$   | `\\Downarrow`   |\n| $\\Leftrightarrow$    | `\\Leftrightarrow`       | $\\Longleftrightarrow$ | `\\Longleftrightarrow` | $\\Updownarrow$ | `\\Updownarrow` |\n| $\\mapsto$            | `\\mapsto`               | $\\longmapsto$         | `longmapsto`          | $\\nearrow$     | `\\nearrow`     |\n| $\\hookleftarrow$     | `\\hookleftarrow`        | $\\hookrightarrow$     | `\\hookrightarrow`     | $\\searrow$     | `\\searrow`     |\n| $\\leftharpoonup$     | `\\leftharpoonup`        | $\\rightharpoonup$     | `\\rightharpoondown`   | $\\swarrow$     | `\\swarrow`     |\n| $\\leftharpoondown$   | `\\leftharpoondown`      | $\\rightharpoondown$   | `\\rightharpoondown`   | $\\nwarrow$     | `\\nwarrow`     |\n| $\\rightleftharpoons$ | `\\rightleftharpoons`    | $\\iff$                | `\\iff`                | $\\leadsto$     | `\\leadsto`     |\n\n## 定界符\n\n| 符号      | 代码              | 符号      | 代码              | 符号      | 代码           | 符号         | 代码         |\n| --------- | ----------------- | --------- | ----------------- | --------- | -------------- | ------------ | ------------ |\n| $($       | `(`               | $)$       | `)`               | \\|      | `\\|` 或 `\\vert` | $\\Vert$      | `\\Vert`      |\n| $[$       | `[` 或 `\\lbrack`  | `]`       | `]` 或 `\\rbrack`  | $\\lceil$  | `\\lceil`       | $\\rceil$     | `\\rceil`     |\n| $\\{$      | `\\{` 或 `\\lbrace` | $\\}$      | `\\}` 或 `\\rbrace` | $\\lfloor$ | `\\lfloor`      | $\\rfloor$    | `\\rfloor`    |\n| $\\langle$ | `\\langle`         | $\\rangle$ | `\\rangle`         | $/$       | `/`            | $\\backslash$ | `\\backslash` |\n\n\n\n## 参考资料\n\n1. [常用数学符号的 LaTeX 表示方法](https://www.mohu.org/info/symbols/symbols.htm)\n\n"
    },

    {
        "id": "965e0dbf-16b3-4e15-9c13-32aa6f765ac1",
        "title": "多项分布",
        "category": "统计",
        "date": { "year": 2022, "month": 2, "day": 1 },
        "peek": "多项分布, 英文为 Multinomial Distribution",
        "content": "\n\n> 2022 年 2 月 1 日\n\n多项分布, 英文为 Multinomial Distribution.\n\n简单地说, 假设做一次试验会有 $c$ 种结果, 且每种结果都有各自发生的概率. 做 $n$ 次这样的试验, 得到各种试验结果的次数的分布. 如果 $c = 2$, 那么就是一个二项分布. 所以, 多项分布就是二项分布的延伸, 换句话说, 二项分布是多项分布的一个特例.\n\n**PMF**\n$$\n\\displaystyle \n{\n  \\begin{aligned}\n    f(x_{1},\\ldots ,x_{k};n,p_{1},\\ldots ,p_{k})&{}=\\Pr(X_{1}=x_{1}{\\text{ and }}\\dots {\\text{ and }}X_{k}=x_{k})\\\\\n    &{}={\n      \\begin{cases}\n        {\\displaystyle {n! \\over x_{1}!\\cdots x_{k}!}p_{1}^{x_{1}}\\times \\cdots \\times p_{k}^{x_{k}}},\\quad     &{\\text{when }}\\sum _{i=1}^{k}x_{i}=n\\\\\\\\\n        0    &{\\text{otherwise,}}\n      \\end{cases}\n    }\n  \\end{aligned}\n}\n$$\n\n> **参数列表**\n>\n> $x_i$ : 第 $i$ 种结果; $p_k$ : 第 $i$ 种结果发生的概率; $n$ : 总试验次数\n\n**期望值和方差**\n\n第 $i$ 种结果在 $n$ 次试验中出现的次数为:\n\n$E(X_i) = np_i$.\n\n方差:\n\n${\\displaystyle \\operatorname {Var} (X_{i})=np_{i}(1-p_{i}).\\,}$\n\n## 参考资料\n\n1. [维基百科 - 多项分布](https://en.wikipedia.org/wiki/Multinomial_distribution)\n\n"
    },

    {
        "id": "b52bcc16-79dc-41b6-9c0d-a7886187495c",
        "title": "中庸 (中国古代儒家经典)",
        "category": "国学",
        "date": { "year": 2022, "month": 1, "day": 30 },
        "peek": "《中庸》是中国古代论述人生修养境界的一部道德哲学专著，是儒家经典之一",
        "content": "> 2022 年 1 月 30 日\n\n## 简介$^1$\n\n《中庸》是中国古代论述人生修养境界的一部道德哲学专著，是[儒家经典](https://baike.baidu.com/item/儒家经典/7329675)之一，原属《[礼记](https://baike.baidu.com/item/礼记/1332574)》第三十一篇，相传为[战国](https://baike.baidu.com/item/战国/4819)时期[子思](https://baike.baidu.com/item/子思/481166)所作。其内容肯定“中庸”是道德行为的最高标准，认为“至诚”则达到人生的最高境界，并提出“博学之，审问之，慎思之，明辨之，笃行之”的学习过程和认识方法。\n\n## 原文和译文$^1$\n\n天命之谓性，率性之谓道，修道之谓教。道也者，不可须臾离也，可离非道也。是故君子戒慎乎其所不睹，恐惧乎其所不闻。莫见乎隐，莫显乎微，故君子慎其独也。喜怒哀乐之未发，谓之中；发而皆中节，谓之和；中也者，天下之大本也；和也者，天下之达道也。致中和，天地位焉，万物育焉。\n\n> 天所赋予人的东西就是性，遵循天性就是道，遵循道来修养自身就是教。道是片刻不能离开的，可离开的就不是道。因此，君子在无人看见的地方也要小心谨慎，在无人听得到的地方也要恐惧敬畏。隐蔽时也会被人发现，细微处也会昭著，因此君子在独处时要慎重。喜怒哀乐的情绪没有表露出来，这叫做中。表露出来但合干法度，这叫做和。中是天下最为根本的，和是天下共同遵循的法度。达到了中和，天地便各归其位，万物便生长发育了。\n\n仲尼曰：“君子中庸，小人反中庸，君子之中庸也，君子而时中；小人之中庸也，小人而无忌惮也。”\n\n> 孔子说：“君子的言行符合中庸，小人的言行却违反中庸。君子的言行符合中庸，因为君子的言行时刻都不偏不倚。小人的言行违反中庸，因为小人的言行无所顾忌、无所畏惧。”\n\n子曰：“中庸其至矣乎！民鲜能久矣！”\n\n> 孔子说：“中庸是最高的境界，人们很少能够长期实行它。”\n\n子曰：“道之不行也，我知之矣：知者过之，愚者不及也。道之不明也，我知之矣：贤者过之，不肖者不及也。人莫不饮食也，鲜能知味也。”\n\n> 孔子说：“中庸之道不能被实行，我是知晓的啊：有智慧的人做得太过分，愚昧的人达不到它。中庸之道不能被发扬，我是知晓的啊：贤明的人做得太过分，不贤明的人达不到它。这就好像人没有不吃饭的，但能够品尝滋味的人却非常少。”\n\n子曰：“道其不行矣夫！”\n\n> 孔子说：“恐怕中庸之道是不能实施的了。”\n\n子曰：“舜其大知也与！舜好问而好察迩言，隐恶而扬善，执其两端，用其中于民，其斯以为舜乎！”\n\n> 孔子说：“舜是有大智慧啊！他喜欢询问且喜欢审察那些浅近的话，他隐瞒别人的坏处，表扬别人的好处。他掌握好两个极端，对人民使用折中的办法，这就是为何他被尊称为舜啊！”\n\n子曰：“人皆曰予知，驱而纳诸罟擭陷阱之中，而莫之知辟也。人皆曰予知，择乎中庸，而不能期月守也。”\n\n> 孔子说：“人们都说‘我是有智慧的’，但他们被驱使而落入鱼网、木笼和陷阱之中，却不知道躲闪。人们都说‘我是有智慧的’，但他们选择了中庸之道，却不能坚持一个月。”\n\n子曰：“回之为人也，择乎中庸，得一善，则拳拳服膺而弗失之矣。“\n\n> 孔子说：“颜回是这样做人的，他选择了中庸之道。得到一条善理，他就牢牢记在心上而不失掉它。”\n\n子曰：“天下国家可均也，爵禄可辞也，白刃可蹈也，中庸不可能也。”\n\n> 孔子说：“天下国家是可以公正治理的，爵位俸禄是可以辞掉的，利刃是可以踩上去的，只是中庸之道不容易实行。”\n\n子路问强，子曰：“南方之强与？北方之强与？抑而强与？宽柔以教，不报无道，南方之强也，君子居之。衽金革，死而不厌，北方之强也，而强者居之。故君子和而不流，强哉矫！中立而不倚，强哉矫！国有道，不变塞焉，强哉矫！国无道，至死不变，强哉矫！”\n\n> 子路问什么是强大。孔子说：“你问的是南方的强大呢？还是北方的强大呢？或者是你所认为的强大？用宽容温柔的态度去教化，对无理的行为不施行报复，这是南方的强大，君子就属于这类。头枕武器、盔甲睡觉，死不反悔，这是北方的强大，强悍的人属于这一类。因此，君子要随和但不随波逐流，这才是真正的强大! 独立而不偏不倚，这才是真正的强大！国家政治清明，不改变志向，这才是真正的强大！国家政治晦暗，至死不变节，这才是强大的！”\n\n子曰：“素隐行怪，后世有述焉，吾弗为之矣。君子遵道而行，半涂而废，吾弗能已矣。君子依乎中庸，遁世不见知而不悔，唯圣者能之。”\n\n> 孔子说：“追求生僻的道理，行为荒诞不经，后代对此会有所称述，但我不这样去做。君子依循中庸之道行事，半途而废，而我是不会停止的。君子依靠中庸之道行事，虽然在世上声迹少闻，不为人知，但不后悔，只有圣人才能做到这一点。”\n\n君子之道，费而隐。夫妇之愚，可以与知焉，及其至也，虽圣人亦有所不知焉。夫妇之不肖，可以能行焉；及其至也，虽圣人亦有所不能焉。天地之大也，人犹有所憾。故君子语大，天下莫能载焉；语小，天下莫能破焉。《诗》云：“鸢飞戾天，鱼跃于渊。”言其上下察也。君子之道，造端乎夫妇，及其至也，察乎天地。\n\n> 君子所奉行的道既广大又精微。黎民百姓虽然愚昧但还是可以知道它的，但至于最高境界的道，即使圣人也有不知晓的地方。普通百姓虽然不贤明，但还是可以实行它，但至于最高境界的道，即使圣人也有不能做到的地方。天地如此之大，但人仍有不满意的地方。因此，君子说的“大”，天下都载不起；君子说的“小”，天下都不能够理解。《诗经》上说：“鸢在天空上飞翔，鱼在深水处跳跃。”这是说君子的中庸之道在天地上下之间都是显豁的。君子所奉行的道，发端于普通百姓，在达到最高境界时便彰著于天地之间。\n\n子曰：“道不远人，人之为道而远人，不可以为道。《诗》云：‘伐柯，伐柯，其则不远。’执柯以伐柯，睨而视之，犹以为远。故君子以人治人，改而止。忠恕违道不远，施诸己而不愿，亦勿施于人。君子之道四，丘未能一焉，所求乎子，以事父，未能也；所求乎臣，以事君，未能也；所求乎弟，以事兄，未能也；所求乎朋友，先施之，未能也。庸德之行，庸言之谨；有所不足，不敢不勉，有余，不敢尽；言顾行，行顾言，君子胡不慥慥尔！”\n\n> 孔子说：“中庸之道不远离人。人去实行中庸之道却远离了人，他就不是在实行中庸之道。《诗经》上说：‘砍伐斧柄，砍伐斧柄，斧柄制作的方法就在手边。’手握斧柄伐木制斧柄，斜着眼审度两者，仍然觉得相差太远。所以，君子应以对待人的方式治理人，直到他们改正为止。忠恕与道不远，不愿施于己身的，也不要施与别人。君子所奉行的道有四条，我孔丘一条都做不到。对侍奉父亲的儿子所要求的，我尚未做到；对侍奉国君的臣下所要求的，我尚未做到，对侍奉兄长的弟弟所要求的，我尚未做到；要求朋友做到的自己先做，我尚未做到。在日常德行的实施方面，在日常语言的慎重方面，我做得还不好，不敢不继续努力，即使有做得完满的地方也不敢把话说尽。言语要照顾到行为，行为要照顾到言语，君子怎么能不笃实忠厚呢？”\n\n君子素其位而行，不愿乎其外。素富贵，行乎富贵；素贫贱，行乎贫贱；素夷狄，行乎夷狄；素患难行乎患难，君子无入而不自得焉。在上位不陵下，在下位不援上，正己而不求于人，则无怨。上不怨天，下不尤人。故君子居易以俟命。小人行险以徼幸。子曰：“射有似乎君子，失诸正鹄，反求诸其身。”\n\n> 君子安于目前的地位做他所应该做的事，不羡慕自己地位以外的东西。地位富贵，就做富贵人做的事；地位贫贱，就做贫贱人应该做的事，处在夷狄的地位上，就做夷狄应该做的事；处在患难的地位上，就做患难时应该做的事。如此，君子无处不感觉到悠然自得。居上位，不欺凌下级。在下位，不攀附上级。端正自己不苛求他人，这样就没有怨恨，对上不怨恨天命，对下不归咎别人。所以，君子安于自己的地位等候天命的到来，小人则冒险求得本不应该获取的东西。孔子说：“射箭的道理与君子的行为有相似的地方：假如没有射中靶子，就应反过来责求自己。\n\n君子之道，辟如行远必自迩，辟如登高必自卑。《诗》曰：“妻子好合，如鼓瑟琴。兄弟既翕，和乐且耽。宜尔室家，乐尔妻帑。”子曰：“父母其顺矣乎！”\n\n> 实行君子的中庸之道，就好像是走远路，必须从近处开始，就如同是登高，必须从低处开始。《诗经》上说：‘夫妻情投意合，协调有如琴瑟，兄弟和睦相处，快乐安顺长久。家庭美满，妻儿愉快。”孔子说：“这样父母是多舒畅啊！”\n\n子曰：“鬼神之为德，其盛矣乎？视之而弗见，听之而弗闻，体物而不可遗，使天下之人齐明盛服，以承祭祀。洋洋乎如在其上，如在其左右。《诗》曰：‘神之格思，不可度思！矧可射思！’夫微之显，诚之不可掩如此夫。”\n\n> 孔子说：“鬼神的功用真是宏大啊！看，看不到它；听，听不到它。它养育万物，没有一种事物可以遗弃它。它使天下的人斋戒沐浴，身穿华丽的祭服，举行祭祀典礼。它浩浩荡荡，好像在天之上，在人身旁。《诗经》上说：‘鬼神来到，不可揣测，不敢对它厌怠不敬啊！’从隐微到明显，真诚的心意就是这样隐藏不住啊。”\n\n子曰：“舜其大孝也与！德为圣人，尊为天子，富有四海之内。宗庙飨之，子孙保之。故大德必得其位，必得其禄。必得其名，必得其寿，故天之生物，必因其材而笃焉。故栽者培之，倾者覆之。《诗》曰：‘嘉乐君子，宪宪令德。宜民宜人，受禄于天，保佑命之，自天申之。’故大德者必受命。”\n\n> 孔子说：“舜可是个最孝敬的人吧！有圣人的德行，有天子的尊贵地位，有普天下的财富。宗庙祭他，子孙维护他。因此，有崇高德行的人必然会获得应有的地位，必然会获得应有的俸禄，必然会获得应有的名望，必定会获得应有的为命。因此，上天生育的万物，必会因为它们的资质而受到厚爱。所以，能够栽培的就培养它们，而歪斜的就让它们歪斜。《诗经》上说：‘快快乐乐的君子，美德盛明。让上下都感受快乐，上天赐给他福禄。保佑他，任用他，上天这样告诫。’因此，有伟大的德行的人一定是受了天命的。”\n\n子曰：“无忧者，其惟文王乎！以王季为父，以武王为子，父作之，子述之。武王缵大王、王季、文王之绪，壹戎衣而有天下。身不失天下之显名，尊为天子，富有四海之内。宗庙飨之，子孙保之。武王末受命，周公成文、武之德，追王大王、王季，上祀先公以天子之礼。斯礼也，达乎诸侯大夫，及士庶人。父为大夫，子为士，葬以大夫，祭以士。父为士，子为大夫，葬以士，祭以大夫。期之丧，达乎大夫。三年之丧，达乎天子。父母之丧，无贵贱一也。”\n\n>孔子说：“恐怕只有周文王是个无忧无虑的人吧！王季是他的父亲，周武王是他的儿子。他有父亲开创事业，有儿子继承事业。周武王继续着大王、王季、文王未完成的功业，披挂战衣，取得了天下。他没有失去自己显赫的名声，获得了天子的尊贵，获得了普天下的财富。宗庙祭奉他，子孙维护他。武王年迈的时候才承受天命。周公成就了文王、武王的德业，追尊大王、王季为王，用天子的礼制祭祀祖先。这种礼制一直贯彻到诸侯、大夫、士和普通百姓。假如父亲是大夫，儿子是士，父死就要按大夫的礼制安葬，按士的礼制祭祀。如果父亲是士，儿子是大夫，父死就要按士的礼制安葬，按大夫的礼制祭祀，守丧一年，通行到大夫；守丧三年，通行到天子。但给父母守丧本身没有贵贱的区别，都是一样的。”\n\n子曰：“武王、周公，其达孝矣乎！夫孝者，善继人之志，善述人之事者也。春秋修其祖庙，陈其宗器，设其裳衣，荐其时食。宗庙之礼，所以序昭穆也。序爵，所以辨贵贱也。序事，所以辨贤也。旅酬下为上，所以逮贱也。燕毛，所以序齿也。践其位，行其礼，奏其乐，敬其所尊，爱其所亲，事死如事生，事亡如事存，孝之至也。郊社之礼，所以事上帝也。宗庙之礼，所以祀乎其先也。明乎郊社之礼、禘尝之义，治国其如示诸掌乎！”\n\n> 孔子说：“武王，周公真是最守孝道的人啊！守孝道的人，善于继承先人的遗志，善于继承先人未完的功业。在春秋两季，修缮祖上庙宇，陈列祭祀器具，摆设祭祀服饰，贡献应时的食品。宗庙祭祀的礼制，是要排列父子、长幼的顺序。按官爵排列次序，就可以分辨出贵贱，按职位排列次序，就能分辨出贤与不贤；敬酒时晚辈先向长辈举杯，这样祖先的恩惠就会延及到晚辈，宴饮时按头发的黑白次序坐，这样就使老少有次序。站在应该站的位置上，行先王传下的祭礼，演奏先王的音乐，尊敬先王所尊敬的，亲爱先王所亲爱的。侍奉死者如同侍奉活着的人，侍奉亡故的人如同侍奉现存的人，这是最高境界的孝啊。郊社祭礼。是用于侍奉上天的。庙宇的祭礼，是祭祀祖先的。明白了郊社的祭礼，大祭小祭的意义，治理国家就如同看手掌一样容易吧！”\n\n哀公问政。子曰：“文武之政，布在方策。其人存，则其政举；其人亡，则其政息。人道敏政，地道敏树。夫政也者，蒲卢也。故为政在人，取人以身，修身以道，修道以仁。仁者人也。亲亲为大；义者宜也。尊贤为大。亲亲之杀，尊贤之等，礼所生也。在下位不获乎上，民不可得而治矣！故君子不可以不修身；思修身，不可以不事亲；思事亲，不可以不知人，思知人，不可以不知天。天下之达道五，所以行之者三。曰：君臣也，父子也，夫妇也，昆弟也，朋友之交也，五者天下之达道也。知，仁，勇，三者天下之达德也，所以行之者一也。或生而知之，或学而知之，或困而知之，及其知之一也。或安而行之，或利而行之，或勉强而行之，及其成功，一也。”子曰：“好学近乎知，力行近乎仁，知耻近乎勇。知斯三者，则知所以修身；知所以修身，则知所以治人；知所以治人，则知所以治天下国家矣。\n\n> 鲁哀公问孔子如何治理好政事。孔子说：“文王、武王的政令，都写在木板竹简上。像他们那样有贤臣，政令就会得到贯彻施行，没有贤臣，政令就会消失。以人立政，政治就会迅速清明，这就像用沃土植树，树木会迅速生长。这政事啊，就好像是蒲苇。因此，治理政事取决于贤臣，贤臣的获得取决于明君的修德养性，修养德行取决于遵循天下的大道，遵循天下大道取决于仁爱之心。所谓仁，就是人，亲爱亲人是最大的仁。所谓义，就是相宜，尊重贤臣是最大的义。亲爱亲人时的亲疏之分，尊重贤臣时的等级划分，是从礼制中产生出来的。处在下位的人得不到上级的信任，人民就不可能治理好了。因此，君子不能不修德养性想要修德养性，不能不侍奉亲人，想要侍奉亲人，不能不知贤善用，想要知贤善用，不能不知道天理。普天下的大道有五种，实践大道的美德有三种。君臣、父子、夫妇、兄弟、朋友交往，这五项是天下的大道。智慧、仁爱、英勇这三者是天下的大德行。实践大道的道理是同样的。有的人生来就通晓大道，有的人通过学习才通晓大道，有的人经历过困惑后才通晓大道；他们最终通晓大道，这是同样的。有的人从容不迫地实行大道，有的人凭着利害关系去实行大道，有的人勉强去实行大道，最终成功的时候是一样的。”孔子又说：“喜爱学习就接近智慧了，尽力去实行就接近仁爱了，知晓羞耻就接近英勇了。知道这三点，就知道如何修养德行；知道怎样修养德行，就知道怎样治理人，知道怎样治理人，就知道怎样治理国家了。治理天下国家大凡有九条准则，分别是修养德行、尊重贤人、亲爱亲族、敬重大臣、体贴众臣、爱民如子、招集各种工匠、优待边远异族、安抚四方的诸侯。修养德行，大道就能够顺利实行。尊重贤人就不会被迷惑。亲爱亲族，父、兄、弟就不会抱怨。敬重大臣，处事就不会恍惚不定。体贴众臣，士就会以重礼相报。爱民如子，百姓就会勤奋努力。招集各种工匠，财富用度就充足。优待边远异族，四方就会、归顺。安抚各诸侯，普天下就会敬畏。清心寡欲，服饰端正，无礼的事不做，这是修养德行的方法；摒弃谗言，远离美色，轻视财物重视德行，这是勉励贤人的方法；尊崇亲族的地位，重赐他们俸禄，与亲族有共同的爱和恨，这是尽力亲爱亲族的方法，为大臣多设下官以供任用，这是鼓励大臣的方法，以忠诚信实、最重俸禄相待，这是勉励士的方法；根据节令使役，赋税微薄，这是鼓励百姓的方法，日日访视，月月考查，赠送给他们的粮食与他们的工作相称，这是鼓励工匠的方法；盛情相迎，热情相送，奖励有才干的，同情才干不足的，这是优待边远异族的方法。承续中断的家庭世系，复兴没落的国家，整治混乱，解救危难，定期朝见聘问，赠礼丰厚，纳贡微薄，这是安抚诸侯的方法。\n\n凡为天下国家有九经，曰：修身也。尊贤也，亲亲也，敬大臣也，体群臣也。子庶民也，来百工也，柔远人也，怀诸侯也。修身则道立，尊贤则不惑，亲亲则诸父昆弟不怨，敬大臣则不眩，体群臣则士之报礼重，子庶民则百姓劝，来百工则财用足，柔远人则四方归之，怀诸侯则天下畏之。齐明盛服，非礼不动。所以修身也；去谗远色，贱货而贵德，所以劝贤也；尊其位，重其禄，同其好恶，所以劝亲亲也；官盛任使，所以劝大臣也；忠信重禄，所以劝士也；时使薄敛，所以劝百姓也；日省月试，既廪称事，所以劝百工也；送往迎来，嘉善而矜不能，所以柔远人也；继绝世，举废国，治乱持危。朝聘以时，厚往而薄来，所以怀诸侯也。凡为天下国家有九经，所以行之者一也。凡事豫则立，不豫则废。言前定则不跲，事前定则不困，行前定则不疚，道前定则不穷。在下位不获乎上，民不可得而治矣。获乎上有道，不信乎朋友，不获乎上矣；信乎朋友有道，不顺乎亲，不信乎朋友矣；顺乎亲有道，反诸身不诚，不顺乎亲矣；诚身有道，不明乎善，不诚乎身矣。诚者，天之道也；诚之者，人之道也。诚者不勉而中，不思而得，从容中道，圣人也。诚之者，择善而固执之者也。博学之，审问之，慎思之，明辨之，笃行之。有弗学，学之弗能，弗措也；有弗问，问之弗知，弗措也；有弗思，思之弗得，弗措也；有弗辨，辨之弗明，弗措也；有弗行，行之弗笃，弗措也。人一能之己百之，人十能之己千之。果能此道矣。虽愚必明，虽柔必强。”\n\n> 尽管治理天下国家共有这九条准则，但实行它们的道理是相同的。凡事有预谋就会成功，没有预谋就会失败。说话事先想好就不会语塞，做事事先想好就不会感到困难。行动之前事先想好就不会内心不安，法则事先想好就不会陷入绝境。在下位的人得不到上级的信任，百姓就治理不好。得到上级的信任是有途径的，得不到朋友的信任就得不到上级的信任。得到朋友的信任是有途径的，不顺从父母就得不到朋友的信任。顺从父母是有途径的，自己心不诚就不能顺从父母。心诚是有途径的，不知晓善就不能心诚。诚实是上天的法则。做到诚实是人的法则。诚实，不必努力就能达到，不必思考就能获得，从容不迫地达到天道法则，这就是圣人。做到诚实，就是选择善并坚持做到它。要广泛地学习，仔细地询问，审慎地思考，清晰地分辨，忠实地实践。要么就不学，学了没有学会就不中止。要么就不问，问了还不明白就不中止。要么就不思考，思考了不懂得就不中止。要么就不辨别，辨别了不分明就不中止。要么就不实行，实行了但不够忠实就不中止。别人一次能做的，我用百倍的工夫，别人十次能做的，我用千倍的工夫。如果真能这样做，即便愚笨也会变得聪明，即使柔弱也会变得刚强。”\n\n自诚明谓之性。自明诚谓之教。诚则明矣，明则诚矣。\n\n> 由真诚达到通晓事理，这叫天性。由通晓事理达到真诚，这叫教化。真诚就会通晓事理，通晓事理就会真诚。\n\n唯天下至诚，为能尽其性；能尽其性，则能尽人之性；能尽人之性，则能尽物之性；能尽物之性，则可以赞天地之化育；可以赞天地之化育，则可以与天地参矣。\n\n> 只有天下最真诚的人才能充分发挥天赋的本性，能发挥天赋的本性才能发挥所有人的本性，能发挥所有人的本性才能充分发挥事物的本性，能够发挥事物的本性才能帮助天地养育万物，可以帮助天地养育万物，才可以与天地并列。\n\n其次致曲。曲能有诚，诚则形，形则著，著则明，明则动，动则变，变则化。唯天下至诚为能化。\n\n> 次一等真诚的人从细微处人手。细微之处也能达到诚的境界，达到真诚就会表现出来，表现出来就会昭然显著，昭然显著就会光辉明亮，光辉明亮就会感动万物，感动万物就会发生变革，发生变革就会感化人们。只有天下最真诚的人才能感化人们。\n\n至诚之道，可以前知。国家将兴，必有祯祥；国家将亡，必有妖孽。见乎蓍龟。，动乎四体。祸福将至，善必先知之；不善必先知之。故至诚如神。\n\n> 最高境界的真诚可以预知未来。国家将要兴盛，必定有吉祥的前兆；国家将要衰败，必定有妖孽作怪。它呈现在蓍草龟甲上，体现在身体仪态上。祸福要来临时：好事一定会提前知道，不好的事也一定提前知道。因此，最高境界的真诚如同神灵一般。\n\n诚者，自成也。而道，自道也。诚者物之终始，不诚无物。是故君子诚之为贵。诚者非自成己而已也，所以成物也。成己仁也；成物知也。性之德也，合外内之道也，故时措之宜也。\n\n> 真诚，是自己成全自己。道，是自己引导自己。真诚贯穿万物的始终，没有真诚就没有万物。因此，君子把真诚看得非常珍贵。真诚，并不只是成全自己就完了，还要成全万物。成全自己是仁义，成全万物是智慧。这是发自本性的德行，是结合了内外的道，因此，适合在任何时候实行。\n\n故至诚无息，不息则久，久则征；征则悠远，悠远则博厚，博厚则高明。博厚所以载物也；高明所以覆物也；悠久所以成物也。博厚配地，高明配天，悠久无疆。如此者不见而章，不动而变，无为而成。天地之道，可一言而尽也。其为物不贰，则其生物不测。天地之道，博也，厚也，高也，明也，悠也，久也。今夫天，斯昭昭之多，及其无穷也，日月星辰系焉，万物覆焉。今夫地，一撮土之多。及其广厚，载华岳而不重，振河海而不泄，万物载焉。今夫山，一卷石之多，及其广大，草木生之，禽兽居之，宝藏兴焉，今夫水，一勺之多，及其不测，鼋、鼍、蛟龙、鱼鳖生焉，货财殖焉。《诗》曰：“惟天之命，于穆不已！”盖曰天之所以为天也。“于乎不显，文王之德之纯！”盖曰文王之所以为文也，纯亦不已。\n\n> 所以，最高境界的真诚是永不休止的。永不休止就会长久，长久就会有效验，有效验就会深远无穷，深远无穷就会博大深厚，博大深厚就会高大光明。博大深厚，能够负载万物；高大光明，可以覆盖万物；深远无穷，可以生成万物。博大深厚与地相配，高大光明与天相配，深远长久可以无穷无尽。这样，不表现也会显著，不行动也有改变，不做也会成功。天地的法则，可以用一句话涵盖：作为物它纯一不二，因而它化生万物就不可测度了。天地的法则，博大、深厚、高大、光明、涤远、长久。现在来说天，论小它不过是一小片光明，而它的整体无穷无尽，日月星辰悬挂在天上，覆盖着万物。现在来说地，论小它不过是一小撮土，而它的整体广大深厚，负载着华山不觉得重，收拢着江河湖海没有泄，负载着万物。现在来说山，论小这不过是一小块石头，但它整体高峻厚重，草木生长在上面，飞禽走兽居住在上面，宝藏从里面开发出来。现在来说水，论小它不过是一小勺水，但它的整体深不可测，里面生活着鼋鼍、蛟龙、鱼鳖，繁殖着货物财富。\n\n大哉，圣人之道！洋洋乎，发育万物，峻极于天。优优大哉！礼仪三百，威仪三千。待其人然后行。故曰：苟不至德，至道不凝焉。故君子尊德性而道问学。致广大而尽精微。极高明而道中庸。温故而知新，敦厚以崇礼。是故居上不骄，为下不倍；国有道，其言足以兴；国无道，其默足以容。《诗》曰：“既明且哲，以保其身。”其此之谓与！\n\n> 《诗经》上说：“只有上天的定命，深远不止。”这大概是说天之所以成为天的原因。啊，难道不光明！文王的德行这么纯洁，这大概是说文王之所以被尊奉为文王，是因为他纯一，而且永无止境。伟大啊，圣人的道。浩浩荡荡，生长发育万物，与天一样高峻。充足而且伟大啊，三百条礼仪，三千条威仪，等待圣人出现后才能实施。因此说，如果达不到最高境界的道德，最高境界的道就不会成功。所以，君子应当尊奉德行，善学好问，达到宽广博大的境界同时又深入到细微之处，达到极端的高明同时又遵循中庸之道。温习过去所学习过的从而获取新的认识，用朴实厚道的态度尊崇礼仪。这样，在上位时不骄傲，在下位时不背弃。国家政治清明时力争主张被接受采纳，国家政治黑暗时以沉默保全自己。《诗经》上“既明达又聪慧，这样才能保全自身”这句话，说的就是这个意思吧！\n\n子曰：“愚而好自用，贱而好自专，生乎今之世，反古之道：如此者，灾及其身者也。”非天子，不议礼，不制度，不考文。今天下车同轨，书同文，行同伦。虽有其位，苟无其德，不敢作礼乐焉；虽有其德。苟无其位，亦不敢作礼乐焉。子曰：“吾说夏礼，杞不足徵也。吾学殷礼，有宋存焉。吾学周礼，今用之，吾从周。”\n\n> 孔子说：“愚蠢但又只凭主观意图行事，卑贱但又好独断专行，生活在现在这个时代，却要恢复古代的做法，这样的话，灾难就要降临在他身上了。”不是天子，就不议论礼制，不制定制度，不考核文字。现在普天下车辙统一，文字统一，伦理观念统一。虽然有天子的地位，但如果没有天子的德行，就不要轻易制礼作乐，虽有天子的德行，但是如果没有天子的地位，也不要轻易制礼作乐。孔子说：“我解说夏代的礼法，但杞国的文献不足以验证。我学习殷朝的礼法，仅仅有宋国保持着它。我学习周代的礼法，现在正实行着它，因此，我遵从周代的礼法。”\n\n“王天下有三重焉，其寡过矣乎！上焉者虽善无徵，无徵不信，不信民弗从；下焉者虽善不尊，不尊不信，不信民弗从。故君子之道：本诸身，徵诸庶民，考诸三王而不缪，建诸天地而不悖，质诸鬼神而无疑，百世以俟圣人而不惑。质诸鬼神而无疑，知天也；百世以俟圣人而不惑，知人也。是故君子动而世为天下道，行而世为天下法，言而世为天下则。远之则有望，近之则不厌。《诗》曰：‘在彼无恶，在此无射。庶几夙夜，以永终誉！’君子未有不如此，而蚤有誉于天下者。”\n\n> “统治天下要做三件重要的事情，做好了就会减少损失。居于上位的人，品德虽好但没有验证，没有验证就不权威，不权威百姓就不会服从；居于下位的人，品德虽好，但不尊贵，不尊贵就不权威，不权威百姓就不服从。因此，君子的道，根本在自身，在黎民百姓那里得到验证，考查到三代先王不显现出错误，树立在天地之间没有悖理的地方，卜问鬼神没有可疑的地方，等到百世以后圣人到来不感到困惑。卜问鬼神没有可疑的地方，这是了解了天，等到百世以后圣人到来不感到困惑，这是了解了人。因此，君子的举动能世世代代成为天下的法则，君子的行为能世世代代成为天下的法度，君子的言谈能世世代代成为天下的准则。离得远使人仰慕，离得近也不让人厌烦。《诗经》上说：‘在那里无人厌恶，在这里不遭人厌恨。几乎是日夜操劳，这样永远保持大家的称赞。’君子没有不先做到这一点就早已闻名于天下的。”\n\n仲尼祖述尧舜，宪章文武：上律天时，下袭水土。辟如天地之无不持载，无不覆帱，辟如四时之错行，如日月之代明。万物并育而不相害，道并行而不相悖，小德川流，大德敦化，此天地之所以为大也。\n\n> 孔子遵循尧、舜的传统，模仿文王、武王。上遵从天时变化，下符合地理位置，好像天地没有什么不能负载，没有什么不能覆盖的，又好像四季的更替运行，日月交替光明，万物同时生长发育互不伤害，天地的道同时运行而互不违背。小德如江河流行，大德敦厚化育，这就是天地之所以为大的原因。\n\n唯天下至圣为能聪明睿知，足以有临也；宽裕温柔，足以有容也；发强刚毅，足以有执也；齐庄中正，足以有敬也；文理密察，足以有别也。溥博渊泉，而时出之。溥博如天，渊泉如渊。见而民莫不敬，言而民莫不信，行而民莫不说。是以声名洋溢乎中国，施及蛮貊。舟车所至，人力所通，天之所覆，地之所载，日月所照，霜露所队，凡有血气者，莫不尊亲，故曰配天。\n\n> 只有天下最高尚的圣人是聪明智慧的，能够居上位临下民，宽大为怀，温和柔顺，能够包容天下；奋发勇健，刚强坚毅，能够决断天下大事，威严庄重，忠诚正直，能够博得人们的尊敬，条理清晰，详细观察，能够分辨区别是非曲直。圣人的德行广博深厚，时时会表现出来。广博如天，深厚如渊，表现出来百姓没有不尊敬的，说出话来百姓没有不信服的，做起事来百姓没有不高兴的。这样，声誉在中国广泛传播，并延续到蛮貊这样的边远地区。船车所能达到的地方，人的力量所能通到的地方，天所覆盖的地方，地所负载的地方，日月所照耀的地方，霜露落下的地方，凡有血气生命的，没有不尊重亲近他们的，因此说能与天相配。\n\n唯天下至诚，为能经纶天下之大经，立天下之大本，知天地之化育。夫焉有所倚？肫肫其仁！渊渊其渊！浩浩其天！苟不固聪明圣知达天德者，其孰能知之？\n\n> 只有天下最高的真诚，才能成为治理国家的典范，树立天下的根本，认识到天地化育万物的道理。这需要什么依凭呢？仁爱之心那样诚挚，像潭水那样幽深，像天空那样广阔。如果不是真正聪明智慧、达到天德的人，还有谁能知道天下最高的真诚呢？\n\n《诗》曰：“衣锦尚絅”，恶其文之著也。故君子之道，闇然而日章；小人之道，的然而日亡。君子之道：淡而不厌，简而文，温而理，知远之近，知风之自，知微之显，可与入德矣。《诗》云：“潜虽伏矣，亦孔之昭！”故君子内省不疚，无恶于志。君子之所不可及者，其唯人之所不见乎！\n\n> 《诗经》上说：“内穿锦缎，外罩麻衣。”这是讨厌锦缎衣服的花纹太艳丽了。因此，君子的道，暗淡无光，但日见彰显，小人的道，鲜艳显著但日趋灭亡。君子的道，平淡但不令人厌恶，简约但文彩熠熠，温和但有条理。知道远是从近开始，知道教化是来自哪里，知道微弱的会变得显著，这样就可进入到圣人的德行行列中去了。《诗经》上说：“尽管潜藏隐匿在水下，仍然清晰可见。”因此，君子内心省察自己而不感到内疚，无愧于心。别人不及君子的原因，大概是君子在人看不到的地方也能严格要求自己。\n\n《诗》云：“相在尔室，尚不愧于屋漏。”故君子不动而敬，不言而信。《诗》曰：“奏假无言，时靡有争。”是故君子不赏而民劝，不怒而民威于鈇钺。《诗》曰：“不显惟德！百辟其刑之。”是故君子笃恭而天下平。《诗》云：“予怀明德，不大声以色。”子曰：“声色之于以化民。末也。”《诗》曰：“德輶如毛。”毛犹有伦，上天之载，无声无臭，至矣！ \n\n> 《诗经》上说：“看你独自一人在室，应当无愧于神灵。”所以，君子即使没有行动也能表现出他的恭敬态度，即使没有言谈也能表现出他的忠诚。《诗经》上说：“默默祈祷，不再有争执。”因此，君子不用赏赐，百姓就会受到勉励，不用发怒，百姓就会比看到铁钺还要畏惧。《诗经》上说：“让上天的德行大放光彩，凡诸侯都来实行。”因此，君子忠厚恭敬天下就会太平。《诗经》上说：“我怀念文王的美德，但不声张宣扬。”孔子说：“用声张宣扬来感化百姓，这是最不根本的啊！”《诗经》上说：“德行犹如羽毛。”但羽毛仍是可比的。“上天所承载的道，无声无味”，这才是最高的境界啊！\n\n## 参考资料\n\n1. [中庸 - 百度百科](https://baike.baidu.com/item/%E4%B8%AD%E5%BA%B8/5700593?fr=aladdin)"
    },

    {
        "id": "7ced8deb-cd74-4780-869d-a5f484ab790e",
        "title": "坐标下降法",
        "category": "机器学习",
        "date": { "year": 2022, "month": 1, "day": 29 },
        "peek": "坐标下降法, 英文是 coordinate descent, 仅仅从名字出发",
        "content": "> 2022 年 1 月 29 日\n\n## 什么是坐标下降法\n\n坐标下降法, 英文是 coordinate descent, 仅仅从名字出发, 似乎是和 [梯度下降法](https://darin1123.github.io/myblog/#/article/e540863b-cca8-4e70-8c6d-ba938e9745f5) 相似的东西, 而事实也是如此, 两者的目的是一致的: 求一个函数的局部最小值. 所以, 简单地说, **坐标下降法就是一个用于计算某个函数的局部最小值的算法**$^1$.\n\n## 如何运作$^{1}$\n\n与梯度下降法不同, **坐标下降法在每次迭代中只会沿着一个坐标的方向进行搜索求得一个局部最小值. 过程中循环使用不同的坐标方向**. \n\n## 数学原理$^3$\n\n假设函数 $f(\\bold{x})$ 有 $p$ 个参数, 即 $\\bold{x} = (x_1, x_2, \\dots, x_p)^T$.\n\n从 $\\bold{x}^{(0)}$ 开始\n\n重复\n$$\n\\bold{x}_j^{(k+1)} = \\mathop{\\arg\\min}\\limits_{x} \\,\\,\\,f(x_1^{(k+1)},\\dots, x_{j-1}^{(k+1)}, x,x_{j+1}^{(k)}, \\dots,x_{p}^{(k)})\n$$\n直到 $\\bold{x}^{(k)}\\approx \\bold{x}^{(k+1)}$.\n\n> 可以观察到, $f(\\bold{x}^{(0)}) \\geq f(\\bold{x}^{(1)})\\geq f(\\bold{x}^{(2)})\\geq \\cdots$\n\n## 为什么要用坐标下降法$^{2, 3}$\n\n1. 如果使用梯度下降法, 有时候函数的梯度无法被计算.\n2. 当变量的数量很大时, 计算梯度的开销可能会很大, 使用坐标下降法可以有更好的性能.\n\n## 一点图形\n\n以定义域为二维的函数为例, 求得局部最小值的路径大概是这样的:\n\n![Coordinate_descent](img/articles/coordinate_descent.svg)\n\n\n\n## 参考资料\n\n1. [维基百科 - 坐标下降法](https://zh.wikipedia.org/wiki/%E5%9D%90%E6%A0%87%E4%B8%8B%E9%99%8D%E6%B3%95)\n1. [CoordinateDescent](https://www.youtube.com/watch?v=lsR647LNmpQ&ab_channel=CynthiaRudin)\n1. [Coordinate vs. gradient descent](https://stats.stackexchange.com/questions/146317/coordinate-vs-gradient-descent)"
    },

    {
        "id": "97881abf-7f86-4f81-8d4c-427b02d71468",
        "title": "掌握一个知识点",
        "category": null,
        "date": { "year": 2022, "month": 1, "day": 29 },
        "peek": "不管是什么领域, 什么学科, 想要学得好, 学得精, 那么不可避免地需要攻克一个个的知识点",
        "content": "\n> 2022 年 1 月 29 日\n\n不管是什么领域, 什么学科, 想要学得好, 学得精, 那么不可避免地需要攻克一个个的知识点. 面对全新的知识, 立刻开始埋头苦学是不可取的. 有句话说得好, 努力在方向面前一文不值. 因此, 在学习新知识的时候, 也需要先树立目标, 然后再付诸努力. 那么, 学习一个知识点的目标是什么呢?\n\n在最近的学习和思考中, 对于上面的问题我似乎有了一个简单的答案. 对于任何一个知识点, 若是能回答以下问题, 那么就应该掌握的比较完全了. 用 \"脊回归\" 为例:\n\n1. 脊回归是什么?\n2. 为什么需要脊回归?\n3. 脊回归如何运作?\n4. 为什么脊回归有效果?\n\n简单地说, 就是一个 What, 一个 How, 以及两个 Why. 其中 What 是最简单的问题, How 是相对最繁琐的. 对于两个 Why 来说, 其中的一个问的是脊回归存在的意义, 另一个问的是脊回归的原理. \n\n以上就是我对掌握一个知识点的理解."
    },

    {
        "id": "e540863b-cca8-4e70-8c6d-ba938e9745f5",
        "title": "梯度下降法",
        "category": "机器学习",
        "date": { "year": 2022, "month": 1, "day": 27 },
        "peek": "梯度下降法的目的在于找到一个函数的局部最小值",
        "content": "\n> 2022 年 1 月 27 日\n>\n> 更新于 2022 年 1 月 29 日\n\n梯度下降法的目的在于**找到一个函数的局部最小值**$^1$. 因此, 在机器学习模型训练的过程中, 需要**计算模型的参数**时, 梯度下降法是非常有效的方法之一$^2$. \n\n## 原理$^1$\n\n假设 $F(x)$ 为我们的目标函数, 而且 $F(x)$ 在点 $a$ 处可以微分且有定义, 那么函数 $F(x)$ 在点 $a$ 沿着梯度相反的方向 $-\\nabla F(a)$ 下降最多. \n\n然后, 使 $b = a - \\gamma \\nabla F(a)$,  (其中 $\\gamma > 0$ 为一个够小数值使其成立,) 我们有 $F(a) \\geq F(b)$.\n\n## 运作方式$^1$\n\n给定函数 $F(x)$ 和一个在局部最小值的初始估计 $x_0$.\n\n重复:\n\n- 计算 $x_{n+1} = x_n - \\gamma_n \\nabla F(x_n)$\n- 当 $F(x_n) - F(x_{n+1})$ 小于某个阈值 $\\text{tol}$ 时, 停止重复\n\n> 其中 $\\gamma$ 的值是动态调整的.\n\n## 一点图形$^1$\n\n如下图所示, 此处 $F$ 的定义域为一个二维平面. 该函数的形状像是一个碗形. 蓝色曲线描述的是函数值的等高线, 红色箭头指向改点梯度的反方向. 沿着梯度下降的方向, 最终达到碗底, 即函数的局部最小值.\n\n![梯度下降](img/articles/gradient_descent.png)\n\n## 具体例子\n\n**问题**\n\n假设目标函数为 $f(a, b) = 5a^2 - 6ab+ 5b^2$. 从 $x_0 = (3, 6)$ 开始, 寻找 $f$ 的局部最小值.\n\n**初始设置**\n\n学习率 $\\gamma = 0.05$, $\\text{tol} = 0.0000001$.\n\n**开始计算**\n\n函数在 $x_0$ 时的值为 $f(3, 6) = 117$.\n\n*计算梯度*\n\n对于 $a$ : $\\dfrac{\\partial f}{\\partial a} = 10a - 6b$\n\n对于 $b$ :  $\\dfrac{\\partial f}{\\partial b} = -6 a + 10b$\n\n于是, $\\gamma\\nabla F(x_n) = 0.05\\cdot\\begin{bmatrix}10a_n - 6b_n\\\\-6a_n + 10b_n\\end{bmatrix}$\n\n*计算 $x_1$*\n\n$x_1 = x_0 - \\gamma\\nabla F(x_0) = \\begin{bmatrix}3\\\\6\\end{bmatrix} - 0.05\\cdot\\begin{bmatrix}10\\times 3 - 6 \\times6\\\\-6\\times 3 + 10\\times6\\end{bmatrix} = \\begin{bmatrix}3.3\\\\3.9\\end{bmatrix}$\n\n检查是否达到要求:\n\n$f(x_0) - f(x_1) = 117 - 53.3 > \\text{tol}$\n\n很显然, 没有达到要求, 所以继续计算 $x_2$.\n\n$x_2 = x_1 - \\gamma\\nabla F(x_1) = \\begin{bmatrix}2.82\\\\2.94\\end{bmatrix}$\n\n检查是否达到要求:\n\n$f(x_1) - f(x_2) = 53.3 - 33.2 > \\text{tol}$\n\n很显然, 没有达到要求, 所以继续计算 $x_3$.\n\n$\\cdots$\n\n直到最后我们在 $x_{45} = \\begin{bmatrix}1.96\\times 10^{-4}\\\\1.96\\times 10 ^{-4}\\end{bmatrix}$ 时, 满足了有关 $\\text{tol}$ 的要求. 其中 $f(x_{45}) = 1.54 \\times 10^{-7}$.\n\n上述过程的 Python 代码\n\n~~~python\nfrom math import log10, floor\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef round_to_3(x):\n    '''\n    Round float to keep 3 most dignificant digits\n    '''\n    return round(x, -int(floor(log10(x))) + (3 - 1))\n\n\nF = lambda x, y: 5 * x ** 2 - 6 * x * y + 5 * y ** 2\ndFdx = lambda x, y: 10 * x - 6 * y\ndFdy = lambda x, y: -6 * x + 10 * y\n\n\nLEARNING_RATE = 0.05\nTOLERANCE = 0.0000001\n\nnumberOfIterations = 0\n\nx = 3\ny = 6\nv = F(x, y)\n\nprint('x_0: {}, y_0: {}, f(x_0): {}'.format(x, y, v))\n\n# trace for ploting\ntraceX = [x]\ntraceY = [y]\ntraceV = [v]\nwhile True:\n    numberOfIterations += 1\n    newX = x - LEARNING_RATE * dFdx(x, y)\n    newY = y - LEARNING_RATE * dFdy(x, y)\n    newV = F(newX, newY)\n    traceX.append(newX)\n    traceY.append(newY)\n    traceV.append(newV)\n    print('iteration: {}, x: {}, y: {}, v: {}'.format(numberOfIterations, round_to_3(newX), round_to_3(newY), round_to_3(newV)))\n\n    if v - newV < TOLERANCE:\n        print('\\nGradient descent done')\n        print('x: {}, y: {}, v: {}'.format(round_to_3(newX), round_to_3(newY), round_to_3(newV)))\n        break\n    else:\n        x = newX\n        y = newY\n        v = newV\n\n\n# plot the trace\ndelta = 0.01\nxs = np.arange(-5, 5, delta)\nys = np.arange(-5, 5, delta)\nX, Y = np.meshgrid(xs, ys)\nZ = F(X, Y)\n\nlevels = [int(item) for item in traceV if item > 1 and item < 100]\nlevels.sort()\n\nfig, ax = plt.subplots(1, 1)\ncp = ax.contour(X, Y, Z, levels, colors='k')\nax.clabel(cp, fontsize=6, inline=True)\nplt.plot(traceX, traceY, color='red')\nplt.xlabel('X')\nplt.ylabel('Y')\nplt.show()\n~~~\n\n程序输出\n\n~~~text\nx_0: 3, y_0: 6, f(x_0): 117\niteration: 1, x: 3.3, y: 3.9, v: 53.3\niteration: 2, x: 2.82, y: 2.94, v: 33.2\niteration: 3, x: 2.29, y: 2.32, v: 21.2\niteration: 4, x: 1.84, y: 1.85, v: 13.6\niteration: 5, x: 1.47, y: 1.48, v: 8.7\n...\niteration: 41, x: 0.000479, y: 0.000479, v: 9.16e-07\niteration: 42, x: 0.000383, y: 0.000383, v: 5.86e-07\niteration: 43, x: 0.000306, y: 0.000306, v: 3.75e-07\niteration: 44, x: 0.000245, y: 0.000245, v: 2.4e-07\niteration: 45, x: 0.000196, y: 0.000196, v: 1.54e-07\n\nGradient descent done\nx: 0.000196, y: 0.000196, v: 1.54e-07\n~~~\n\n路径图形\n\n![trace](img/articles/trace.png)\n\n## 参考资料\n\n1. [维基百科 - 梯度下降法](https://zh.wikipedia.org/wiki/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95)\n\n2. [百度百科 - 梯度下降法](https://baike.baidu.com/item/%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D/4864937?fr=aladdin)"
    },

    {
        "id": "0ed262cd-723c-4edf-892a-65120605a76c",
        "title": "Lasso Regression",
        "category": "机器学习",
        "date": { "year": 2022, "month": 1, "day": 24 },
        "peek": "Lasso 回归和脊回归十分相近",
        "content": "> 2022 年 1 月23 日\n>\n> 更新于 2022 年 1 月 24 日\n\nLasso 回归和脊回归十分相近. 两者都是收缩法, 都是正则化的实例. \n\n**Lasso 回归**\n$$\n\\min\\limits_{\\beta}\\,\\, \\text{RSS} + \\lambda\\Vert\\beta\\Vert_1\n$$\n\n## Lasso 回归和脊回归的不同之处\n\n**两者之间最大的区别在于, Lasso 可以完全将斜率缩小至 0, 而脊回归只能使斜率无限接近 0.$^{[1]}$** 也因为如此, Lasso 可以做特征选择. \n\n在数学的角度上的不同之处在于: 脊回归使用的是 $L_2$ 正则, 而 Lasso 使用的是 $L_1$ 正则.\n\n具体的, 脊回归:\n$$\n\\min\\limits_{\\beta}\\,\\, \\text{RSS} + \\lambda\\,\\Vert\\beta\\Vert_2^2\n$$\n\n## 两者适用的情景$^{[1]}$\n\n根据如上所述, 可以得到两者的适用场景: Lasso 适用于存在很多不相关变量的数据集; 脊回归适用于所有变量都相关的场景.\n\n## 相关文章\n\n[脊回归 Ridge Regression](https://darin1123.github.io/myblog/#/article/4c907503-f821-4dba-bd3a-e95d41f3f088)\n\n## 参考资料\n\n1. [Regularization Part 2: Lasso (L1) Regression](https://youtu.be/NGf0voTMlcs)\n\n"
    },

    {
        "id": "ea66a6e6-a665-47df-a713-9048bdd64468",
        "title": "LaTeX 正下方文字",
        "category": "LaTeX",
        "date": { "year": 2022, "month": 1, "day": 23 },
        "peek": "在写数学公式的时候, 遇到如最大化, 最小化时, 需要在正下方添加参数符号",
        "content": "> 2022 年 1 月 23 日\n>\n> 更新于 2022 年 1 月 29 日\n\n在写数学公式的时候, 遇到如最大化, 最小化时, 需要在正下方添加参数符号, 我们可以使用 `\\limits`.\n\n写法如下:\n\n~~~latex\n\\limits_{content}\n~~~\n\n## 实例\n\n- $\\min\\limits_{\\beta}$ 的代码为 `\\min\\limits_{\\beta}`.\n\n- $\\lim\\limits_{x \\rightarrow\\infty}$ 的代码为 `\\lim\\limits_{x \\rightarrow\\infty}`.\n\n**特殊情况**\n\n当 `\\limit` 前面有不止一个数学函数时, 需要用 `\\mathop` 将他们整合为一个数学函数, 然后使用 `\\limit`. \n\n如: $\\mathop{\\arg \\min}\\limits_{\\beta}$ 的代码为 `\\mathop{\\arg \\min}\\limits_{\\beta}`.\n\n## 参考资料\n\n1. [Writing a limit so that the subscript goes directly underneath](https://tex.stackexchange.com/questions/39390/writing-a-limit-so-that-the-subscript-goes-directly-underneath)\n2. [LaTeX argmin argmax 下标使用方法](https://blog.csdn.net/YhL_Leo/article/details/50036001)\n"
    },

    {
        "id": "4c907503-f821-4dba-bd3a-e95d41f3f088",
        "title": "脊回归 Ridge Regression",
        "category": "机器学习",
        "date": { "year": 2022, "month": 1, "day": 23 },
        "peek": "脊回归是为模型添加正则项的一种方式.",
        "content": "> 2022 年 1 月 23 日\n>\n> 更新于 2022 年 1 月 24 日\n\n脊回归是为模型添加正则项的一种方式. 脊回归适用于**变量之间存在高共线性**的多元回归情景$^{[1]}$.\n\n## 脊回归如何运作? $^{[2]}$\n\n以线性回归为例, 脊回归在线性回归的基础上做一点变动.\n\n原来的线性回归的目标函数在于最小化残差平方和:\n$$\n\\text{RSS} = \\sum_i \\epsilon_i^2\n$$\n其中, $\\hat{\\epsilon} = y_i - \\hat{y}_i$, $\\hat{y}_i = \\alpha + \\beta_ix_i $.\n\n而脊回归在此基础上, 最小化了 $($残差平方和 $+ \\lambda\\times$斜率$^2)$.\n$$\n\\text{RSS} + \\lambda\\Vert\\beta\\Vert^2_2\n$$\n**关于 $\\lambda$**\n\n$\\lambda$ 的取值范围是 0 到 $\\infty$. \n\n当 $\\lambda = 0$ 时, 正则项没有任何作用; 当 $\\lambda$ 增大时, 正则项的作用也相应变大, 模型本身的作用相对变小. 可以使用 cross validation 来选出最优的 $\\lambda$ 值.\n\n## 一些图形\n\n以二维数据为例, 图像如下: 横坐标为 $\\beta_0$, 纵坐标为 $\\beta_1$. 若为三维图像的话, 则类似于一个山谷. 绿色为原目标函数, 蓝色为添加正则项后. \n\n可以观察到, 原来的\"山谷\"细又长, 在数据上反应为 $y$ 值对 $\\beta_0$ 的变动十分敏感. 而脊回归后则消除了这种敏感性.\n\n![Ridge](img/articles/ridge.png)\n\n## 参考资料\n\n1. [维基百科 - 脊回归](https://en.wikipedia.org/wiki/Ridge_regression)\n2. [YouTube - Regularization Part 1: Ridge (L2) Regression](https://youtu.be/Q81RR3yKn30)\n\n"
    },

    {
        "id": "cd1cd14a-61f4-4df3-8c18-ef042abd3d8f",
        "title": "偏量和方差 Bias and Variance",
        "category": "机器学习",
        "date": { "year": 2022, "month": 1, "day": 22 },
        "peek": "本文介绍了机器学习中的bias和variance",
        "content": "> 2022 年 1 月 22 日\n\n## 偏量 Bias\n\n\"The inability for a machine learning method to capture the true relationship is called bias.\"$^{[1]}$\n\n当一个机器学习模型无法完整地涵盖数据的模式即是偏量. 我的理解: 因为这个机器学习模型有自己的\"想法\", 没有完全\"屈服\"数据表现出来的模式, 所以这个模型对于数据有自己的想法, 也就是有了自己的偏见(bias). 这样的偏见越大, 数据的影响就越小; 偏见越小, 数据的影响就越大. \n\n当数据展现的模式的影响达到一定的程度时, 这个模型就会出现过度贴合数据的情况, 于是就出现了过拟合现象.\n\n## 方差 Variance\n\n\"The difference in fits between data sets is called variance.\"$^{[1]}$\n\n模型在不同的数据集中的偏差量叫做方差. 我觉得这里的 variance 不应该翻译为方差, 而应该是变数. 统计中方差描述的是随机变量或一组数据离散程度的度量$^{[2]}$, 在这个情境下显然不是太合适. 如果作为变数理解, 那就说得通一些了. 如果变数小, 那么模型对的不同的未知数据的预测性能就越稳定; 如果变数大, 那么模型的预测行为就变得不可靠了. 所以说, 极低偏差的模型反而会有更糟糕的性能, 因为他在极力贴合数据的同时, 可能使得自己对于未来预测的变数变得极大.\n\n## 其他\n\n在理想情况下, 我们希望在降低偏量的同时, 也能有很小的变数. 想要达到这个效果, 就要小心平衡模型的复杂度. (简单模型通常有较高的偏量, 复杂的模型通常会过拟合而导致大变数.)\n\n常见的寻找合适模型的方法$^{[1]}$:\n\n1. regularization\n2. boosting\n3. bagging\n\n## 参考资料\n\n1. [YouTube - Machine Learning Fundamentals: Bias and Variance](https://www.youtube.com/watch?v=EuBBz3bI-aA&t=113s&ab_channel=StatQuestwithJoshStarmer)\n2. [方差 - 百度百科](http://www.baidu.com/link?url=b1n9PEDaaUlBxdlPYIphuYtkaSahFch6G-TqTOOx2n9AicM_soNWXAPoAMncqYnu4rmK0a9bKJW7j5PSOik1Kx5PeICJTZbFRpxWDC50B4i&wd=&eqid=ea1b36a90006614e0000000661ec0410)"
    },

    {
        "id": "f2ab1603-46e1-4a46-b99a-30f945fca0f7",
        "title": "重采样 Resampling Method",
        "category": "统计",
        "date": { "year": 2022, "month": 1, "day": 22 },
        "peek": "重采样顾名思义就是在已有的数据中重新采集样本. 是一种度量统计精度的方法",
        "content": "> 2022 年 1 月 20 日\n>\n> 更新于 2022 年 1 月 22 日\n\n重采样顾名思义就是在已有的数据中重新采集样本. 是一种度量统计精度的方法. 重采样方法为以下任意一种方法或者是其变形.\n\n1. Bootstrap\n2. 交叉验证 Cross validation\n\n## Cross Validation\n\n**什么是 cross validation ?**\n\nK-fold CV 是用于**估测 test error** 的常用方法. 可以用于选出最优模型; 对于最终选择的模型给出一个 test error 的报告.\n\n**K-fold CV 如何运作?**\n\n1. 随机地将数据集分为 $K$ 个等份\n2. 取出其中一份作为测试集, 剩余的 $K- 1$ 份为训练集\n3. 用训练集训练模型并用测试集进行测试\n4. 对于每个等份, 重复上述动作. (一共执行 $K$ 次.)\n5. 整合所有结果.\n\n**Leave-One Out Cross Validation LOOCV**\n\n与 K-fold 不同的是, 每次只用一个数据实例作为测试集. 也就是做一个$k = n$ 的 K-fold CV.\n\n**CV 的劣势**\n\n- Prediction error 会受到 bias 的影响. \n- 当 $k = n$ 时, bias会被最小化, 但是预测结果会有较高的方差.\n\n> 由此可见, 需要在 bias 和 variance 之间做取舍. \n>\n> 当 $k = 5$ 或 $k = 10$ 时, 通常可以达到两者之间的平衡.\n\n**习题**\n\n思考如下情景. 用一个简单的分类器来分类一个二类数据.\n\n1. 开始有50个数据实例, 且有 500 个特征. 但是发现只有其中的 100 个特征和标签有关联.\n2. 于是只使用那 100 个特征来构建模型.\n\n*问题* : 我们应该如何估算 test error? 我们是否可以 *仅仅* 对第二步中的模型进行交叉验证?\n\n> 答:\n>\n> 不可以仅仅对第二步中的模型进行交叉验证. 第一步中已经对标签进行了使用, 因此第一步也是训练模型的一部分. 所以第一步和第二步都应该包含在交叉验证的过程中.\n\n***Cross validation 的相关文章***\n\n*[使用 Python 进行 Cross Validation](https://darin1123.github.io/myblog/#/article/a0e6f23f-96ea-456e-bbce-4510d82646d6)*\n\n## Bootstrap\n\nBootstrap 是度量一个 *模型的不确定性* 的有效方法$^{[3]}$. 也称作拔靴法, 自助抽样法$^{[2]}$. \n\n该方法不是用来估计参数的, 而是用来判断原有的估计多大程度上是有效的$^{[4]}$. 因此, bootstrap 针对的是模型给出的估计结果而不是模型本身. \n\n**如何运作**$^{[5]}$\n\n*第一步, 从原数据集生成 Bootstrap 数据集*. 这里, 随机从原数据集中取出 $n$ 个样本, $n$ 为原数据集的数据量. 随机取出的样本可能会有重复, 这样就能生成和原数据集有差异的数据集.\n\n*第二步, 进行某个指标的计算.* 如平均值, 方差等等.\n\n*第三步, 记录这个计算结果.*\n\n*第四步, 重复第一步到第三步多次.*\n\n从最终的结果中, 可以对这个指标有一定的分析.\n\n## 参考资料\n\n1. [维基百科 - 重抽样](https://zh.wikipedia.org/wiki/%E9%87%8D%E6%8A%BD%E6%A0%B7)\n2. [维基百科 - 自助法](https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A9%E6%B3%95)\n3. SDSC 6001 课件\n4. [知乎 - 统计学里面的自助法（Bootstrap Method）为什么效果好？](https://www.zhihu.com/question/38429969)\n\n5. [YouTube - Bootstrapping Main Ideas!!!](https://www.youtube.com/watch?v=Xz0x-8-cgaQ&ab_channel=StatQuestwithJoshStarmer)\n\n"
    },

    {
        "id": "f2c1d389-c855-43a9-8bc8-ea625fed2d85",
        "title": "R - 数据类型",
        "category": "R",
        "date": { "year": 2022, "month": 1, "day": 21 },
        "peek": null,
        "content": "> 2022 年 1 月 21 日\n\n**布尔值** \n\n`TRUE`, `FALSE`. (注意都是大写的.)\n\n**字符串** \n用双引号包住, 也可以用单引号包住.\n\n**向量**\n\n~~~r\n# 定义两个向量\na = c(3, 4)\nb = c(5, 0)\n\n# 向量运算\na + b  # 8 4\n\n# 取单个数值\na[1]  # 3; 下标从 1 开始\n\n# 切片\nv = c(1, 2, 3, 4, 5, 6, 7, 8, 9)\n# 取出第一个到第四个, 包含第一个和第四个\nv[1:4]  # 1 2 3 4\n# 取出第 1, 3, 5 项\nv[c(1, 3, 5)]  # 1 3 5\n# 去掉第 1 和第 5 项\nv[c(-1, -5)]  # 2 3 4 6 7 8 9\n~~~\n\n**矩阵**\n\n~~~r\ndata = c(1,2,3,4,5,6)\nm = matrix(data, 2, 3)\n#      [,1] [,2] [,3]\n# [1,]    1    3    5\n# [2,]    2    4    6\n\nm = matrix(data, 2, 3, byrow=TRUE)\n#      [,1] [,2] [,3]\n# [1,]    1    2    3\n# [2,]    4    5    6\n\n# 设置列名和行名\ncolnames(m) = c(\"x\", \"y\", \"z\")  # 设置列名称\nrownames(m) = c(\"a\", \"b\")  # 设置行名称\n~~~\n\n## 参考资料\n\n1. [R 数据类型 | 菜鸟教程](https://www.runoob.com/r/r-data-types.html)\n\n"
    },

    {
        "id": "517eb6bd-6bc6-4e9d-a165-cacd170c3c4b",
        "title": "R - 函数",
        "category": "R",
        "date": { "year": 2022, "month": 1, "day": 21 },
        "peek": "构建自己的函数.",
        "content": "> 2022 年 1 月 21 日\n\n构建自己的函数.\n\n**定义函数**\n\n可以观察到, 像 Python 一样, 没有指明参数列表类型以及返回类型.\n\n~~~r\nfunction_name <- function(arg_1, arg_2, ...) {\n  # 函数体\n}\n~~~\n\n*例*\n\n~~~r\nadd <- function(a, b) {\n  return (a + b)\n}\n\nadd(2, 3)  # 5\n~~~\n\n*设置默认值*\n\n例\n\n~~~r\nadd <- function(a = 3, b = 6) {\n   return (a + b)\n}\n\nadd()  # 9\n~~~\n\n**惰性加载**\n\n懒惰计算将推迟计算工作直到系统需要这些计算的结果。如果不需要结果，将不用进行计算。\n\n## 参考资料\n\n1. [R 函数 | 菜鸟教程](https://www.runoob.com/r/r-functions.html)\n\n"
    },

    {
        "id": "93e325e3-124c-401e-a8ec-e17ea9c7b4ec",
        "title": "R - 循环",
        "category": "R",
        "date": { "year": 2022, "month": 1, "day": 21 },
        "peek": "如题所示",
        "content": "> 2022 年 1 月 21 日\n\n有三种循环: `repeat`, `while`, 和 `for`.\n\n*repeat*\n\n无限循环, 直到被 `break`.\n\n~~~r\nrepeat {\n  # do something here\n  if (condition) {\n    break\n  }\n}\n~~~\n\n*while*\n\n与 Java 中相同\n\n*for*\n\n仅有 for each 的写法\n\n~~~r\nfor (value in vector) {\n\t# do something\n}\n~~~\n\n*循环控制*\n\n有 `break` 和  `next` 这两个关键字. 其中 `next` 用于跳过当前循环, 类似于其他语言中的 `continue`.\n\n## 参考资料\n\n1. [R | 菜鸟教程](https://www.runoob.com/r/r-tutorial.html)"
    },

    {
        "id": "16a535a0-610b-449b-8a76-8fa05f82235f",
        "title": "R - 安装, 基础语法",
        "category": 'R',
        "date": { "year": 2022, "month": 1, "day": 21 },
        "peek": "首先看看如何安装 R 以及基本的语法",
        "content": "> 2022 年 1 月 21 日\n\n因为课程内容需要, 所以来快速学习一下 R 语言. 首先看看如何安装 R 以及基本的语法.\n\n*\"R 语言是为数学研究工作者设计的一种数学编程语言，主要用于统计分析、绘图、数据挖掘。\"*\n\n## 安装\n\n本人使用 Mac 系统, 在这里只记录了 Mac 的安装方法. 需要安装的内容由两部分: 语言环境以及开发工具.\n\n**语言环境**\n\n网上教程很多都是在 [官网](https://cran.r-project.org/mirrors.html) 安装. 但是我习惯使用 Homebrew 在电脑上直接安装软件, 所以就去找了 Homebrew 的安装方法:\n\n~~~bash\nbrew install r\n~~~\n\n**开发工具**\n\n下载安装 Mac 版本的 [RStudio](https://www.rstudio.com/products/rstudio/download/).\n\n> RStudio 清除 Console 的快捷命令: `CTRL + L`\n\n## 基础语法\n\n**变量命名**\n\nR 语言允许变量名称包含 `.` . (好奇怪!) \n\n因此, `.var`, `var.name`, `var.` 都是合法的变量名. \n\n**变量赋值**\n\n可以使用 `=`, `->`, 和 `<-` 进行赋值\n\n~~~r\nstr = \"String\"\n\"String\" -> str\nstr <- \"String\"\n~~~\n\n**注释**\n\n*单行注释*\n\n~~~r\n# 单行注释\n~~~\n\n*多行注释*\n\n没有多行注释, 但是可以用IDE中的快捷键来\"多行注释\".\n\n**基本运算**\n\n与 Java 完全一致: `|`, `&`, `!`, `||`, `&&`.\n\n**if 语句**\n\n`if` 语句\n\n~~~r\nif (boolean_expression) {\n  # 布尔表达式为真将执行的语句\n}\n~~~\n\n`if ... else ...`\n\n~~~r\nif (boolean_expression) {\n\t# 如果布尔表达式为真将执行的语句\n} else {\n\t# 如果布尔表达式为假将执行的语句\n}\n~~~\n\n`if ... else if ... else`\n\n~~~r\nif(boolean_expression 1) {\n\t# 如果布尔表达式 boolean_expression 1 为真将执行的语句\n} else if( boolean_expression 2) {\n\t# 如果布尔表达式 boolean_expression 2 为真将执行的语句\n} else if( boolean_expression 3) {\n\t# 如果布尔表达式 boolean_expression 3 为真将执行的语句\n} else {\n\t# 以上所有的布尔表达式都为 false 时执行\n}\n~~~\n\n**`switch` 语句**\n\n当 expression 为整数时\n\n~~~r\nx <- switch(\n   3,\n   \"google\",\n   \"amazon\",\n   \"alibaba\",\n   \"tencent\"\n)\nprint(x)  # 输出 alibaba\n~~~\n\n当 expression 为字符串时\n\n~~~r\nday <- \"monday\"\nswitch(day, monday=2, tuesday=3, wednesday=4, thursday=5, friday=6, saturday=7, sunday=1)\n\n# 输出 2\n~~~\n\n## 参考资料\n\n1. [R | 菜鸟教程](https://www.runoob.com/r/r-tutorial.html)"
    },

    {
        "id": "359c2902-bb10-4eb5-95b2-195130cb75f3",
        "title": "二项分布 Binomial Distribution",
        "category": "统计",
        "date": { "year": 2022, "month": 1, "day": 21 },
        "peek": "是 n 个独立的是/非实验中成功次数的离散分布, 每次试验成功概率为 p. ",
        "content": "> 2022 年 1 月 21 日\n\n是 $n$ 个独立的是/非实验中成功次数的离散分布, 每次试验成功概率为 $p$. \n\n这样的一次是/非试验即是一次伯努利试验. 因此二项分布就是伯努利分布.\n\n**PMF**\n$$\nF(k, n, p)= Pr(X = k) = \n\\left(\n\\begin{aligned}\nn\\\\k\n\\end{aligned}\n\\right)\\,p^k (1 - p)^{n - k}\n$$\n\n> **参数列表**\n>\n> $k$ : 成功次数;  $n$ : 总试验次数;  $p$ : 试验成功的概率 \n>\n> 其中, $\\left(\\begin{aligned}n\\\\k\\end{aligned}\\right)= \\dfrac{n!}{k!(n-k)!}$\n\n**期望值和方差**\n\n$E[X] = np$\n\n$Var[X] = np(1 - p)$\n\n## 参考资料\n\n1. [维基百科 - 二项分布](https://zh.wikipedia.org/wiki/%E4%BA%8C%E9%A0%85%E5%BC%8F%E5%88%86%E5%B8%83)\n\n2. SDSC 8013 课件"
    },

    {
        "id": "af8c71a0-3032-4538-8815-95998b89d9f8",
        "title": "Hypothesis Test 假设验证 ",
        "category": "统计",
        "date": { "year": 2022, "month": 1, "day": 19 },
        "peek": "本文介绍了 Hypothesis Test",
        "content": "> 2022 年 1 月 19 日\n>\n> [YouTube - Intro to Hypothesis Testing in Statistics](https://www.youtube.com/watch?v=VK-rnA3-41c&t=447s&ab_channel=MathandScience)\n\n## 有关 Hypothesis\n\n**Hypothesis**\n\nHypothesis, 是我们想要进行验证的假设.\n\n**Null Hypothesis**\n\n用 $H_0$ 表示. 是当前已经接受的事实.\n\n**Alternative Hypothesis**\n\n用 $H_a$ 表示. 也被称为 Research hypothesis, 因此, 是我们需要进行研究的一个假设.\n\n### 糖果机器的例子\n\n有一个生产糖果的机器, 生产出来的糖果的重量的平均值是 5 克. 但是一个工人说: \"这个机器没法保证生产 5 克的糖了\". 请问 $H_0$ 和 $H_a$ 分别是什么?\n\n> $H_0 : \\mu = 5$\n>\n> 根据 Null Hypothesis 的定义描述, \"是当前已经接受的事实\", 那么很显然**当前已经接受的事实**就是这个机器生产出来的糖果的平均质量为 5 克.\n>\n> $H_a : \\mu \\neq 5$\n>\n> 根据 Alternative Hypothesis 的定义, \"是我们需要进行研究的一个假设\", 这个工人说的话我们不知道是不是真的, 因此需要进行**研究**.\n\n## 有关 Test\n\n**可能的测试结果**\n\n1. Reject $H_0$. 因为否定了曾经接受的事实, 因此我们更加愿意接受 $H_a$ 所描述的.\n2. Fail to reject $H_0$. 因为无法否定曾经接受的事实, 因此我们任然接受 $H_0$ 所描述的.\n\n**如何进行测试**\n\nTest statistics. 使用样本数据进行相关计算并作出决定. \n\n> 在糖果机的例子中, 样本可以是所生产出的众多糖果中随机挑选的 50 个.\n\n**Statistically significant**\n\n我们需要决定一个临界点, 或者说阈值, 来作出决定. \n\n> 在糖果机的例子中, 我们可以说, 如果样本的平均值减去 5 大于某个数值, 那么我们就作出 reject $H_0$ 的决定.\n\n**相关计算**\n\n*Level of Confidence*. 如 $c-95\\%$.\n\n*Level of Significance*. 即 $1 - c$."
    },

    {
        "id": "5f56f9d9-7218-4669-ba38-52d0d583f20d",
        "title": "React 点击空白处自动关闭组件",
        "category": "React",
        "date": { "year": 2022, "month": 1, "day": 16 },
        "peek": "打开某个组件后, 如何通过点击其他区域使得这个组件自动关闭呢?",
        "content": "> 2022 年 1 月 16 日\n\n## 问题?\n\n打开某个组件后, 如何通过点击其他区域使得这个组件自动关闭呢?\n\n## 解决方法\n\n### `class` 写法\n\n```javascript\nimport React, { Component } from 'react';\nimport PropTypes from 'prop-types';\n\n/**\n * Component that alerts if you click outside of it\n */\nexport default class OutsideAlerter extends Component {\n    constructor(props) {\n        super(props);\n\n        this.wrapperRef = React.createRef();\n        this.setWrapperRef = this.setWrapperRef.bind(this);\n        this.handleClickOutside = this.handleClickOutside.bind(this);\n    }\n\n    componentDidMount() {\n        document.addEventListener('mousedown', this.handleClickOutside);\n    }\n\n    componentWillUnmount() {\n        document.removeEventListener('mousedown', this.handleClickOutside);\n    }\n\n    /**\n     * Alert if clicked on outside of element\n     */\n    handleClickOutside(event) {\n        if (this.wrapperRef && !this.wrapperRef.current.contains(event.target)) {\n            alert('You clicked outside of me!');\n        }\n    }\n\n    render() {\n        return <div ref={this.wrapperRef}>{this.props.children}</div>;\n    }\n}\n\nOutsideAlerter.propTypes = {\n    children: PropTypes.element.isRequired,\n};\n```\n\n### `hook` 写法\n\n```javascript\nimport React, { useRef, useEffect } from \"react\";\n\n/**\n * Hook that alerts clicks outside of the passed ref\n */\nfunction useOutsideAlerter(ref) {\n    useEffect(() => {\n        /**\n         * Alert if clicked on outside of element\n         */\n        function handleClickOutside(event) {\n            if (ref.current && !ref.current.contains(event.target)) {\n                alert(\"You clicked outside of me!\");\n            }\n        }\n\n        // Bind the event listener\n        document.addEventListener(\"mousedown\", handleClickOutside);\n        return () => {\n            // Unbind the event listener on clean up\n            document.removeEventListener(\"mousedown\", handleClickOutside);\n        };\n    }, [ref]);\n}\n\n/**\n * Component that alerts if you click outside of it\n */\nexport default function OutsideAlerter(props) {\n    const wrapperRef = useRef(null);\n    useOutsideAlerter(wrapperRef);\n\n    return <div ref={wrapperRef}>{props.children}</div>;\n}\n```\n\n## 参考资料\n\n[Detect click outside React component](https://stackoverflow.com/questions/32553158/detect-click-outside-react-component)"
    },

    {
        "id": "6c4e15d7-669b-4de0-bbf6-896c966d8d96",
        "title": "ROC 曲线",
        "category": "机器学习",
        "date": { "year": 2022, "month": 1, "day": 12 },
        "peek": "ROC 曲线的全称为受试者工作特征曲线, 英文为Receiver Operating Characteristic Curve",
        "content": "> 2022 年 1 月 12 日\n>\n> 🔗 链接\n>\n> - [维基百科](https://zh.wikipedia.org/wiki/ROC%E6%9B%B2%E7%BA%BF)\n>\n> - [知乎-ROC曲线简介](https://zhuanlan.zhihu.com/p/26293316)\n\n\n\n## 1. ROC 曲线是什么?\n\nROC 曲线的全称为受试者工作特征曲线, 英文为Receiver Operating Characteristic Curve.\n\n## 2. 定义 - 以二分问题为例\n\n使数据中的1表示正值, 0 表示负值.\n\n- **P** (Condition Positive) 表示数据中 1 的数量\n\n- **N** (Condition Negatives) 表示数据中 0 的数量\n\n如果模型将一个实例进行二分分类, 则会有四种结果:\n\n- **TP** (True Positive) 表示模型判断结果为 1 且真实值也为 1 的数量\n\n- **TN** (True Negative) 表示模型判断结果为 0 且真实值也为 0  的数量\n\n- **FP** (False Positive) 表示模型判断结果为 1 但真实值为 0 的数量, 也为成为第一类错误 (Type I Error)\n\n- **FN** (False Negative) 表示模型判断结果为 0 但真实值为 1  的数量, 也为成为第二类错误 (Type II Error)\n\n并有以下的一些计算:\n\n- **TPR** (True Positive Rate) 的定义如下:\n\n$$\nTPR = \\dfrac{TP}P = \\dfrac{TP}{TP + FN}\n$$\n\n- **FPR** (False Positive Rate) 的定义如下:\n\n$$\nFPR = \\dfrac{FP}N = \\dfrac{FP}{FP + TN} = 1 - TNR\n$$\n\n- **TNR** (True Negative Rate) 的定义如下:\n\n$$\nTNR = \\dfrac{TN}N = \\dfrac{TN}{FP + TN}\n$$\n\n## 3. ROC 曲线图\n\n将 FPR 设为横坐标, TPR 设为纵坐标, 可以画出一个 ROC 曲线. \n\n( 需要注意的是, 横坐标的值和纵坐标的值没有相关联性, 因此不可以将该曲线作为一个函数看待. )\n\n下面给出一个 ROC 曲线图:\n\n![ROC Curve](img/articles/roc_curve.png)\n\n图中的每个点都代表了一个分类器的性能. 如 A 点所代表的分类器有以下的性能数据:\n\n| TPR  | FPR  | PPV  | F1   | ACC  |\n| ---- | ---- | ---- | ---- | ---- |\n| 0.63 | 0.28 | 0.69 | 0.66 | 0.68 |\n\n既然每个点都代表了一个分类器, 那么一条 ROC 曲线则代表了无数个分类器. ( A )\n\n但是我们通常用一条 ROC 曲线代表一个分类器. ( B )\n\n**A 和 B 不是冲突了吗?**\n\n> 其实，**这些点代表着一个分类器在不同阈值下的分类效果**. \n>\n> 具体的，曲线从左往右可以认为是阈值从0到1的变化过程。\n>\n> 当分类器阈值为0，代表不加以识别全部判断为0，此时TP=FP=0，TPR=TP/P=0，FPR=FR/N=0；\n>\n> 当分类器阈值为1，代表不加以识别全部判断为1，此时FN=TN=0，P=TP+FN=TP, TPR=TP/P=1，N=FP+TN=FP, FPR=FR/N=1。\n>\n> 所以，**ROC曲线描述的其实是分类器性能随着分类器阈值的变化而变化的过程**。\n\n对于ROC曲线，一个重要的特征是它的面积，面积为0.5为随机分类，识别能力为0，面积越接近于1识别能力越强，面积等于1为完全识别。"
    },

    {
        "id": "18f36afa-bd78-4cc7-a068-dbc21dc81d74",
        "title": "大学 (儒家散文)",
        "category": "国学",
        "date": { "year": 2022, "month": 1, "day": 23 },
        "peek": "《大学》是一篇论述儒家修身齐家治国平天下思想的散文",
        "content": "> 2022 年 1 月 1 日\n\n![大学](img/articles/大学.png)\n\n## 简介\n\n《大学》是一篇论述[儒家](https://baike.baidu.com/item/儒家/945629)修身齐家治国平天下思想的[散文](https://baike.baidu.com/item/散文/104524)，原是《[小戴礼记](https://baike.baidu.com/item/小戴礼记/10865398)》第四十二篇，相传为春秋战国时期[曾子](https://baike.baidu.com/item/曾子/208375)所作，实为秦汉时儒家作品，是一部中国古代讨论教育理论的重要著作。\n\n## 正文\n\n大学之道，在明明德，在亲民，在止于至善。知止而后有定，定而后能静，静而后能安，安而后能虑，虑而后能得。物有本末，事有终始。知所先后，则近道矣。\n\n> 《大学》的宗旨，在于弘扬高尚的德行，在于关爱人民，在于达到最高境界的善。知道要达到“至善”的境界方能确定目标，确定目标后方能心地宁静，心地宁静方能安稳不乱，安稳不乱方能思虑周详，思虑周详方能达到“至善”。凡物都有根本有末节，凡事都有终端有始端，知道了它们的先后次序，就与《大学》的宗旨相差不远了。\n\n\n\n古之欲明明德于天下者，先治其国。欲治其国者，先齐其家。欲齐其家者，先修其身。欲修其身者，先正其心。欲正其心者，先诚其意。欲诚其意者，先致其知。致知在格物。物格而后知至，知至而后意诚，意诚而后心正，心正而后身修，身修而后家齐，家齐而后国治，国治而后天下平。\n\n> 在古代，意欲将高尚的德行弘扬于天下的人，则先要治理好自己的国家；意欲治理好自己国家的人，则先要调整好自己的家庭；意欲调整好自己家庭的人，则先要修养好自身的品德；意欲修养好自身品德的人，则先要端正自己的心意；意欲端正自己心意的人，则先要使自己的意念真诚；意欲使自己意念真诚的人，则先要获取知识；获取知识的途径则在于探究事理。探究事理后才能获得正确认识，认识正确后才能意念真诚，意念真诚后才能端正心意，心意端正后才能修养好品德，品德修养好后才能调整好家族，家族调整好后才能治理好国家，国家治理好后才能使天下太平。\n\n自天子以至于庶人，一是皆以修身为本。其本乱而末治者否矣。其所厚者薄，而其所薄者厚，未之有也。此谓知本，此谓知之至也。\n\n> 从天子到普通百姓，都要把修养品德作为根本。人的根本败坏了，末节反倒能调理好，这是不可能的。正像我厚待他人，他人反而慢待我；我慢待他人，他人反而厚待我这样的事情，还未曾有过。这就叫知道了根本，这就是认知的最高境界。\n\n所谓诚其意者，毋自欺也。如恶恶臭，如好好色，此之谓自谦。故君子必慎其独也。小人闲居为不善，无所不至，见君子而后厌然，掩其不善而著其善。 人之视己，如见其肺肝然，则何益矣。此谓诚于中，形于外，故君子必慎其独也。 曾子曰：“十目所视，十手所指，其严乎！” 富润屋，德润身，心广体胖，故君子必诚其意。\n\n> 所谓意念真诚，就是说不要自己欺骗自己。就像厌恶难闻的气味，喜爱好看的女子，这就是求得自己的心满意足。所以君子在独处时一定要慎重。小人在家闲居时什么坏事都可以做出来。当他们看到君子后，才会遮掩躲闪，藏匿他们的不良行为，表面上装作善良恭顺。别人看到你，就像能见到你的五脏六腑那样透彻，装模作样会有什么好处呢？这就是所说的心里是什么样的，会显露在外表上。因此，君子在独处的时候一定要慎重。曾子说：“一个人被众人注视，被众人指责，这是很可怕的啊！”富能使房屋华丽，德能使人品德高尚，心胸宽广能体态安适，所以，君子一定要意念真诚。\n\n《诗》云：“瞻彼淇澳，菉竹猗猗。有斐君子，如切如磋，如琢如磨。 瑟兮僴兮，赫兮喧兮。有斐君子，终不可喧兮。”“如切如磋”者，道学也。 “如琢如磨”者，自修也。“瑟兮僴兮”者，恂傈也。“赫兮喧兮”者，威仪也。“有斐君子，终不可喧兮”者，道盛德至善，民之不能忘也。《诗》云：“於戏，前王不忘！”君子贤其贤而亲其亲，小人乐其乐而利其利，此以没世不忘也。《康诰》曰：“克明德。”《大甲》曰：“顾諟天之明命。”《帝典》曰： “克明峻德。”皆自明也。汤之《盘铭》曰：“茍日新，日日新，又日新。”《康诰》曰：“作新民。” 《诗》曰：“周虽旧邦，其命维新。”是故君子无所不用其极。《诗》云：“邦畿千里，维民所止。”《诗》云：“缗蛮黄鸟，止于丘隅。” 子曰：“于止，知其所止，可以人而不如鸟乎？”《诗》云：“穆穆文王，於缉熙敬止！”为人君，止于仁；为人臣，止于敬；为人子，止于孝；为人父，止于慈； 与国人交，止于信。子曰：“听讼，吾犹人也。必也使无讼乎！”无情者不得尽其辞，大畏民志。此谓知本”。\n\n> 《诗经》上说：“看那弯弯的淇水岸边，绿竹苍郁。那文质彬彬的君子，像切磋骨器、琢磨玉器那样治学修身。他庄重威严，光明显耀。那文质彬彬的君子啊，令人难以忘记！”所谓“像切磋骨器”，是说治学之道；所谓“像琢磨玉器”，是说自身的品德修养；所谓“庄重威严”，是说君子谦逊谨慎，所谓“光明显耀”，是说君子仪表的威严；“那文质彬彬的君子啊，令人难以忘记”，是说君子的品德完美，达到了最高境界的善，百姓自然不会忘记他。《诗经》上说：“哎呀，先前的贤王不会被人忘记。”后世君子，尊前代贤王之所尊，亲前代贤王之所亲，后代百姓因先前贤王而享安乐，获收益。这样前代贤王虽过世而不会被人遗忘。《尚书·周书》中的《康诰》篇上说：“能够弘扬美德。”《尚书·商书》中的《太甲》篇中说：“思念上天的高尚品德。”《尚书·虞书》中《帝典》篇中说：“能够弘扬伟大的德行。”这些都是说要自己发扬美德。商汤的《盘铭》上说：“如果一日洗刷干净了，就应该天天洗净，不间断。”《康诰》篇上说：“劝勉人们自新。”《诗经》上说：“周朝虽是旧国，但文王承受天命是新的。”因此，君子处处都要追求至善的境界。《诗经》上说：“京城方圆千里，都为百姓居住。”《诗经》上说：“啁啾鸣叫的黄莺，栖息在多树的山丘上。”孔子说：“啊呀，黄莺都知道自己的栖息之处，难道人反而不如鸟吗？”《诗经》上说：“仪态端庄美好的文王啊，他德行高尚，使人无不仰慕。”身为国君，当努力施仁政；身为下臣，当尊敬君主；身为人之子，当孝顺父母；身为人之父，当慈爱为怀；与国人交往，应当诚实，有信用。孔子说：“审断争讼，我的能力与他人的一般无二，但我力争使争讼根本就不发生。”违背实情的人，不能尽狡辩之能事，使民心敬畏。这叫做知道什么是根本。\n\n所谓修身在正其心者，身有所忿(fèn)懥(zhì)，则不得其正，有所恐惧，则不得其正， 有所好乐，则不得其正，有所忧患，则不得其正。心不在焉，视而不见，听而不闻，食而不知其味。此谓修身在正其心。\n\n> 如要修养好品德，则先要端正心意。心中愤愤不平，则得不到端正；心中恐惧不安，则得不到端正；心里有偏好，则得不到端正；心里有忧患，则得不到端正。一旦心不在焉，就是看了，却什么也看不到；听了，却什么也听不到；吃了，却辨别不出味道。所以说，修养品德关键在端正心意。\n\n所谓齐其家在修其身者，人之其所亲爱而辟焉86，之其所贱恶而辟焉87，之其所畏敬而辟焉88，之其所哀矜而辟焉89，之其所敖惰而辟焉90。故好而知其恶91，恶而知其美者，天下鲜矣。故谚有之曰：“人莫知其子之恶，莫知其苗之硕92。”此谓身不修，不可以齐其家。\n\n> 如要调整好家族，则先要修养好品德，为什么呢？因为人往往对他所亲近喜爱的人有偏见，对他所轻视讨厌的人有偏见，对他所畏惧恭敬的人有偏见，对他所怜惜同情的人有偏见，对他所傲视怠慢的人有偏见。所以喜爱一个人但又认识到他的缺点，不喜欢一个人但又认识到他优点的人，也少见。因此有一则谚语说：“人看不到自己孩子的过错，人察觉不到自己的庄稼好。”这就是不修养好品德，就调整不好家族的道理。\n\n所谓治国必先齐其家者，其家不可教而能教人者，无之。故君子不出家而成教于国。孝者，所以事君也；弟者，所以事长也；慈者，所以使众也。《康诰》 曰：“如保赤子。”心诚求之，虽不中，不远矣。未有学养子而后嫁者也。一家仁，一国兴仁；一家让，一国兴让；一人贪戾，一国作乱，其机如此。此谓一言偾事， 一人定国。尧、舜率天下以仁，而民从之。桀、纣率天下以暴，而民从之。其所令反其所好，而民不从。是故君子有诸己而后求诸人，无诸己而后非诸人。所藏乎身不恕，而能喻诸人者，未之有也。故治国在齐其家。《诗》云：“桃之夭夭， 其叶蓁蓁。之子于归，宜其家人。”宜其家人，而后可以教国人。《诗》云：“ 宜兄宜弟。”宜兄宜弟，而后可以教国人。《诗》云：“其仪不忒，正是四国。” 其为父子兄弟足法，而后民法之也。此谓治国在齐其家。\n\n> 要治理好国家，必须先要调整好自己的家族，因为不能教育好自己家族的人反而能教育好一国之民，这是从来不会有的事情。所以，君子不出家门而能施教于国民。孝顺，是侍奉君主的原则，尊兄，是侍奉长官的原则，仁慈，是控制民众的原则。《康诰》中说：“像爱护婴儿那样。”诚心诚意去爱护，即便不合乎婴儿的心意，也相差不远。不曾有过先学养育孩子再出嫁的人呀！一家仁爱相亲，一国就会仁爱成风；一家谦让相敬，一国就会谦让成风；一人贪婪暴戾，一国就会大乱——它们的相互关系就是这样。这就叫做一句话可以败坏大事，一个人可以决定国家。尧、舜用仁政统治天下，百姓就跟从他们实施仁爱。桀、纣用暴政统治天下，百姓就跟从他们残暴不仁。他们命令大家做的，与他自己所喜爱的凶暴相反，因此百姓不服从。因此，君子要求自己具有品德后再要求他人，自己先不做坏事，然后再要求他人不做。自己藏有不合“己所不欲，勿施于人”这一恕道的行为，却能使他人明白恕道，这是不会有的事情。因此，国家的治理，在于先调整好家族。《诗经》上说：“桃花绚烂，枝繁叶茂。姑娘出嫁，合家欢快。”只有合家相亲和睦后，才能够调教一国之民。《诗经》上说：“尊兄爱弟。”兄弟相处和睦后，才可以调教一国的人民。《诗经》上说：“他的仪容没有差错，成为四方之国的准则。”能使父亲、儿子、兄长、弟弟各谋其位，百姓才能效法。这就叫做治理好国家首先要调整好家族。\n\n所谓平天下在治其国者，上老老而民兴孝，上长长而民兴弟，上恤孤而民不倍，是以君子有絜矩之道也。所恶于上，毋以使下，所恶于下，毋以事上；所恶于前，毋以先后；所恶于后，毋以从前；所恶于右，毋以交于左；所恶于左，毋以交于右；此之谓絜矩之道。《诗》云：“乐只君子，民之父母。”民之所好好之，民之所恶恶之，此之谓民之父母。《诗》云：“节彼南山，维石岩岩。赫赫师尹，民具尔瞻。”有国者不可以不慎，辟，则为天下僇矣。《诗》云：“殷之未丧师，克配上帝。仪监于殷，峻命不易。”道得众则得国，失众则失国。\n\n> 要平定天下，先要治理好自己的国家。因为居上位的人敬重老人，百姓就会敬重老人；居上位的人敬重兄长，百姓就会敬重兄长，居上位的人怜爱孤小，百姓就不会不讲信义。所以，君子的言行具有模范作用。厌恶上级的所作所为，就不要用同样的做法对待下级；厌恶下级的所作所为，就不要用同样的做法对待上级；厌恶在我之前的人的所作所为，就不要用同样的做法对待在我之后的人，厌恶在我之后的人的所作所为，就不要用同样的做法对待在我之前的人，厌恶在我右边的人的所作所为，就不要用同样的方法与我左侧的人交往；厌恶在我左边的人的所作所为，就不要用同样的方法与我右侧的人交往。这就是所说的模范作用。《诗经》上说：“快乐啊国君，你是百姓的父母。”百姓喜爱的他就喜爱，百姓厌恶的他就厌恶，这就是所说的百姓的父母。《诗经》上说：“高高的南山啊，重峦叠嶂。光耀显赫的尹太师啊，众人都把你仰望。”统治国家的人不能不谨慎，出了差错就会被天下百姓杀掉。《诗经》上说：“殷朝没有丧失民众时，能够与上天的意旨相配合。应以殷朝的覆亡为鉴，天命得来不易啊。”这就是说得到民众的拥护，就会得到国家；失去民众的拥护，就会失去国家。\n\n是故君子先慎乎德。有德此有人，有人此有土，有土此有财，有财此有用。德者本也，财者末也。外本内末，争民施夺。是故财聚则民散，财散则民聚。是故言悖而出者，亦悖而入；货悖而入者，亦悖而出。《康诰》曰：“惟命不于常。”道善则得之，不善则失之矣。《楚书》曰：“楚国无以为宝，惟善以为宝。”舅犯曰：“亡人无以为宝，仁亲以为宝。”\n\n> 所以，君子应该谨慎地修养德行。具备了德行才能获得民众，有了民众才会有国土，有了国土才会有财富，有了财富才能享用。德行为根本，财富为末端。如若本末倒置，民众就会互相争斗、抢夺。因此，财富聚集在国君手中，就可以使百姓离散，财富疏散给百姓，百姓就会聚在国君身边。所以你用不合情理的言语说别人，别人也会用不合情理的言语说你，用不合情理的方法获取的财富，也会被人用不合情理的方法夺走。《康诰》上说：“天命不是始终如一的。”德行好的就会得天命，德行不好就会失掉天命。《楚书》上说：“楚国没有什么可以当做珍宝的，只是把德行当做珍宝。”舅犯说：“流亡的人没有什么可以当做珍宝的，只是把挚爱亲人当做珍宝。”\n\n《秦誓》曰：“若有一介臣，断断兮无他技，其心休休焉，其如有容焉。人之有技，若己有之；人之彦圣，其心好之，不啻若自其口出。实能容之，以能保我子孙黎民，尚亦有利哉！人之有技，媢疾以恶之；人之彦圣，而违之俾不通：实不能容，以不能保我子孙黎民，亦曰殆哉！”唯仁人放流之，迸诸四夷，不与同中国。此谓唯仁人为能爱人，能恶人。见贤而不能举，举而不能先，命也；见不善而不能退，退而不能远，过也。好人之所恶，恶人之所好，是谓拂人之性，菑必逮夫身。是故君子有大道，必忠信以得之，骄泰以失之。\n\n> 《秦誓》上说：“如果有这样一个大臣，他虽没有什么才能，但心地诚实宽大，能够容纳他人。别人有才能，如同他自己有一样；别人德才兼备，他诚心诚意喜欢，不只是口头上说说而已。能够留用这人，便能够保护我的子孙百姓。这对百姓是多么有利啊。如果别人有才能，就嫉妒厌恶；别人德才兼备，就阻拦他施展才干。不能留用这样的人，他不能保护我的子孙百姓，这种人也实在是危险啊。”只有仁德的人能把这种嫉妒贤人的人流放，驱逐到边远地区，使他们不能留在国家的中心地区。这叫做只有仁德的人能够爱人，能够恨人。看到贤人而不举荐，举荐了但不尽快使用，这是怠慢。看到不好的人却不能摈弃，摈弃了却不能放逐到远方，这是过错。喜欢人所厌恶的，厌恶人所喜欢的，这是违背了人性，灾害必然会降临到他的身上。因此，君子所有的高尚德行，一定要忠诚老实才能够获得，骄纵放肆便会失去。\n\n生财有大道，生之者众，食之者寡，为之者疾，用之者舒，则财恒足矣。仁者以财发身，不仁者以身发财。未有上好仁而下不好义者也，未有好义其事不终者也，未有府库财非其财者也。孟献子曰：“畜马乘，不察于鸡豚；伐冰之家，不畜牛羊；百乘之家，不畜聚敛之臣。与其有聚敛之臣，宁有盗臣。”此谓国不以利为利，以义为利也。长国家而务财用者，必自小人矣。彼为善之，小人之使为国家， 灾害并至。虽有善者，亦无如之何矣！此谓国不以利为利，以义为利也。 \n\n> 发财致富有这样一条原则：生产财富的人要多，消耗财富的人要少；干得要快，用得要慢，这样就可以永远保持富足了。有德行的人会舍财修身，没有德行的人会舍身求财。没有居上位的人喜爱仁慈而下位的人不喜爱忠义的；没有喜爱忠义而完不成自己事业的；没有国库里的财富最终不归属于国君的。孟献子说：“拥有一车四马的人，不应计较一鸡一猪的财物；卿大夫家不饲养牛羊；拥有马车百辆的人家，不豢养收敛财富的家臣。与其有聚敛民财的家臣，还不如有盗贼式的家臣。”这是说，国家不应把财物当做利益，而应把仁义作为利益。掌管国家大事的人只致力于财富的聚敛，这一定是来自小人的主张。假如认为这种做法是好的，小人被用来为国家服务，那么灾害就会一起来到，纵使有贤臣，也无济于事啊！这就是说国家不要把财利当做利益，而应把仁义当做利益。\n\n\n\n## 参考资料\n\n1. [大学 (儒家散文) - 百度百科](https://baike.baidu.com/item/%E5%A4%A7%E5%AD%A6/5655065?fr=aladdin)\n\n\n\n\n\n\n\n\n\n\n\n"
    },

    {
        "id": "9ef7c04b-0af7-4884-927b-01a5e22a9cf7",
        "title": "git pull",
        "category": "Git",
        "date": { "year": 2021, "month": 12, "day": 24 },
        "peek": "用于从远程获取代码并合并本地的版本",
        "content": "> 2021 年 12 月 24 日\n\n## 干什么用的\n用于从远程获取代码并合并本地的版本.\n\n## 本质\n```bash\ngit pull = git fetch + git merge\ngit pull --rebase = git fetch + git rebase\n```\n\n## `--rebase` vs 没有 `--rebase`\n### 没有 `--rebase`\n```bash\nA <- B <- Y\n     ^    ^\n     |    |\n     X <- M\n```\n### `--rebase`\n```bash\nA <- B <- Y\n     ^    ^\n     |    |\n    (X) <- M\n```\n其中 X 为自己的分支, Y 为其他人的. 由此可见, `--rebase` 将自己的旧分支舍弃掉了, 隐去了菱形的困惑.\n### 官网原文\n\nWhen true, rebase the current branch on top of the upstream branch after fetching. If there is a remote-tracking branch corresponding to the upstream branch and the upstream branch was rebased since last fetched, the rebase uses that information to avoid rebasing non-local changes.\n\n## 参考链接\n- https://git-scm.com/docs/git-pull\n- https://www.runoob.com/git/git-pull.html\n- https://www.cnblogs.com/kevingrace/p/5896706.html"
    },

    {
        "id": "5efc5083-2563-4fc4-aabb-eaea5993d69a",
        "title": "React HTML 元素 截图",
        "category": "React",
        "date": { "year": 2021, "month": 11, "day": 28 },
        "peek": "因为需要的依赖只有 React Hook 的写法, 所以使用 class 的用户需要注意一下",
        "content": "> 2021 年 11 月 28 日\n\n## 写在前面\n因为需要的依赖只有 React Hook 的写法, 所以使用 class 的用户需要注意一下.\n\n## 简介\n这篇文章记录了如何在 [React](https://reactjs.org/) 框架的使用中集成 HTML 元素截图的功能.\n\n## 依赖\n所需要的依赖: [use-react-scrrenshot](https://www.npmjs.com/package/use-react-screenshot)\n\n## 具体用例\n```javascript\nimport { useScreenshot } from 'use-react-screenshot'\nimport { createRef } from 'react';\n\n\nfunction App() {\n    const ref = createRef(null);\n    const [image, takeScreenshot] = useScreenshot()\n    const getImage = () => takeScreenshot(ref.current\n    return (\n        <div ref={ref}>\n            <button onClick={async () => {\n                await getImage();\n                var link = document.createElement('a');\n                link.download = `${new Date()}.png`;\n                link.href = $('#screenshot').attr('src');\n                link.click();\n            }}/>\n            <img width={'0'} id={'screenshot'} src={image} alt={'Screenshot'}/>\n        </div>\n    );\n}\n```\n\n## 引用\n1. https://stackoverflow.com/questions/44555950/custom-download-name-with-javascript-or-jquery\n2. https://www.npmjs.com/package/use-react-screenshot"
    },

    {
        "id": "da085f00-bf68-46fc-9e72-9df2dea399f0",
        "title": "Font family [‘sans-serif‘] not found.Falling back to DejaVu Sans.解决办法",
        "category": null,
        "date": { "year": 2021, "month": 11, "day": 25 },
        "peek": "使用 matplotlib 画图时中文无法正常显示, 且报警告",
        "content": "> 2021 年 11 月 25 日\n>\n> 原文链接: https://blog.csdn.net/sinat_40875078/article/details/104326855\n\n### 问题\n使用 `matplotlib` 画图时中文无法正常显示, 且报警告.\n\n### 解决方法\n首先, 找到字体路径\n\n```python\nimport matplotlib    \nprint(matplotlib.matplotlib_fname())\n```\n然后, 下载字体.\n> 下载字体链接: https://www.fontpalace.com/font-download/SimHei/\n\n并将下载的文件放入之前找到的字体路径的 `fonts` 文件夹下面.\n\n最后, 删除 matplotlib 的缓冲目录\n```python\nimport matplotlib\nmatplotlib.get_cachedir()\n```\n````bash\nrm -rf {你找到的那个缓冲路径}\n```\n"
    },

    {
        "id": "84df1b7e-433b-42f3-b69f-1314ea29dcc2",
        "title": "如何准备考试",
        "category": null,
        "date": { "year": 2021, "month": 11, "day": 22 },
        "peek": "临近考试, 是一些比较理论的数学课, 而且学得一般般, 所以请教老朋友他是如何准备考试的",
        "content": "> 2021 年 11 月 22 日\n\n## 一点背景\n临近考试, 是一些比较理论的数学课, 而且学得一般般, 所以请教老朋友他是如何准备考试的. (这个问题我想问他好久了, 然而不知道出于什么原因一直没有问.) 这个老朋友, (以下简称 J, ) 是一个学习成绩很有优异的同学! 虽然他老是说自己的应试学习法, 但是我觉得他太谦虚啦.\n\n## Q & A\n#### 说说你是怎么准备考试的?\n- \"喜欢疯狂做题\"\n- \"尤其数学相关\"\n- \"就是对题目熟练了, 考试就不会来不及了\"\n\n#### 但是概念也不大会的情况下, 应该怎么办呢?\n- \"然后概念的问题我喜欢用手抄一遍\"\n- \"我感觉我会慢下心\"\n- \"去关注里面的一些细节\"\n- \"然后开个手游\" (手动狗头)\n\n#### 就是在做题目的时候, 题量很大怎么办?\n这个问题虽然没有得到解答, 但是得到一个新的认知:\n- J: \"记得当时因为太多没能做很多遍, 贼难受\"\n- 我: \"正常操作是要做很多遍吗?\"\n- J: \"喜欢在做题中学习知识点, 所以每一遍重点都不一样\"\n\n原来人家题都刷了很多遍了! 嗯, 是我肤浅了.\n\n## 总结\n概念抄一遍, 题目好几遍.\n题目里面学概念, 手抄概念见细节."
    },

    {
        "id": "a0e6f23f-96ea-456e-bbce-4510d82646d6",
        "title": "用 Python 进行 Cross Validation",
        "category": "机器学习",
        "date": { "year": 2021, "month": 11, "day": 22 },
        "peek": "使用 Python 作为机器学习的语言时, 有很方便的包用于交叉验证. 在这里介绍用 sklearn 相关包的方法",
        "content": "> 2021 年 11 月 22 日\n\n## 简介\n使用 Python 作为机器学习的语言时, 有很方便的包用于交叉验证. 在这里介绍用 `sklearn` 相关包的方法.\n\n## `cross_val_score` 方法\n\n若想要用 `cross_val_score` 进行交叉验证, 要求被检验的模型实现了 `sklearn` 机器学习模型的所有相关接口.\n\n### 第一步 - 导包\n```python\nfrom sklearn.model_selection import cross_val_score\n```\n\n### 第二步 - 使用\n对于模型和数据集, 根据不同的参数, 得出相应的分数. 其中 `cv` 为 fold 的数量, 每次 cross validation 都会得到 `cv` 个分数然后得到一个平均值便是这次 cross validation 的分数.\n```python\nX = ...  # predictors\ny = ...  # target\n\nscore_dict = {}  # 初始化分数字典\nparam_space = ...  # 参数空间\n\nfor param_value in param_space:\n    model = Model(param=param_value)\n    score_dict[cost] = np.mean(cross_val_score(model, X, y, cv=10))\n```\n\n### 例子\n以 `SVC` 为例,\n```python\nX = ...  # predictors\ny = ...  # target\n\nsvc_score_dict = {}\ncost_values = np.logspace(-2, 6, 10)\n\nfor cost in cost_values:\n    svc = SVC(kernel='linear', C=cost)\n    svc_score_dict[cost] = np.mean(cross_val_score(svc, X, y, cv=10))\n```\n\n## 使用 `KFold`\n\n`KFold` 的作用在于生成交叉验证的数据集索引. 当需要被验证的模型没有满足 `sklearn` 模型的接口时, 可以使用这个方法.\n\n### 第一步 - 导包\n~~~python\nfrom sklearn.model_selection import KFold\n~~~ \n\n### 第二步 - 使用\n~~~python\nscore_dict = {}\nN = ...  # number of folds\nparam_space = ...\n\nfor param in param_space:\n    model = model(param=param)\n    kf = KFold(n_splits=N)\n    scores = []\n    for train_index, test_index in kf.split(X_train):\n      X_train_kv, X_test_kv = X_train[train_index], X_train[test_index]\n      y_train_kv, y_test_kv = y_train[train_index], y_train[test_index]\n      model.fit(X_train_kv, y_train_kv)\n      scores.append(model.score(X_test_kv, y_test_kv))\n    score_dict[param] = sum(scores) / N\n~~~\n\n### 例子\n以 `KNN` 为例:\n\n~~~python\nN = 10\nscore_dict = {}\nparam_space = list(range(1, 11))\nfor param in param_space:\n    model = KNN(k=param)\n    kf = KFold(n_splits=N)\n    scores = []\n    for train_index, test_index in kf.split(X_train):\n        X_train_kv, X_test_kv = X_train[train_index], X_train[test_index]\n        y_train_kv, y_test_kv = y_train[train_index], y_train[test_index]\n        model.fit(X_train_kv, y_train_kv)\n        scores.append(model.score(X_test_kv, y_test_kv))\n    score_dict[param] = sum(scores) / N\n~~~\n\n## 更多 - 结果可视化\n在 cross validation 后, 通常会对分数进行可视化来选出最好的参数. 模板如下:\n```python\nplt.plot(list(score_dict.keys()), list(score_dict.values()), marker='o')\nplt.plot(\n    max(score_dict, key=score_dict.get),\n    max(list(score_dict.values())), marker='o', markersize=8, c='r', label='max_accuracy')\nplt.legend()\nplt.xlabel('')  # 写入参数的名称\nplt.ylabel('Score')\nplt.xscale('log')\nplt.show()\n```\n\n## 参考资料\n1. [sklearn - cross_val_score](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.cross_val_score.html)\n2. [sklearn - KFold](https://scikit-learn.org/stable/modules/generated/sklearn.model_selection.KFold.html)\n"
    },

    {
        "id": "861e658c-1f9b-4d93-9c22-1e7ffe84273a",
        "title": "Mac 无法访问 Github",
        "category": null,
        "date": { "year": 2021, "month": 11, "day": 3 },
        "peek": "浏览器无法访问 Github",
        "content": "> 2021 年 11 月 3 日\n>\n> [原文链接](https://www.jianshu.com/p/eea7e1276d2d)\n\n### 问题\n浏览器无法访问 Github.\n\n### 解决方法\n#### 第一步\n打开 https://websites.ipaddress.com/github.com\n找到网页中显示的 IP Address, 记下并标记为 IP1.\n\n#### 第二步\n打开 https://websites.ipaddress.com/github.global.ssl.fastly.net#ipinfo \n找到网页中显示的 IP Address, 记下并标记为 IP2.\n\n#### 第三步\n打开位于 /etc 的名为 hosts 的文件, 拷贝其中的所有内容.\n\n#### 第四步\n在桌面创建一个新文件, 文件名称为 hosts, 将第三步中拷贝的信息全部粘贴到这个文件中.\n\n#### 第五步\n在 hosts 文件中添加以下记录. (如果原本就存在则直接修改.)\n```text\nIP1 github.com\nIP2 github.global.ssl.fastly.net\n```\n> 其中 IP1 和 IP2 为第一步和第二步中得到.\n\n#### 第六步\n保存并将新的 hosts 文件移动到 /etc 文件夹中. 此时旧文件就会被覆盖.\n\n#### 第七步\n终端输入命令:\n```bash\nsudo killall -HUP mDNSResponder\n```\n\n#### 完成!"
    },

    {
        "id": "58d9aa98-b8c3-45b1-a086-4d87f0ef0192",
        "title": "二战轰炸主题纪录片小记",
        "category": null,
        "date": { "year": 2021, "month": 10, "day": 3 },
        "peek": "德国纳粹用轰炸打先锋，用闪电战快速侵略。轰炸对城市建筑的破坏极大",
        "content": "> 2021 年 10 月 3 日\n\n## 一点小结\n\n- 德国纳粹用轰炸打先锋，用闪电战快速侵略。\n- 轰炸对城市建筑的破坏极大。许多国家为了保护城市的建筑完整，只能宣布投降。\n\n## 历史\n\n德军的进度一直很顺畅，直到遇见了顽强的英国。在长时间轰炸未果后，就放弃了轰炸计划。\n\n接下来就是英美共同轰炸德国。\n\n根据英国的一个教授的推断：破坏的建筑对幸存者造成的心理伤害甚至比失去亲人更加巨大，于是由此为依据展开对城市的轰炸计划。但是真正的效果却并不理想。\n\n而且高空坠落的炸弹总是偏离预计落点，有很多甚至直接落在了乡村地区而非城市中心。这其中有很大原因是高度太高，但是低空飞行又很容易被地面防空设备击落。后来发明了一种仪器，可以在保证高空飞行时，着陆误差保证在30米内。只可惜该仪器对天气要求很高，因为它是基于视觉观察瞄准目标的。\n\n后来为了进一步提升轰炸的效果，盟军采用了以下的轰炸流程：普通轰炸、燃烧弹、普通轰炸。这么做的目的是为了让火势可以快速蔓延并形成蔓延的趋势，从而摧毁整个城市。其中第二次的普通轰炸是为了防止消防员救火。至于这个轰炸方案的效果如何，我不记得了。\n\n盟军在轰炸前会对那些有历史遗迹的城市特别关照。这些城市会被分级从而采取相应的轰炸方案。\n\n后来德军发明了V2火箭。这家伙是导弹的鼻祖。对后来的航天事业也有很大的价值。\n\n> V2火箭的发明者后来成为了美籍人员。\n\n在太平洋战场这边，美军使用凝固燃烧弹进行轰炸。这种炸弹的烧伤力对于人来说比普通的燃烧弹效果好很多。因为里面的燃烧物质成胶状，会粘附在人体表面从而造成毁灭性的伤害。美军用此武器造成了大量人员伤亡，但是却没有等到胜利。\n\n后来日本天皇提出只要保存他的皇位就投降，但是美国人没有答应。再往后就是美国人的核武器试爆成功，先后两枚核武器在广岛和长崎爆炸，两座城市瞬间毁灭并带来了巨大的核辐射。最后日本投降，但是天皇皇位仍然得以保留… \n\n## 总结\n\n简单说就是传统轰炸到导弹，再到核武器。轰炸的目标主要是摧毁城市以及敌方的资源。除了使用核武器的轰炸，其他的轰炸方式对被轰炸的一方的生产效率几乎没有受到影响，最大的受害者却是普通民众。\n\n"
    },

    {
        "id": "bbb4e189-4ef1-4910-9a55-41e91cf5d1e3",
        "title": "WiFi 信号很好, 网络很很通畅, 但是 App Store, iCloud 等网络服务一直很不稳定怎么办?",
        "category": null,
        "date": { "year": 2021, "month": 9, "day": 25 },
        "peek": "坐标香港, 使用大陆的 Apple ID, 连了家里的 WiFi. 家里的 WiFi 信号很好而且网速也不错, 但是",
        "content": "> 2021 年 9 月 25 日\n\n## 问题\n坐标香港, 使用大陆的 Apple ID, 连了家里的 WiFi. 家里的 WiFi 信号很好而且网速也不错, 但是下载系统更新, 从 App Store 下载 App 都很慢, 而且 iCloud 服务完全没法用.\n\n## 解决方法\n在设置里面找到已连接的 WiFi, 将 DNS 模式改为手动, 然后删除原来的 DNS 服务器, 再手动依次添加 `114.114.114.114`, `8.8.8.8` 即可."
    },

    {
        "id": "73107442-a6c3-4d97-bba5-ad56b79650d3",
        "title": "HomePod mini 重置",
        "category": null,
        "date": { "year": 2021, "month": 9, "day": 25 },
        "peek": "本文介绍了如何重置 HomePod mini",
        "content": "> 2021 年 9 月 25 日\n\n## 操作方式\n1. 断电10秒以上\n2. 插电出现白光后等5秒以上\n3. 手指长按面板中间直到出现红光\n4. 继续长按直到有三声 \"beep\"\n\n## 参考链接\n1. [How to factory reset HomePod mini (YouTube)](https://youtu.be/ZFwQoiByaBU)\n"
    },

    {
        "id": "c5574070-4f20-4d88-ad9c-be885b9b7a5b",
        "title": "LaTeX - Block indentation",
        "category": "LaTeX",
        "date": { "year": 2021, "month": 9, "day": 23 },
        "peek": "如题所示",
        "content": "> 2021 年 9 月 23 日\n\n## 导包\n```latex\n\\usepackage{scrextend}\n```\n\n## 使用\n```latex\n\\begin{addmargin}[8em]{2em} % [left indentation]{right indentation}\nasdasdasdasd\\\\\nasdasd\n\\end{addmargin}\n```\n\n## 参考链接\nhttps://tex.stackexchange.com/questions/37080/how-can-i-indent-a-block-of-text-for-a-specified-amount/37084"
    },

    {
        "id": "9c52d1ae-2a5a-4496-b467-ad2631cf950a",
        "title": "\"only if\" 和 \"if and only if\"",
        "category": "数学",
        "date": { "year": 2021, "month": 9, "day": 20 },
        "peek": "在学习数学的过程中, 总是能看见 \"if and only if\" 这样的表达",
        "content": "> 2021 年 9 月 20 日\n\n## 问题\n在学习数学中, 总是能看见 \"if and only if\" 这样的表达, 于是产生疑问: 为什么不直接用 \"only if\" 而一定要用 \"if and only if\" 呢?\n\n## 解答\n简单地说, \n- \"A only if B\": 只有 B 是真的, A 才是真的.\n$$\nB \\implies A\n$$\n\n- \"A if and only if B\": 如果 A 是真的, 那么 B 就是真的; 如果 B 是真的, 那么 A 也是真的.\n$$\n(A \\implies B) \\wedge (B \\implies A)\n$$\n\n\n## 参考链接\n1. [What is the difference between only if and iff?](https://math.stackexchange.com/questions/68293/what-is-the-difference-between-only-if-and-iff)\n"
    },

    {
        "id": "e99f2df9-be60-4195-b867-ee402d78b34e",
        "title": "LaTeX - 支持中文",
        "category": "LaTeX",
        "date": { "year": 2021, "month": 9, "day": 20 },
        "peek": "如题所示",
        "content": "> 2021 年 9 月 20 日\n\n## 安装\n下载 `ctex` 包.\n```bash\ntlmgr install ctex\n```\n\n## 导包\n```latex\n\\usepackage[UTF8]{ctex}\n```\n\n## 编译\n注意要使用 `XeLaTeX` 编译.\n\n## 参考链接\n1. [在Mac下安装使用支持中文的LaTeX](https://www.cnblogs.com/kko-liu/p/4696429.html)\n2. [Latex支持中文编辑的两种方式](https://blog.csdn.net/meilikafei/article/details/80145149)\n"
    },

    {
        "id": "4d687d5b-7864-479e-b234-66f9bb9e479f",
        "title": "LaTeX 超链接",
        "category": "LaTeX",
        "date": { "year": 2021, "month": 9, "day": 20 },
        "peek": "如题所示",
        "content": "> 2021 年 9 月 20 日\n\n## 如何在 LaTeX 中插入超链接?\n1. 导包. `\\usepackage[colorlinks,linkcolor=red]{hyperref}`.\n2. 插入超链接.\n\n加入超链接的方式有两种. 第一种为**直接链接**, 第二种为**隐式链接**.\n\n### 直接链接\n```latex\n\\url{https://www.zhejianglao.cn}\n````\n\n### 隐式链接 \n```latex\n\\href{https://www.zhejianglao.cn}}{Darin 的博客}\n```\n\n\n## 参考链接\n[Latex插入超链接](https://blog.csdn.net/weixin_36670529/article/details/109115800)\n"
    },

    {
        "id": "335ceb7a-310f-4204-a370-2815ff394b90",
        "title": "iPhone 靠近 HomePod 抖动怎么关?",
        "category": null,
        "date": { "year": 2021, "month": 9, "day": 13 },
        "peek": "当 iPhone 靠近 HomePod 时, 就会触发某种机制, 使得 iPhone 开始抖动",
        "content": "> 2021 年 9 月 13 日\n\n## 问题\n\n当 iPhone 靠近 HomePod 时, 就会触发某种机制, 使得 iPhone 开始抖动. 它的原来设计目的是让 iPhone 上播放的媒体在手机靠近 HomePod 时自动转移. 然而, 这个机制对个人来说还是很扰人. 总之就是弊大于利.\n\n## 解决方法\n打开 iPhone 的 `设置` $\\rightarrow$ `通用` $\\rightarrow$ `隔空播放与接力`, 将 `转移到HomePod` 这个选项关闭."
    },

    {
        "id": "a6c83078-c0b9-4ebc-9810-b2523f7ce4b4",
        "title": "LeetCode - Rand7 -> Rand 10",
        "category": "算法",
        "date": { "year": 2021, "month": 9, "day": 5 },
        "peek": "已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整",
        "content": "> 创建于 2021 年 9 月 5 日\n\n## 题目描述\n已有方法 rand7 可生成 1 到 7 范围内的均匀随机整数，试写一个方法 rand10 生成 1 到 10 范围内的均匀随机整数。\n\n不要使用系统的 Math.random() 方法。\n\n来源：力扣（LeetCode）\n链接：https://leetcode-cn.com/problems/implement-rand10-using-rand7\n\n## 解法\n### 拒绝采样\n#### \"理论\"\n用两个 `rand7` 得到的数相乘, 有下面的表格\n\n| |1|2|3|4|5|6|7|\n|-------|-------|-------|---|---|---|---|---|\n|1|1|2|3|4|5|6|7|\n|2|2|4|6|8|10|12|14|\n|...|...|...|...|...|...|...|...\n|6|6|12|18|24|30|36|42|\n|7|7|14|21|28|35|42|49|\n\n然后得到每个数出现的概率, 如数字 $1$ 出现的概率是 $\\dfrac1{49}$ , 数字 $4$ 出现的概率是 $\\dfrac 3{49}$ .\n最后选出其中10个概率相同的数字即可.\n\n#### \"实际\"\n同用两个 `rand7` 得到的数相乘. 得到下面的表格\n\n| |1|2|3|4|5|6|7|\n|-------|-------|-------|---|---|---|---|---|\n|1|1|2|3|4|5|6|7|\n|2|8|9|10|1|2|3|4|\n|...|...|...|...|...|...|...|...\n|6|36|37|38|39|40|x|x|\n|7|x|x|x|x|x|x|x|\n\n> x 代表忽略\n\n由此通过 $[1, 40]$ 就可以得到 `rand10`.\n\n## 代码\n```java\n/**\n * The rand7() API is already defined in the parent class SolBase.\n * public int rand7();\n * @return a random integer in the range 1 to 7\n */\nclass Solution extends SolBase {\n    public int rand10() {\n        int row, col, idx;\n        do {\n            row = rand7();\n            col = rand7();\n            idx = col + (row - 1) * 7;\n        } while (idx > 40);\n        return 1 + (idx - 1) % 10;\n    }\n}\n\n```"
    },

    {
        "id": "099a714d-88fa-4467-9ad9-93fa2afbee4a",
        "title": "iPhone 突然黑屏",
        "category": null,
        "date": { "year": 2021, "month": 9, "day": 3 },
        "peek": "今天在通讯录中输入\"农业银行\"后, 突然黑屏, 也无法关机重启.",
        "content": "> 2021 年 9 月 3 日\n\n## 情况\n今天在通讯录中输入\"农业银行\"后, 突然黑屏, 也无法关机重启.\n**手机型号**: iPhone 12 mini.\n**备注**: 第一次遇见该状况.\n\n## 解决办法\n如图所示, 依次执行下面的步骤:\n\n1. 快速按下音量加键, 然后松开\n2. 快速按下音量减键, 然后松开\n3. 长按开机键\n\n\n![解决方法](img/articles/iphone-x-later-force-restart-animation.gif)\n \n## 感想\n苹果的文档写的还挺全面的. 不愧是大厂.\n\n## 参考链接\n[如果您的iPhone无法开机或死机](https://support.apple.com/zh-cn/HT201412)"
    },

    {
        "id": "c2c71693-b31c-4bf2-9900-c1f48b1a8706",
        "title": "icloud Drive 里面某个 APP 文件夹不见了怎么办?",
        "category": null,
        "date": { "year": 2021, "month": 8, "day": 29 },
        "peek": "可能是因为网络的缘故, icloud 的文件无法同步. 一番操作后在 Mac 上发现曾经的一个APP的文件夹不见了",
        "content": "> 创建于 2021 年 8 月 29 日\n\n## 问题描述\n可能是因为网络的缘故, icloud 的文件无法同步. 一番操作后在 Mac 上发现曾经的一个APP的文件夹不见了. 而且在退出 icloud 账号再重新登录等操作都完成后均无法重新出现. 更奇怪的是在网页版中这个文件夹好好地待着.\n\n## 解决方法\n在这个 APP 所在的设备上创建一个文件夹.\n\n## 其他\n这么奇怪的事情还是第一次遇到."
    },

    {
        "id": "77a540a4-40a8-4bd6-b98f-f9057469f8a1",
        "title": "Mac - Github 修改命令行中的密码",
        "category": null,
        "date": { "year": 2021, "month": 8, "day": 14 },
        "peek": "Github 在今年八月份启用账号密码登录并改用token登录",
        "content": "> 2021年8月14日\n\n## 背景\nGithub 在今年八月份启用账号密码登录并改用token登录. \n\n使用token登录其实就是先在官网生成一个token(一串码), 然后在本地用token代替原来的密码使用. \n\n本人的环境是mac.\n\n## 操作方式\n其实很简单, 打开 Keychain Access APP. \n\n然后搜索\"github.com\", 其中会有一条\"Internet password\"的记录. \n\n把找到的记录中的密码用token替换进去就好了."
    },

    {
        "id": "70eb4be5-f301-4be9-906d-af128238e447",
        "title": "好用的眼药水",
        "category": null,
        "date": { "year": 2021, "month": 8, "day": 2 },
        "peek": "以下信息仅供参考, 购买前请咨询眼科医生",
        "content": "> 2021年8月2日\n## 写在前面\n*以下信息仅供参考, 购买前请咨询眼科医生*\n\n*眼药水不宜长期使用*\n\n## 想要的眼药水\n这里想找的眼药水不是那种具备治疗功能的眼药水, 如消炎等, 而是那种可以缓解眼睛干涩疲惫的眼药水.\n\n## 找到的眼药水\n在小红书上面看了两个眼科医生的视频, 找到以下三款眼药水:\n\n- 海露滴眼液 ✨✨\n- 羧甲基纤维素钠滴眼液 ✨✨✨\n- 聚乙烯醇滴眼液 ✨\n\n其中第三款根据视频里面的描述已经比较过时了."
    },

    {
        "id": "248585fd-bcbb-4a7f-ba9a-f3c53c09cab6",
        "title": "什么时候应该使用 RuntimeException ?",
        "category": "Java",
        "date": { "year": 2021, "month": 7, "day": 26 },
        "peek": "程序员的锅就要用RuntimeException, 否则就是Exception.",
        "content": "> 2021年7月26日\n\n## 答案\n**程序员的锅就要用`RuntimeException`, 否则就是`Exception`.**\n> 举个例子, `ArrayIndexOutOfBoundException` 就是因为程序员的错误导致的, 所以就是 `RuntimeException`. 这种错误没有必要去特别处理(`try`/`catch`), 而是需要程序员自己去调试修正.\n\n## 异常简单分类\n\nJava中的异常分为两类: `Exception` 和 `RuntimeException`. \n\n其中前者属于检查型异常, 也就是如果在某处被抛出, 则后续调用时必须要写代码时将其处理. (处理方式有重新再抛出和使用try/catch语句两种.) \n\n而后者则没有这样的要求. 毕竟人家是runtime的异常, 不应该在编译期被关注.\n\n## 什么时候使用/抛出`RuntimeException`?\n\n那么什么时候应该使用`RuntimeException`呢? 网上的说法是 \n\n> \"*通常如果一切正常的话本不该发生的异常*\". \n\n额, 每个字都懂怎么连起来就看不懂了呢? 自己总结一下吧. \n\n常见的`RuntimeException`有`ArrayIndexOutOfBoundException`, `ClassCastException`, `NullPointerException`... \n\n之所以这类错误不应该被预先处理, 是因为这些异常出现的原因就是bug, 应该直接被修复, 而不是在运行时通过预先的处理方式来处理. \n\n所以得出结论: **当认为某个情况是程序员的错误所导致的时候, 就应该抛出`RuntimeException`**. \n\n这个说法说的通. 这样的话, `Exception` 就是因为其他不可抗力的因素导致的错误. \n\n> 例如`IOException` 就是因为电脑或者是操作系统无法读写文件导致的, 不是程序员的锅.\n\n## 参考链接\n[1] java异常问题。什么时候用RuntimeException????, https://blog.csdn.net/evilcry2012/article/details/85316938"
    },

    {
        "id": "53471ce7-6ac6-4b11-a30f-a7b50775857a",
        "title": "MacBook Pro 屏幕清洁",
        "category": null,
        "date": { "year": 2021, "month": 7, "day": 26 },
        "peek": "在清洁 MacBook Pro (以下简称MBP) 屏幕时, 千万不要用含有酒精的清洁剂喷洒屏幕. ",
        "content": "> 2021年7月26日\n\n## 错误的清洁方式\n在清洁 MacBook Pro (以下简称MBP) 屏幕时, *千万不要用含有酒精的清洁剂喷洒屏幕*. 因为 MBP 的屏幕有一层涂层, 使用酒精可能会对涂层造成腐蚀. \n\n## 正确的清洁方式\n正确的清洁方式很简单: **只需要用一张用水打湿的纸巾, 将脏的部分擦除, 然后用一块擦屏幕的布擦干即可.** 这是我自己的方法, 仅供参考吧."
    },

    {
        "id": "b1fc2b86-8f9b-481a-a63e-cc00c3d7225e",
        "title": "二分查找",
        "category": "算法",
        "date": { "year": 2021, "month": 7, "day": 25 },
        "peek": "今天在写LeetCode题目的时候忽然发现连二分查找都不大会写了, 给我吓了一跳. 赶紧找来算法第四版, 把代码敲一敲!",
        "content": "> 2021年7月25日\n\n今天在写LeetCode题目的时候忽然发现连二分查找都不大会写了, 给我吓了一跳. 赶紧找来算法第四版, 把代码敲一敲!\n\n```java\npublic class BinarySearch {\n    /**\n     * Returns the index of the specified key in the specified array.\n     *\n     * @param  a the array of integers, must be sorted in ascending order\n     * @param  key the search key\n     * @return index of key in array {@code a} if present; {@code -1} otherwise\n     */\n    public static int indexOf(int[] a, int key) {\n        int lo = 0;\n        int hi = a.length - 1;\n        while (lo <= hi) {\n            // Key is in a[lo..hi] or not present.\n            int mid = lo + (hi - lo) / 2;\n            if      (key < a[mid]) hi = mid - 1;\n            else if (key > a[mid]) lo = mid + 1;\n            else return mid;\n        }\n        return -1;\n    }\n}\n```"
    },

    {
        "id": "dce78b8f-af27-4958-8dd1-64da496097b6",
        "title": "Lesson 12 - Creating your own types",
        "category": "Haskell",
        "date": { "year": 2021, "month": 7, "day": 13 },
        "peek": "Creating your own types",
        "content": "> Created on 2021/07/13\n\n## Synonyms\n\nUse `type` keyword to do synonyms.\n\n```haskell\ntype FirstName = String\ntype LastName = String\ntype MiddleName = String\ntype Age = Int \ntype Height = Int\ntype PatientName = (String, String)\n```\n\n## New types\n\nUse `data` keyword to create new types.\n\n```haskell\ndata Sex = Male | Female\ndata Name = Name FirstName LastName | NameWithMiddle FirstName MiddleName LastName \n```\n\n### Write a function with the new type\n\n```haskell\nsexInitial :: Sex -> Char\nsexInitial Male = 'M'\nsexInitial Female = 'F'\n```\n\n## Record syntax\n\nFirst look at this `patient` type.\n\n```haskell\ndata Patient = Patient Name Age Height\n```\n\nNow if we need to access attributes from an instance, we need to write functions like the following.\n\n```haskell\ngetName :: Patient -> Name\ngetName (Patient n _ _) = n\n\ngetAge :: Patient -> Int\ngetAge (Patient _ a _) = a\n```\n\nImagine we have 12 attributes, this would be tedious.\n\nWe can use *record syntax* to fix this problem\n\n```haskell\ndata Patient = Patient {\n    name :: Name,\n    age :: Age,\n    height :: Int,\n}\n```\n\n### Accessor\n\nAssume we have the following patient\n\n```haskell\njeckieSmith :: Patient\njeckieSmith = Patient {\n    name = Name \"Jackie\" \"Smith\",\n    age = 43,\n    height = 62,\n}\n```\n\nTo access the name, we can do this\n\n```haskell\nname jeckieSmith\n```\n\n### Mutator\n\nTo mutate an attribute, we can do this\n\n```haskell\njeckieSmithUpdated = jeckieSmith { age = 34 }\n```\n\n## Practice\n\n**Q12.1** Write a function similar to canDonateTo that takes two patients as arguments rather than two BloodTypes.\n\n```haskell\n-- blood type\ndata RhType = Pos | Neg\ndata ABOType = A | B | AB | O\n\ndata BloodType = BloodType ABOType RhType\n\n-- patient\ntype FirstName = String\ntype LastName = String\ntype Age = Int \n\ndata Sex = Male | Female\n\ntype MiddleName = String\n\ndata Name = Name FirstName LastName\n          | NameWithMiddle FirstName MiddleName LastName\n\ndata Patient = Patient {\n    name :: Name,\n    sex :: Sex,\n    age :: Age,\n    height :: Int,\n    weight :: Int,\n    bloodType :: BloodType\n}\n\n-- can donate to function\ncanDonateTo :: BloodType -> BloodType -> Bool\ncanDonateTo (BloodType O _) _ = True\ncanDonateTo _ (BloodType AB _) = True \ncanDonateTo (BloodType A _) (BloodType A _) = True\ncanDonateTo (BloodType B _) (BloodType B _) = True\ncanDonateTo _ _ = False\n```\n\n*Answer.*\n\n```haskell\ncanPatientDonateTo :: Patient -> Patient -> Bool\ncanPatientDonateTo p1 p2 = canDonateTo bloodType1 bloodType2\n    where bloodType1 = bloodType p1\n          bloodType2 = bloodType p2\n```\n\n**Q12.2** Implement a patientSummary function that uses your final Patient type. patientSummary should output a string that looks like this:\n\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\n Patient Name: Smith, John\n Sex: Male\n Age: 46\n Height: 72 in.\n Weight: 210 lbs.\n Blood Type: AB+\n\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\\*\nIf you need to, feel free to create useful helper functions.\n\n*Answer.*\n\n```haskell\nlongStars :: String\nlongStars = \"*******************\"\n\nnewLine :: String -> String\nnewLine str = str ++ \"\\n\"\n\nshowName :: Name -> String\nshowName (Name f l) = f ++ \" \" ++ l \nshowName (NameWithMiddle f m l) = f ++ \" \" ++ m ++ \" \" ++ l\n\nshowSex :: Sex -> String\nshowSex Male = \"Male\"\nshowSex Female = \"Female\"\n\nshowRh :: RhType -> String\nshowRh Pos = \"+\"\nshowRh Neg = \"-\"\n\nshowABO :: ABOType -> String\nshowABO A = \"A\"\nshowABO B = \"B\"\nshowABO AB = \"AB\"\nshowABO O = \"O\"\n\nshowBloodType :: BloodType -> String\nshowBloodType (BloodType abo rh) = showABO abo ++ showRh rh \n\npatientSummary :: Patient -> String\npatientSummary p = newLine longStars ++\n                   newLine (\"Patient Name: \" ++ showName(name p)) ++\n                   newLine (\"Sex: \" ++ showSex(sex p)) ++\n                   newLine (\"Age: \" ++ show (age p)) ++\n                   newLine (\"Height: \" ++ show (height p)) ++\n                   newLine (\"Weight: \" ++ show (weight p)) ++\n                   newLine (\"Blood Type: \" ++ showBloodType(bloodType p)) ++\n                   newLine longStars\n```\n\n"
    },

    {
        "id": "a145af21-e2f0-40be-b233-6559d13cb05d",
        "title": "Lesson 11 - Type basics",
        "category": "Haskell",
        "date": { "year": 2021, "month": 7, "day": 13 },
        "peek": "The book, “it automatically determines the types of all variables at compile-time based on the way they’re used.”",
        "content": "> Created on 2021/07/13\n\n## Type inferences\n\nThe book, *\"it automatically determines the types of all variables at compile-time based on the way they're used.\"*\n\n> Even we do NOT write the types explicitly, the compiler is able to infer the types.\n\n## `Int` vs `Integer`\n\nThe greatest difference is that `Int` is just like its position in other programming languages, which has a lower bound and an upper bound. However, `Integer` is more mathematical. It is just like the term in math.\n\n```haskell\nanotherNumber :: Int\nabotherNumber = read \"6\"\n```\n\n## Function types\n\nThe last one is the return type, the others are argument types.\n\n```haskell\nhalf :: Int -> Double\n-- half n = n/2  -- This gives error\nhalf n = (fromIntegral n) / 2\n```\n\n> `half n = n/2` gives error because `n/2` gives an `Int` type.\n\n### Function with multiple arguments\n\n```haskell\nmakeAddress :: Int -> String -> String -> (Int, String, String)\nmakeAddress number street town = (number, street, town)\n```\n\n### Function with first-class function\n\n```haskell\nifEven :: (Int -> Int) -> Int -> Int \nifEven f n = if even n \n             then f n \n             else n\n```\n\n### Function with unknown types\n\n```haskell\nsimple :: a -> a \nsimple n = n\n```\n\n```haskell\nmakeTriple :: a -> b -> c -> (a, b, c)\nmakeTriple a b c = (a, b, c)\n```\n\n> Same type variable means the same type"
    },

    {
        "id": "fa503d99-81c2-4390-9e3e-6a873784a2c5",
        "title": "Lesson 10 - Capstone: Functional object-oriented programming with robots!",
        "category": "Haskell",
        "date": { "year": 2021, "month": 7, "day": 8 },
        "peek": "Capstone: Functional object-oriented programming with robots!",
        "content": "> Created on 2021/7/8\n\n## Cup!\n\n```haskell\n-- constructor of a basic cup object\ncup flOz = \\message -> message flOz\n\n-- accessor\ngetOz aCup = aCup (\\flOz -> flOz)\n\n-- modifier\ndrink aCup ozDrank = if ozDiff >= 0\n                     then cup ozDiff\n                     else cup 0\n    where flOz = getOz aCup\n          ozDiff = flOz - ozDrank\n\n-- check if empty\nisEmpty aCup = getOz aCup == 0\n```\n\n## Fighting robots\n\n```haskell\n-- constructor\nrobot (name, attack, hp) = \\method -> method (name, attack, hp)\n\n-- helper functions for accessors\nname (n, _, _) = n\nattack (_, a, _) = a\nhp (_, _, hp) = hp\n\n-- accessors\ngetName aRobot = aRobot name\ngetAttack aRobot = aRobot attack\ngetHp aRobot = aRobot hp\n\n-- setter\nsetName aRobot newName = aRobot (\\(n, a, h) -> robot (newName, a, h))\nsetAttack aRobot newAttack = aRobot (\\(n, a, h) -> robot (n, newAttack, h))\nsetHp aRobot newHp = aRobot (\\(n, a, h) -> robot (n, a, newHp))\n\n-- toString\nprintRobot aRobot = aRobot (\\(n, a, h) -> n ++\n                                          \" attack: \" ++ (show a) ++\n                                          \" hp: \" ++ (show h))\n\n-- damage\ndamage aRobot attackDamage = aRobot (\\(n,a,h) -> \n                                      robot (n, a, h - attackDamage))\n\n-- fight\nfight aRobot defender = damage defender attack\n    where attack = if getHp aRobot > 10\n                   then getAttack aRobot\n                   else 0\n```\n\n"
    },

    {
        "id": "9e8ab3f8-f615-4eb1-9165-33b6574a1ccb",
        "title": "Lesson 9 - Higher-order functions",
        "category": "Haskell",
        "date": { "year": 2021, "month": 7, "day": 7 },
        "peek": "The book, “A higher-order function is technically any function that takes another function as an argument.”",
        "content": "> Created on 2021/07/07\n\nThe book, \"*A higher-order function is technically any function that takes another function as an argument*.\"\n\nIn this lesson, we'll look at three common higher-order functions, `map`, `filter`, `foldl`, and how to write our own implementation of these.\n\n## `map` function\n\n### Usage\n\n```bash\nGHCi> map reverse [\"dog\", \"cat\", \"moose\"]\n[\"god\",\"tac\",\"esoom\"]\nGHCi> map head [\"dog\", \"cat\", \"moose\"]\n\"dcm\"\n```\n\n### Implementation\n\n```haskell\nmyMap _ [] = []\nmyMap f (x:xs) = (f x) : myMap xs\n```\n\n## `filter` function\n\n### Usage\n\n```bash\nGHCi> filter even [1,2,3,4]\n[2,4]\nGHCi> filter (\\(x:xs) -> x == 'a') [\"apple\", \"banana\", \"avocado\"]\n[\"apple\", \"avocado\"]\n```\n\n### Implementation\n\n```haskell\nmyFilter _ [] = []\nmyFilter f (x:xs) = if f xf x\n                    then x : myFilter f xs\n                    else myFilter f xs\n```\n\n## `foldl` function\n\n### Usage\n\n```bash\nGHCi> foldl (+) 0 [1,2,3,4]\n10\n```\n\n### Implementation\n\n```haskell\nmyFoldl _ n [] = n \nmyFoldl f n (x:xs) = myFoldl f (f n x) xs\n```\n\n ### `foldr`\n\n#### Implementation\n\n```haskell\nmyFoldr _ n [] = n \nmyFoldr f n (x:xs) = f x (myFoldr f n xs)\n```\n\n## Practice\n\n**Q 9.1** Use `filter` and `length` to re-create the elem function.\n\n*Answer*.\n\n```haskell\nmyElem x list = length (filterResult) /= 0\n    where filterResult = filter (== x) list\n```\n\n**Q 9.2** Your `isPalindrome` function from lesson 6 doesn’t handle sentences with spaces or capitals. Use `map` and `filter` to make sure the phrase *“A man a plan a canal Panama”* is recognized as a palindrome.\n\n```haskell\nisPalindrome text = processedText == reverse processedText\n    where npSpaces = filter (/= ' ') text \n          processedText = map toLower npSpaces\n```\n\n**Q 9.3** In mathematics, the harmonic series is the sum of 1/1 + 1/2 + 1/3 + 1/4 .... Write a function *harmonic* that takes an argument n and calculates the sum of the series to n. Make sure to use lazy evaluation.\n\n```haskell\nharmonic n = sum (take n series)\n    where values = zip (cycle [1.0]) [1.0, 2.0 ..]\n          series = map (\\p -> (fst p) / (snd p)) values\n```\n\n"
    },

    {
        "id": "ededd510-96a4-4f8a-8e78-6a0746f5408d",
        "title": "Lesson 8 - Writing recursive functions",
        "category": "Haskell",
        "date": { "year": 2021, "month": 7, "day": 6 },
        "peek": "In this lesson, we'll write some recursive functions.",
        "content": "> Created on 2021/07/06\n\nIn this lesson, we'll write some recursive functions.\n\n## Recursion on lists\n\n### `length`\n\n```haskell\nmyLength [] = 0\nmyLength (x:xs) = 1 + myLength xs\n-- myLength xs = 1 + length(tail xs)\n```\n\n### `take`\n\n```haskell\nmyTake _ [] = []\nmyTake 0 _ = []\nmyTake n (x:xs) = x : rest\n    where rest = myTake (n - 1) xs\n```\n\n### `cycle`\n\n```haskell\nmyCycle xs = xs ++ (myCycle xs)\n```\n\n\n\n## Pathological recursion\n\nThere are two interesting functions: *the Ackermann function* and *The Collatz conjecture*.\n\n### The Ackermann function\n\nThe Ackermann function follows these three rules:\n\n- If m = 0, return n + 1.\n\n- If n = 0, then A(m – 1, 1).\n- If both m != 0 and n != 0, then A(m –1, A(m, n – 1)).\n\n```haskell\nackermann 0 n = n + 1\nackermann m 0 = ackermann (m - 1) 1\nackermann m n = ackermann (m - 1) (ackermann m (n - 1))\n```\n\n### The Collatz conjecture\n\nThe Collatz conjecture involves defining a recursive process given a starting number *n*:\n\n- If n is 1, you’re finished.\n- If n is even, repeat with n/2.\n- If n is odd, repeat with n × 3 + 1.\n\n```haskell\ncollatz 1 = 1\ncollatz n = if even n\n            then 1 + collatz (n `div` 2)\n            else 1 + collatz (3 * n + 1)\n```\n\n\n\n## Practice\n\n**Q8.1**\n\nImplement your own version of `reverse`, which reverses a list.\n\n*Answer*.\n\n```haskell\nmyReverse [] = []\nmyReverse (x:xs) = (myReverse xs) ++ [x]\n```\n\n**Q8.2** \n\nCalculating Fibonacci numbers is perhaps the single most common example of a\n\nrecursive function. The most straightforward definition is as follows:\n\n```haskell\nfib 0 = 0\nfib 1 = 1\nfib n = fib (n-1) + fib (n-2)\n```\n\nLike the Ackermann function, this implementation quickly explodes due to the mutually recursive calls. But unlike the Ackermann function, there’s a much more efficient way to compute the *n*th Fibonacci number. Write a function, `fastFib`, that can compute the 1,000th Fibonacci number nearly instantly. Hint: `fastFib` takes three arguments: `n1`, `n2`, and `counter`. To calculate the 1,000th Fibonacci number, you call `fastFib 1 1 1000` and for the 5th, you call `fastFib 1 1 5`.\n\n*Answer*.\n\n```haskell\nfastFib n = fastFibHelper n 0 1\n\nfastFibHelper 0 _ _ = 0\nfastFibHelper 1 _ b = b\nfastFibHelper n a b = fastFibHelper (n - 1) a' b'\n    where a' = b\n          b' = a + b\n```"
    },

    {
        "id": "56d97d0b-93ef-4745-a9b1-b6d5c35bf673",
        "title": "Lesson 7 - Rules for recursion and pattern matching",
        "category": "Haskell",
        "date": { "year": 2021, "month": 7, "day": 5 },
        "peek": "Think. How to write a take function?",
        "content": "> Created on 2021/07/05\n\n**Think**. How to write a `take` function?\n\n## Recursion\n\nThe book, *\"In general, something is recursive if it's defined in terms of itself.\"*\n\n### Rules for recursion\n\nThe book,\n\n- Identify the end goal(s)\n- Determine what happens when a goal is reached\n- List all alternate possibilities\n- Determine your \"rinse and repeat\" process\n- Ensure that each alterative moves you toward your goal\n\n> As a software engineer student, this is easy for me. 😎\n\n### Greatest common divisor\n\n[*Euclid's algorithm*](https://en.wikipedia.org/wiki/Euclidean_algorithm) solves this problem.\n\n1. You start with two numbers, a and b.\n2. If you divide a by b and the remainder is 0, clearly b is the GCD.\n3. Otherwise, you change the value of a by assigning it the value of b (b becomes the new a). You also change the value of b to be the remainder you obtained in step 2 (the new b is the remainder of the original a divided by the original b).\n4. Then repeat until a/b has no remainder.\n\n#### Example\n\n| iteration | a    | b    | remainder |\n| --------- | ---- | ---- | --------- |\n|           | 20   | 16   | 4         |\n| 1         | 16   | 4    | 0         |\n\nThus the gcd is 4.\n\n#### Haskell code\n\n```haskell\nmyGCD a b = if remainder == 0\n            then b\n            else myGCD b remainder\n    where remainder = a `mod` b\n```\n\n## Pattern matching\n\n**Example**\n\n```haskell\nsayAmount n = case n of\n    1 -> \"one\"\n    2 -> \"two\"\n    n -> \"a bunch\"\n```\n\nIn pattern matching format,\n\n```haskell\nsayAmount 1 = \"one\"\nsayAmount 2 = \"two\"\nsayAmount n = \"a bunch\"\n```\n\n**Check whether a list is empty**\n\n```haskell\nisEmpty [] = True\nisEmpty _ = False\n```\n\n> The book, *\"In Haskell, it’s standard practice to use _ as a wildcard for values you don’t use. \"*\n\n### Pattern matching on lists\n\n#### Get head\n\n```haskell\nmyHead (x:xs) = x\n```\n\n**What to do if the input is an empty list?**\n\n*Answer*. Use `error` function to throw an exception.\n\n```haskell\nmyHead (x:xs) = x\nmyHead [] = error \"No head for empty list\"\n```\n\n## Practice\n\n**Q7.2** Rewrite `myGCD` by using pattern matching.\n\n*Answer*.\n\n```haskell\n-- actually have no idea.\n-- possible answer from \"https://lettier.github.io/posts/2016-04-22-fibonacci-lcm-and-gcd-in-haskell.html\"\ngcd' x 0 = abs x\ngcd' x y = gcd' b (mod a b)\n  where a = abs x\n        b = abs y\n```\n\n*Answer from the book*\n\n```haskell\nmyGCD a 0 = a\nmyGCD a b = myGCD b (a 'mod' b)\n```\n\n"
    },

    {
        "id": "a05f45c8-8f24-4abb-99ea-b2e84570bef1",
        "title": "Lesson 6 - Lists",
        "category": "Haskell",
        "date": { "year": 2021, "month": 7, "day": 3 },
        "peek": "Lists in Haskell are inherently recursive.",
        "content": "> Created on 2021/07/03\n\n## The anatomy of a list\n\nLists in Haskell are inherently recursive. \n\n> *recursive*. A list can be an empty list or an element followed by another list.\n\nIt is composed of three parts, *head*,  *tail*, and *end*.\n\n> *end*. It is represented by '[]'.\n\n### Head\n\nThe *head* of a list is the first element of the list.\n\n```bash\nGHCi> head [1, 2, 3]\n1\nGHCi> head [[1, 2], [3, 4]]\n[1, 2]\n```\n\n### Tail\n\nThe *tail* is the rest of the list leftover, after the head.\n\n```bash\nGHCi> tail [1, 2, 3]\n[2, 3]\n```\n\n### Empty list\n\nAn empty list is different from a regular list, it has no *head* or *tail*. Thus calling `head` and `tail` on an empty list will cause an error.\n\n### `:` operator\n\nAKA, the *infix* operator. It is also called *cons*, short for *construct*.\n\nThus, a list is like the following,\n$$\ne_1:e_2: \\cdots :e_n:\\epsilon\n$$\nwhere $\\epsilon$ is the *end*.\n\n>  $\\epsilon$ alone is a valid list. (The base case.)\n\n### `[...]` notation\n\nThis is *syntactic sugar*.\n\n> *syntactic sugar*. a feature of the programming language syntax designed solely to make things easier to read.\n\n### Strings are lists\n\nStrings are essentially lists\n\n```bash\nGHCi> ['h', 'e', 'l', 'l', 'o']\n\"hello\"\nGHCi> 'h':'e':'l':'l':'o':[]\n\"hello\"\n```\n\n### `++` operator\n\nUsed to combine two lists.\n\n```bash\nGHCi> \"h\" ++ \"ello\"\n\"hello\"\n```\n\n## Lists and lazy evaluation\n\n### Quickly Generate Lists\n\nHere are some not very interesting examples.\n\n```bash\nGHCi> [1 .. 10]\n[1,2,3,4,5,6,7,8,9,10]\nGHCi> [1, 3 .. 10]\n[1,3,5,7,9]\nGHCi> [1, 1.5, .. 5]\n[1.0,1.5,2.0,2.5,3.0,3.5,4.0,4.5,5.0]\nGHCi> [1, 0 .. -10]\n[1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10]\n```\n\n### Without Bounds?\n\n```bash\nGHCi> [1 .. ]\n[1,2,3,4 ..\n```\n\nThis will generate an infinitely long list. However, it can be assigned to a variable and use it in a function.\n\n```haskell\n-- Simple function\nsimple x = x\n\n-- long list\nlongList = [1 .. ]\n\n-- pass the long list to a function\nstillLongList = simple longList\n```\n\nIt works fine without making *GHCi* stuck by evaluating an infinitely long list. But how? The answer is *lazy evaluation*.\n\nThe book, *\"No code is evaluated until it is needed.\"*\n\n> *Quick check 6.1*\n>\n> *True or false*. You can compile and run a program with the variable <code>backwardInfinity = reverse [1 .. ]</code>.\n>\n> *Answer*\n>\n> *True*. Even though you're reversing an infinite list, you're never calling the code, so the infinite list is never evaluated. If you loaded this code into GHCi and typed the following\n>\n> ```bash\n> GHCi> backwardInfinity\n> ```\n>\n> you'd have a problem, as the program would need to evaluate this argument to print it out.\n\n## Common functions on lists\n\n### `!!` operator\n\nTo access an element of a list by its index.\n\n```bash\nGHCi> \"dog\" !! 2\n'g'\n```\n\n### `length`\n\nAs its name implies.\n\n### `reverse`\n\nAs its name implies.\n\n### `elem`\n\nIt takes a value and list and checks whether the value is in the list.\n\n```bash\nGHCi> elem 23 [1 .. 30]\nTrue\n```\n\n> *infix and prefix*\n>\n> For binary functions, there are two ways of writing them. For example, the `elem` function can be written as the following.\n>\n> ```bash\n> GHCi> elem 1 [1 .. 10]\n> True\n> GHCi> 1 `elem` [1 .. 10]\n> True\n> ```\n\n### `take` and `drop`\n\n#### `take`\n\nIt takes a number $n$ and a list and then returns the first $n$ elements of the list.\n\n```bash\nGHCi> take 5 [1..10]\n[1,2,3,4,5]\n```\n\n#### `drop`\n\nIt takes a number $n$ and a list and then it removes the first $n$ elements of the list.\n\n```bash\nGHCi> drop 4 [1..10]\n[5,6,7,8,9,10]\n```\n\n### `zip`\n\nIt combines two lists into tuple pairs. If one of the two lists is longer, `zip` will stop whenever one of the two lists is empty.\n\n```bash\nGHCi> zip [1..5] [1..10]\n[(1,1),(2,2),(3,3),(4,4),(5,5)]\n```\n\n### `cycle`\n\nGiven a list, `cycle` repeats that list endlessly.\n\n```haskell\nones n = take n (cycle [1])\n```\n\n```bash\nGHCi> ones 5\n[1,1,1,1,1]\n```\n\n## Practice\n\n**Q 6.1** Haskell has a function called `repeat` that takes a value and repeats it infinitely. Using the functions you've learned so far, implement your own version of `repeat`.\n\n*Answer*. \n\n```haskell\nrepeat n = cycle [n]\n```\n\n\n\n**Q 6.2** Write a function `subseq` that takes three arguments: a start position, an end position, and a list. The function should return the subsequence between the start and end. For example:\n\n```bash\nGHCi> subseq 2 5 [1..10]\n[3,4,5]\nGHCi> subseq 2 7 \"a puppy\"\n\"puppy\"\n```\n\n*Answer*.\n\n```haskell\nsubseq s e list= take (e - s) (drop s list)\n```\n\n\n\n**Q 6.3** Write a function `inFirstHalf` that returns `True` if an element is in the first half of a list, and otherwise returns `False`.\n\n*Answer.*\n\n```haskell\ninFirstHalf e list = elem e (take ((length list) `div` 2) list)\n```\n\n```haskell\ninFirstHalf e list = elem e firstHalf\n                     where halfLength = (length list) `div` 2\n                           firstHalf = take halfLength list\n```\n\n```haskell\ninFirstHalf e list = let halfLength = (length list) `div` 2\n                         firstHalf = take halfLength list\n                     in elem e firstHalf\n```\n\n"
    },

    {
        "id": "fec01e78-81ea-4c1a-b665-ab2fb923c086",
        "title": "Lesson 5 - Closures and Partial Application",
        "category": "Haskell",
        "date": { "year": 2021, "month": 7, "day": 3 },
        "peek": "Closures and Partial Application",
        "content": "> Created on 2021/07/03\n\n## Brief\n\nLesson 5 introduced two key concepts in functional programming. As shown in the title, they are *closure* and *partial application*.\n\n## Closures\n\nThe book, *\"When you capture a value inside a lambda function, this is referred to as a closure.\"*\n\nHere is the `ifEven` example as a closure:\n\n**Firstly** we have `ifEven`\n\n```haskell\nifEven myFunction n = if even n\n                      then myFunction n\n                      else n\n```\n\nHere's how we'll write `ifEvenXXX` the original way:\n\n```haskell\ninc n = n + 1\ndouble n = 2 * n \nsquare n = n^2\n\nifEvenInc n = ifEven inc n \nifEvenDouble n = ifEven double n \nifEvenSquare n = ifEven square n\n```\n\nLet's re-write them in *closure*!\n\n```haskell\ngenIfEven f = (\\x -> ifEven f x)\n\nifEvenInc = genIfEven (\\x -> x + 1)\nifEvenDouble = genIfEven (\\x -> 2 * x)\nifEvenSquare = genIfEven (\\x -> x^2)\n```\n\n> From my observation: one benefit is that the argument n is eliminated.\n\n### Request Url Builder Example\n\nWe have the following function for building request URL:\n\n```haskell\n-- bad way: enter so much stuff, error-prone\ngetRequestURL host apiKey resource id = host ++\n                                        \"/\" ++\n                                        resource ++\n                                        \"/\" ++\n                                        id ++\n                                        \"?token=\" ++\n                                        apiKey\n```\n\nIn *GHCi*,\n\n```bash\nGHCi> getRequestURL \"http://example.com\" \"1337hAsk3ll\" \"book\" \"1234\"\n```\n\nWriting a host each time when the function is called is troublesome. Let's write it as a closure,\n\n```haskell\ngetRequestBuilder host = (\\apiKey resource id ->\n                          getRequestURL host apiKey resource id)\n```\n\nIn *GHCi*,\n\n```bash\nGHCi> urlEntered = getRequestBuilder \"http://www.example.com\"\nGHCi> urlEntered \"asdasdasddsd\" \"car\" \"12\"\n\"http://www.example.com/car/12?token=asdasdasddsd\"\n```\n\nEntering API key is also troublesome!\n\n```haskell\ngenApiRequestBuilder hostBuilder apiKey = (\\resource id -> \n                                            hostBuilder apiKey resource id)\n```\n\nIn *GHCi*,\n\n```bash\nGHCi> urlBuilder = getRequestBuilder \"http://www.example.com\"\nGHCi> myBuilder = genApiRequestBuilder urlBuilder \"asd123sadasd\"\nGHCi> myBuilder \"asdasd\" \"adsasd\"\n\"http://www.example.com/asdasd/adsasd?token=asd123sadasd\"\n```\n\nMuch better!\n\n## Partial Application\n\nTake a look at this function\n\n```haskell\nadd4 a b c d = a + b + c + d\n\naddXto3 x = (\\b c d -> \n              add4 x b c d)\n\naddXYto2 x y = (\\c d ->\n                 add4 x y c d)\n```\n\nEven with *closure*, the lambda function brings bad reability.\n\nIntroducing *partial application*:\n\n```haskell\nmystery = add4 3\n```\n\n> This is a language feature!\n\nThe book, *Partial Function*, *\"When you call any function with fewer than the required number of parameters in Haskell, you get a new function that's waiting for the remaining parameters.\"*\n\nLet's re-write the URL builder example.\n\n```haskell\nexampleUrlBuilder = getRequestURL \"http://www.example.com\"\nmyExampleUrlBuilder = exampleUrlBuilder \"asasddasd32\"\n```\n\n> Thus argument should be **ordered from most to least general**.\n\n### Flip Trick\n\nSometimes the order of the arguments can not be changed. For example, when call functions from some library, the order of arguments is fixed. However, with the *flip trick*, we can make a difference.\n\nAssume we have the *foo* function, which takes two arguments, *x* and *y*\n\n```haskell\nfoo x y -- here's how we call this function\n```\n\nUse *flip trick* to change the order of arguments:\n\n```haskell\nflipBinaryArgs binaryFunction = (\\x y -> binaryFunction y x)\n```\n\n> `flip` is an existing function in Haskell that behaves exactly the same as above.\n\n## Practice\n\nWe have the following function\n\n```haskell\nifEven myFunction n = if even n\n                      then myFunction n\n                      else n\n```\n\nHere is how we write `ifEvenInc`, `ifEvenDouble`, `ifEvenSquare`,\n\n```haskell\ngenIfEven f = (\\x -> ifEven f x)\n\nifEvenDouble = genIfEven (\\x -> 2 * x)\nifEvenInc = genIfEven (\\x -> x + 1)\nifEvenSquare = genIfEven (\\x -> x^2)\n```\n\n**Question**: Re-write `ifEvenInc`, `ifEvenDouble`, `ifEvenSquare` using `ifEven` and *partial application*.\n\n> *Answer*\n>\n> ```haskell\n> ifEvenInc = ifEven (\\n -> n + 1)\n> ifEvenDouble = ifEven (\\n -> 2 * n)\n> ifEvenSquare = ifEven (\\n -> n^2)\n> ```\n\n"
    },

    {
        "id": "297958c8-6ed0-4cbb-924e-63d0168c7f94",
        "title": "npm 安装时 \"cb() never called!\"",
        "category": null,
        "date": { "year": 2021, "month": 7, "day": 2 },
        "peek": "npm 安装时 \"cb() never called!",
        "content": "> 创建于 2021/07/02\n\n👉 [原文链接](https://www.huaweicloud.com/articles/4f006786cb02a9877e358d33f0dd0adf.html)\n\n依次输入以下命令:\n```bash\n$ npm cache clean -f\n$ npm install -g n\n$ npm install -g n --force\n```\n然后该安装啥就安装啥."
    },

    {
        "id": "13c53c18-9ef0-4710-8e7f-71dc7b29c9ca",
        "title": "Lesson 4 - First-class Functions",
        "category": "Haskell",
        "date": { "year": 2021, "month": 6, "day": 30 },
        "peek": "The functions can be passed around like other values. They can be both arguments and return values.",
        "content": "> Created on 2021/06/30\n\n## First-class functions\n\nThe functions can be passed around like other values. They can be both arguments and return values.\n\n## Functions as Argument\n\n### `ifEven` Example\n\nConsider the following functions\n\n```haskell\nifEvenInc n = if even n \n              then n + 1\n              else n\n\nisEvenDouble n = if even n \n                 then n * 2\n                 else n\n\nisEvenSquare n = if even n \n                 then n^2\n                 else n\n```\n\nBy observation, it is easily noticed that these three functions are almost identical. Actually, we can do this\n\n```haskell\nifEven myFunction n = if even \n                      then myFunction n\n                      else n\n```\n\nThen the previous three functions can be rewritten as this\n\n```haskell\ninc n = n + 1\ndouble n = n * 2\nsquare n = n^2\n\nifEvenInc n = ifEven inc n\nifEvenDouble n = ifEven double n\nifEvenSquare n = ifEven square n\n```\n\n> *Precedence*\n>\n> Functions over operators\n\n### `Custom Sorting` Example\n\n```haskell\n-- import Haskell's sorting related module\nimport Data.List\n\n-- some names\nnames = [(\"Ian\", \"Curtis\"), \n         (\"Bernard\", \"Sumner\"), \n         (\"Peter\", \"Hook\"), \n         (\"Stephen\", \"Morris\")]\n         \n-- default sorting\nsort names\n\n-- define custom compare two elements\ncompareLastNames name1 name2 = if lastname1 > lastname2\n                               then GT\n                               else if lastname1 < lastname2\n                                    then LT \n                                    else EQ\n    where lastname1 = snd name1\n          lastname2 = snd name2 \n          \n-- invoke sortBy\nsortBy compareLastNames names\n```\n\n## Returning Functions\n\n> *`++` operator*\n>\n> Concatenate strings and lists.\n\n### Why?\n\nThe book, *\"One good reason is that you want to dispatch certain functions based on other parameters.\"*\n\n### Example\n\nThe initial requirement is that, given a name and an address, concatenate them together.\n\n```haskell\naddressLetter name location = nametext ++ \" - \" ++ location\n    where nametext = (fst name) ++ \" \" ++ (snd name)\n```\n\nAs time goes by, a new requirement merged: different offices want their own combination format. \n\n- `sf` office wants to do something with the last name.\n- `ny` office wants '`:`' instead of '`-`'\n- `reno` office only needs the last name.\n\nThen we would have three function for each office:\n\n```haskell\n-- for sf office\nsfOffice name = if lastName < \"L\"\n                then nameText ++ \" - 972 Main St W\"\n                else nameText ++ \" - 1686 Main St W\"\n    where lastName = snd name \n          nameText = (fst name) ++ \" \" ++ (snd name)\n\n-- for ny office\nnyOffice name = nameText ++ \": 972 Main St W\"\n    where nameText = (fst name) ++ \" \" ++ (snd name)\n\n-- for reno office\nrenoOffice name = lastName ++ \" - 1686 Main St W\"\n    where lastName = snd name \n```\n\nThen, edit `addressLetter` function\n\n```haskell\n-- dispatch function based on office instance\n-- !! This function returns a function !!\ngetLocationFunction location = case location of \n    \"ny\"   -> nyOffice\n    \"sf\"   -> sfOffice\n    \"reno\" -> renoOffice\n    _      -> (\\name -> (fst name) ++ \" \" ++ (snd name))\n\n-- new addressLetter function\naddressLetter name location = locationFunction name \n    where locationFunction = getLocationFunction location\n```\n\n"
    },

    {
        "id": "aea6849d-4809-4c58-9472-630669a7e6f6",
        "title": "Lesson 3 - Lambda Functions and Lexical Scope",
        "category": "Haskell",
        "date": { "year": 2021, "month": 6, "day": 30 },
        "peek": "Lambda Functions and Lexical Scope",
        "content": "> Created on 2021/06/30\n\n# Lambda Function\n\n### What is \"lambda function\"?\n\nLambda function is simply a function without a name. AKA, *anonymous function*. Here is a simple example, this function takes $x$ and returns $x$.\n\n### Simple Example\n\n```haskell\n\\x -> x\n```\n\nThis is equivalent to \n\n```haskell\nsimple x = x\n```\n\n## Some Haskell Code\n\n### sum of squares for the square of sums\n\nThe function takes two arguments, $x$ and $y$, you can figure out what the function does ... \n\n```haskell\nsumSquareOrSquareSum x y = if sumSquare > squareSum\n                           then sumSquare\n                           else squareSum\n    where sumSquare = x ^ 2 + y ^ 2\n          squareSum = (x + y) ^ 2\n```\n\nCompare with the bad implementation\n\n```haskell\nsumSquareOrSquareSum x y = if (x^2 + y^2) > ((x + y)^2) \n                           then (x^2 + y^2)\n                           else (x + y)^2\n```\n\n> 👆 (A quick review of lesson 2)\n\n**Lambda version**\n\n```haskell\nsumSquareOrSquareSum x y = (\\sumSquare squareSum -> \n                              if sumSquare > squareSum\n                              then sumSquare\n                              else squareSum) (x^2 + y^2) ((x + y)^2)\n```\n\n**`let .. in ..` version**\n\n ```haskell\nsumSquareOrSquareSum x y = let sumSquare = (x ^ 2 + y ^ 2)\n                               squareSum = (x + y) ^ 2\n                           in \n                            if sumSquare > squareSum\n                            then sumSquare\n                            else squareSum\n ```\n\n### overwrite\n\nConsider the following function\n\n```haskell\noverwrite x = let x = 2\n              in\n               let x = 3\n               in\n                let x = 4\n                in \n                 x\n```\n\n**Q - 1** What is the value of $x$ after the function call?\n\n>  $x$ is 4\n\n**Q - 2** Write the above function in $\\lambda$ format\n\n```haskell\noverwrite x = (\\x -> \n                (\\x -> \n                  (\\x -> x) 4\n                ) 3\n              ) 2\n```\n\n## Lexical Scope\n\nThe book, \"*Whenever you create a new function, named or not, you create a new scope, which is the context in which a variable is defined. When a variable is used, the program looks at the nearest scope; if the definition of the variable isn’t there, it goes to the next one up.*\" \n\nIn summary,\n\n- The creation of a function creates a new scope\n- When a variable is used, the program looks at the nearest scope\n  - If the definition is NOT there, goes to the next one up\n\n## Practice\n\n**Q3.2** Using a let expression and a lambda function aren’t exactly the same thing under\n\nthe hood. For example, the following code will cause an error if you try to run it:\n\n```haskell\n counter x = let x = x + 1\n             in\n              let x = x + 1 \n              in \n               x\n```\n\nTo prove that let and lambda aren’t identical, rewrite the counter function exactly as it is here, but use nested lambdas instead of let.\n\n**My Answer**\n\n```haskell\ncounter x = (\\x -> x + 1) ((\\x -> x + 1) x)\n```\n\n\n"
    },

    {
        "id": "d29c0fb9-cb7f-4e28-b512-847c5e0baa15",
        "title": "Lesson 2 - Functions and Functional Programming",
        "category": "Haskell",
        "date": { "year": 2021, "month": 6, "day": 29 },
        "peek": "Functions and Functional Programming",
        "content": "> Created on 2021/06/29\n> \n> Updated on 2021/06/30\n\n## Function Programming\n\n### What I already know\n\n#### 1. Immutability\n\nIn functional programming, everything is immutable. Which means the following can NOT be performed in the world of functional programming:\n\n```?\nc = 1;\nc = 2;\n```\n\nOnce `c` is assigned with value `1`. It is `1` forever. This feature gives it a great advantage in concurrent programming. Since everything is immutable, it's always thread-safe.\n\n#### 2. Given a function and certain argument, the output is constant\n\nIf we have a function $f$, which takes one argument $x$, then the output of $f(x)$ is consistent for some $x$. There is a term for this: *referential transparency*.\n\n#### 3. Functions can be argument of functions\n\nYou can even pass a function as an argument. Don't be surprised, it's common in the functional programming world.\n\n#### 4. No side-effect\n\n> *Side effect*\n>\n> In this context, \"side effect\" means the interaction between the internal function and its outside world. For example, when a function changes the value of a global variable, a side effect takes place.\n\n##### Side effect example\n\n```javascript\nn = 1;  // global\n\nfunction f(x, y) {\n\tn = x + y;  // this alters the global n\n\treturn n;\n}\n\nf(2, 3);\nprint n;  // it is 5 now\n```\n\nAlthough we just want to calculate `x + y` here, we did alter the value of `n` by accident.\n\n(Of course, the code snippet above is not functional programming.)\n\nFunctional programming would never produce a side effect like that. From my understanding, it is because of immutability and referential transparency.\n\n## Some Haskell Code\n\n*Calculate change*\n\nThe function takes two arguments, *owed* and *given*, if the change is less than 0, return 0, otherwise return the change.\n\n```haskell\ncalcChange owed given = if given - owed >0 \n\t\t\tthen given - owed\n\t\t\telse 0\n```\n\nIn the implementation above, `given - owed` is calculated twice when the change is greater than 0. We need a better implementation\n\n```haskell\ncalcChange owed given = if change > 0\n\t\t\tthen change\n\t\t\telse 0\n\t\twhere change = given - owed\n```\n\n## Practice\n\n**Q2.2** Write functions named inc, double, and square that increment, double, and square an argument n, respectively.\n\n```haskell\ninc n = n + 1\ndouble n = 2 * n\nsquare n = n * n  -- or n^2\n```\n\n**Q2.3** Write a function that takes a value n. If n is even, the function returns n - 2, and if the number is odd, the function returns 3 × n + 1. To check whether the number is even, you can use either Haskell’s even function or mod (Haskell’s modulo function).\n\n```haskell\n-- `even n` is equivalent to `mod n 2 == 0`\nfoo n = if mod n 2 == 0\n        then n - 2\n        else 3 * n + 1\n```\n\n"
    },

    {
        "id": "26b34e37-19fe-4584-a714-09bb410acbeb",
        "title": "Lesson 1 - Getting started with Haskell",
        "category": "Haskell",
        "date": { "year": 2021, "month": 6, "day": 28 },
        "peek": "Getting started with Haskell",
        "content": "> Created on 2021/06/28\n\n## Haskell Platform\n\nIt includes the following:\n\n- The Glasgow Haskell Compiler (GHC)\n- An interactive interpreter (GHCi)\n- The stack tool fot managing Haskell projects\n- A bunch of useful Haskell packages\n\n[Download](http://www.haskell.org/downloads#platform)\n\n## GHC\n\nWrite the following code in `Hello.hs`\n\n```haskell\nmain = do\n    print \"Hello!\"\n```\n\nIn terminal, run \n\n```bash\n$ ghc Hello.hs\n```\n\nThen get the executable file. Run it:\n\n```bash\n$ ./Hello\n```\n\nThe following shows up:\n\n```bash\n\"Hello\"\n```\n\n\n\n## GHCi\n\n`Hello.hs` can run in GHCi. In terminal, run\n\n```bash\n$ ghci Hello.hs\n```\n\n**OR**, get in the GHCi first by \n\n```bash\n$ ghci\n```\n\nThen load the code by\n\n```bash\nGHCi> :load Hello.hs\n```\n\n>  `:l` and `:load` are equivalent.\n\n\n\n"
    },

    {
        "id": "7ec03153-642e-4072-916c-6532cb5c434d",
        "title": "box-shadow",
        "category": "CSS",
        "date": { "year": 2021, "month": 6, "day": 26 },
        "peek": "`box-shadow` 如何使用",
        "content": "> 创建于26/06/2021\n\n## `box-shadow` 如何使用?\n\n### 语法\n```css\nbox-shadow: none|h-offset v-offset blur spread color |inset|initial|inherit;\n\n```\n\n#### 更多\n```css\n/* x偏移量 | y偏移量 | 阴影颜色 */\nbox-shadow: 60px -16px teal;\n\n/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影颜色 */\nbox-shadow: 10px 5px 5px black;\n\n/* x偏移量 | y偏移量 | 阴影模糊半径 | 阴影扩散半径 | 阴影颜色 */\nbox-shadow: 2px 2px 2px 1px rgba(0, 0, 0, 0.2);\n\n/* 插页(阴影向内) | x偏移量 | y偏移量 | 阴影颜色 */\nbox-shadow: inset 5em 1em gold;\n\n/* 任意数量的阴影，以逗号分隔 */\nbox-shadow: 3px 3px red, -1em 0 0.4em olive;\n\n/* 全局关键字 */\nbox-shadow: inherit;\nbox-shadow: initial;\nbox-shadow: unset;\n\n```\n\n### 参考链接\n- [mdn web doc, box-shadow](https://developer.mozilla.org/zh-CN/docs/Web/CSS/box-shadow)\n- [w3school, box-shadow](https://www.w3schools.com/cssref/css3_pr_box-shadow.asp)"
    },

    {
        "id": "f3f88952-2485-4cd4-a4a2-85e780798b67",
        "title": "input 标签修改 placeholder 样式",
        "category": "CSS",
        "date": { "year": 2021, "month": 6, "day": 25 },
        "peek": "如何修改 `<input/>` 标签中的 `placeholder` 属性的样式呢?",
        "content": "> 创建于 25/06/2021\n## 如何修改 `<input/>` 标签中的 `placeholder` 属性的样式呢?\n\n很简单, 只需要用到 `::placeholder`\n```css\ninput::placeholder {\n    color: red;\n    ...\n}\n```\n更详细内容请查看[这里](https://developer.mozilla.org/zh-CN/docs/Web/CSS/::placeholder)"
    },

    {
        "id": "2710d69c-ef40-48f4-bf40-f48aa612eb94",
        "title": "Elasticsearch 笔记",
        "category": null,
        "date": { "year": 2021, "month": 6, "day": 23 },
        "peek": "elasticsearch是一个分布式的, 基于Lucene的全文搜索服务器.",
        "content": "> 环境: **MacOS** Big Sur\n>\n> 创建于 14/06/2021\n>\n> 更新于 23/06/2021\n\nelasticsearch是一个分布式的, 基于Lucene的全文搜索服务器.\n\n## 核心组件\n\n| 组件          | 来源       | 重要性   | 作用               |\n| ------------- | ---------- | -------- | ------------------ |\n| elasticsearch | brew (Mac) | 非常重要 | 搜索引擎           |\n| kibana        | brew (Mac) | 非常重要 | 展示数据, 分析数据 |\n| logstash      | brew (Mac) | 非常重要 | 中央数据流引擎     |\n\n\n\n## 其他工具\n\n### Elasticsearch-head\n\n#### 作用\n\n查看集群概览\n\n#### Github 链接\n\nhttps://github.com/mobz/elasticsearch-head\n\n#### 遇到的问题\n\n**在ES配置安全后, es-head相应的配置**\n\n- 首先要确保 es 的跨域已经配置好\n\n- es 跨域再添加下面的配置\n\n  - ```yml\n    http.cors.allow-headers: Authorization,X-Requested-With,Content-Length,Content-Type  # 仅 `Authorization` 无效\n    ```\n\n- 用下面的链接打开es-head\n\n  - ```url\n    http://localhost:9100/?auth_user=elastic&auth_password=change_to_your_password\n    ```\n\n- [Github链接](https://github.com/mobz/elasticsearch-head/issues/368)\n\n\n\n### 分词器\n\n> 💡 中文建议使用**ik分词器**\n\n#### 作用\n\n将输入的关键字分成一个个子关键字\n\n- 例: \"数码宝贝暗黑战斗暴龙兽\" -> \"数码宝贝\", \"暗黑\", \"战斗暴龙兽\"\n\n#### Github 链接\n\nhttps://github.com/medcl/elasticsearch-analysis-ik\n\n##### 安装方式\n\n方式之一:\n\n- ```bash\n  https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v6.3.0/elasticsearch-analysis-ik-6.3.0.zip\n  ```\n\n更多方法请参考 Github 中的引导\n\n#### 自定义词库\n\n> ==解决的问题==: 特殊词无法被单独搜索的\n>\n> - 例: \"浙江佬\" 将会被拆分为 [\"浙江\", \"佬\"] 而不会被单独成词\n\n1. 找到 ik分词器 的配置文件\n\n   > 文件夹中会有大量的 .dic 文件和一个 .xml 文件\n\n2. 新建一个自己的 .dic 文件, 输入自己的词汇\n\n3. 在 .xml 文件中加入自己词典\n\n   ```xml\n   <entry key=\"ext_dict\">me.dic</entry>\n   ```\n\n4. 重新启动 es\n\n\n\n## Rest 命令\n\n#### 基本操作\n\n| method | url                                | 描述                 |\n| ------ | ---------------------------------- | -------------------- |\n| PUT    | ../ index / type / doc_id          | 创建文档(指定文档id) |\n| POST   | ../ index / type /                 | 创建文档(随机文档id) |\n| POST   | ../ index / type / doc_id /_update | 修改文档             |\n| DELETE | ../ index / type / doc_id          | 删除文档             |\n| GET    | ../ index / type / doc_id          | 通过文档id查询文档   |\n| POST   | ../ index / type / _search         | 查询所有数据         |\n\n\n\n\n\n## 集成 SpringBoot\n\n> **elasticsearch Java 客户端 官方文档**\n>\n> https://www.elastic.co/guide/en/elasticsearch/client/java-rest/current/java-rest-high.html\n\n#### Maven Repository *\n\n```xml\n<repositories>\n    <repository>\n        <id>es-snapshots</id>\n        <name>elasticsearch snapshot repo</name>\n        <url>https://snapshots.elastic.co/maven/</url>\n    </repository>\n</repositories>\n```\n\n#### Maven 依赖 🌞\n\n```xml\n<dependency>\n    <groupId>org.elasticsearch.client</groupId>\n    <artifactId>elasticsearch-rest-high-level-client</artifactId>\n    <version>7.13.1</version>\n</dependency>\n```\n\n#### `mathcQuery`\n\n```java\n// - source\nSearchSourceBuilder sourceBuilder = new SearchSourceBuilder();\nsourceBuilder.from((page - 1) * size);  // set from index\nsourceBuilder.size(size);  // set size\nsourceBuilder.query(QueryBuilders.matchQuery(\"field_name\", \"your_input\")  // define query here\n\t.fuzziness(Fuzziness.AUTO)\n\t.prefixLength(3)\n\t.maxExpansions(10));\nsourceBuilder.timeout(new TimeValue(30, TimeUnit.SECONDS));  // set timeout\n\n// - search according to source with certain index\nSearchRequest request = new SearchRequest(\"index_name\");\nrequest.source(sourceBuilder);\n\n// - analyze response\nSearchResponse response;\ntry {\n\tresponse = client.search(request, RequestOptions.DEFAULT);  // actual communication\n} catch (IOException e) {  //\n\t// do something when communication fails\n}\n\nList<Item> items = new ArrayList<>();\nMap<String, Object> resultMap;\nfor (SearchHit hit : response.getHits().getHits()) {\n\tresultMap = hit.getSourceAsMap();\n}\n```\n\n#### `countQuery`\n\n```java\nCountRequest countRequest = new CountRequest(\"index_name\");\ncountRequest.query(QueryBuilders.matchQuery(\"field_name\", \"your_input\"));\ntry {\n\tCountResponse countResponse = client.count(countRequest, RequestOptions.DEFAULT);\n} catch (IOException e) {\n\te.printStackTrace();\n}\n```\n\n\n\n## 连接 MySQL 数据\n\n#### 基本\n\n创建 `mysql.conf` 文件\n\n```json\ninput {\n    jdbc {\n        jdbc_connection_string => \"jdbc:mysql://localhost:3306/db_name\"\n        jdbc_user => \"username\"\n        jdbc_password => \"password\"\n        jdbc_validate_connection => true\n        jdbc_driver_library => \"./jar/mysql-connector-java-8.0.25.jar\"\n        jdbc_driver_class => \"com.mysql.cj.jdbc.Driver\"\n        statement => \"select * from `item`\"\n        schedule => \"* * * * *\"\n    }\n}\n\noutput {\n    stdout { codec => json_lines }\n}\n\noutput {\n    elasticsearch {\n        # protocol => http\n        hosts => \"localhost:9200\"\n        index => \"item\"\n        document_type => \"item\"\n        document_id => \"%{id}\"\n    }\n}\n```\n\n- 在同文件夹创建 jar 文件夹, 并将 mysql 驱动jar包放进去.\n\n- 在终端输入命令\n\n```shell\nlogstash -f simple-out.conf\n```\n\n> 官方文档中的例子\n>\n> https://www.elastic.co/blog/logstash-jdbc-input-plugin\n\n\n\n#### 多张表\n\n```json\ninput {\n    jdbc {\n        jdbc_connection_string => \"jdbc:mysql://localhost:3306/table_name\"\n        jdbc_user => \"username\"\n        jdbc_password => \"password\"\n        jdbc_validate_connection => true\n        jdbc_driver_library => \"./jar/mysql-connector-java-8.0.25.jar\"\n        jdbc_driver_class => \"com.mysql.cj.jdbc.Driver\"\n        statement => \"select * from `item`\"\n        type => \"item\"\n        schedule => \"* * * * *\"\n    }\n    jdbc {\n        jdbc_connection_string => \"jdbc:mysql://localhost:3306/thrift_hamilton\"\n        jdbc_user => \"darin\"\n        jdbc_password => \"password\"\n        jdbc_validate_connection => true\n        jdbc_driver_library => \"./jar/mysql-connector-java-8.0.25.jar\"\n        jdbc_driver_class => \"com.mysql.cj.jdbc.Driver\"\n        statement => \"select * from `car`\"\n        type => \"car\"\n        schedule => \"* * * * *\"\n    }\n}\n\noutput {\n    stdout { codec => json_lines }\n}\n\noutput {\n    if [type] == \"item\" {\n        elasticsearch {\n            # protocol => http\n            hosts => \"localhost:9200\"\n            index => \"item\"\n            document_type => \"item\"\n            document_id => \"%{id}\"\n        }\n    }\n    if [type] == \"car\" {\n        elasticsearch {\n            # protocol => http\n            hosts => \"localhost:9200\"\n            index => \"car\"\n            document_type => \"car\"\n            document_id => \"%{id}\"\n        }\n    }\n}\n```\n\n> **参考链接**: https://stackoverflow.com/questions/37613611/multiple-inputs-on-logstash-jdbc\n\n\n\n\n\n## 安全\n\n### 跨域\n\n编辑 `ES_CONFIG_DIR/elasticsearch.yml` , 添加下面的配置:\n\n```yml\nhttp.cors.enabled: true\nhttp.cors.allow-origin: \"*\"\n```\n\n\n\n### 最小安全设置\n\n> 官方链接: https://www.elastic.co/guide/en/elasticsearch/reference/7.13/security-minimal-setup.html\n\n#### 为内置账号设置密码\n\n1. 编辑 `ES_CONFIG_DIR/elasticsearch.yml` , 添加下面的配置:\n\n   ```yml\n   xpack.security.enabled: true\n   ```\n\n2. 重启 `elasticearch`, 然后打开一个终端窗口, 输入命令\n\n   ```shell\n   elasticsearch-setup-passwords interactive\n   ```\n\n\n\n#### Kibana\n\n编辑 `ES_CONFIG_DIR/elasticsearch.yml` , 添加下面的配置:\n\n```yml\nelasticsearch.username: \"kibana_system\"\nelasticsearch.password: \"password\"\n```\n\n在网页端中使用 `elastic` 这个账号登录.\n\n\n\n#### Logstash\n\n修改 output\n\n```json\noutput {\n    if [type] == \"table_name\" {\n        elasticsearch {\n            user => \"elastic\"\n            password => \"password\"\n            hosts => \"localhost:9200\"\n            index => \"index_name\"\n            document_type => \"type_name\"\n            document_id => \"%{id}\"\n        }\n    }\n}\n```\n\n\n\n#### Java端设置 `RestHighLevelClient`\n\n> 单节点参考链接: https://www.cnblogs.com/pxinhai/p/12685424.html\n\n```java\n@Configuration\npublic class ElasticSearchConfiguration {\n\n    // 配置信息写在 .yml 文件中, 用 ConstantProperties 统一加载\n    @Autowired private ConstantProperties properties;\n\n    @Bean\n    public RestHighLevelClient restHighLevelClient() {\n        CredentialsProvider credentialsProvider = new BasicCredentialsProvider();\n        credentialsProvider.setCredentials(AuthScope.ANY, new UsernamePasswordCredentials(\n                properties.getEsUsername(),\n                properties.getEsPassword()\n        ));\n        RestClientBuilder builder = RestClient.builder(\n                new HttpHost(\n                        properties.getEsHost(),\n                        properties.getEsPort(),\n                        HttpHost.DEFAULT_SCHEME_NAME)\n        );\n        builder.setHttpClientConfigCallback(\n                f -> f.setDefaultCredentialsProvider(credentialsProvider));\n        return new RestHighLevelClient(builder);\n    }\n}\n```\n\n"
    },

    {
        "id": "00e42141-6a31-44b2-8c3d-7b380e7e5457",
        "title": "Spring Cloud - Managing Comfiguration - II",
        "category": "Spring Cloud",
        "date": { "year": 2021, "month": 5, "day": 4 },
        "peek": "需要由 Config Server 管理的配置信息写在 `application.yml` 文件中",
        "content": "> 2021 年 5 月 4 日 \n>\n> 佛山\n\n## 编写配置信息\n需要由 Config Server 管理的配置信息写在 `application.yml` 文件中, 这个文件很显然就是存放在之前提到的**保存配置信息的版本控制系统**中. `application.yml` 文件我相信大家都知道怎么写, 该写什么, 所以这里就不再赘述.\n\n## 消费 Config Server\n当一个服务需要消费由 Config Server 提供的配置信息时, 需要在服务项目的 `pom.xml` 中添加下面的依赖代码:\n```xml\n<!-- config client -->\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-starter-config</artifactId>\n</dependency>\n```\n[然后在项目的 `bootstrap.yml` 中添加 Config Server 的信息:]\n\n```yml\nspring:\n  cloud:\n    config:\n      uri: http://{config server 的网址}\n```\n如果不填写上面的信息, 则默认 `localhost:8888` 为 Config Server 的地址.\n\n## !\n因为要正式学习微服务架构, 所以 \"Spring in Action Fifth Edition\" 中有关 Cloud 的部分就先写到这里. (不过说不定以后会把它补完.)\n"
    },

    {
        "id": "9e063848-15da-4bf2-9615-e295d6538a07",
        "title": "设计模式 - 备忘录模式",
        "category": "设计模式",
        "date": { "year": 2021, "month": 4, "day": 8 },
        "peek": "通途: 使软件可以实现 “回溯” 这个动作.",
        "content": "> 创建于 2021 年 4 月 8 日\n\n## 通途\n使软件可以实现 \"回溯\" 这个动作.\n\n## 类图\n![设计模式](img/articles/备忘录模式.png)\n\n**Originator (发起人)**\n负责创建一个备忘录 Memento, 用于记录它当前的内部状态.\n\n**Memento (备忘录)**\n负责存储 Originator 的内部状态. 并可以防止 Originator 以外的其他对象访问备忘录. \n\n**Caretaker (管理者)**\n负责保存好备忘录 Memento, 不能对备忘录的内容进行操作或检查.\n\n> **为什么要有 Caretaker 的存在?**\n> 这是因为需要保证备忘录内部信息的封闭性. \n\n## 客户端代码\n```java\nOriginator originator = new Originator();\noriginator.setState(\"foo\");\n\nCaretaker caretaker = new Caretaker();\ncaretaker.setState(originator.createMemento());\n\noriginator.doSomething(); // originator 的内部状态改变\n\n// 回溯\noriginator.setMemento(caretaker.getMemento());\n```\n可以观察到, 在整个过程中, originator 的内部状态一直保持封闭, 没有在客户端代码中暴露.\n\n## 缺点\n因为需要存储对象的数据, 若是数据大, 将会占用大量内存."
    },

    {
        "id": "df0ad265-a169-4b68-b55d-37f1296494ed",
        "title": "Java - 枚举类型 / 枚举类",
        "category": "Java",
        "date": { "year": 2021, "month": 3, "day": 18 },
        "peek": "枚举是什么? 一个有限的值的集合.",
        "content": "> 2021-03-18 (晴) 佛山\n\n## 枚举是什么?\n一个有限的值的集合. \n\n这么说会很抽象, 举个具体的例子: 对于一件衣服的大小, 我们可以有 S, M, L, XL 这四个值的类型. 那么 `{S, M, L, XL}` 就是一个有限的值的集合, 用于描述衣服的大小.\n\n## 实现方式 $^{[1]}$\n#### 简单实现\n很显然, 对于这样的需求, 我们可以简单地使用 0, 1, 2, 3 来分别表示 S, M, L, XL. 但是这样做很容易会出现错误: 例如一个程序员将 `5` 赋值给了衣服的大小, 但是 `5` 对于现在的 `{S, M, L, XL}` 而言是没有含义的, 也就是 `undefined`, 所以这样的简单实现是不够完善的.\n\n#### `enum` 关键字 (简单使用)\n在 `Java` 中, 我们可以使用 `enum` 关键字来实现枚举类. 就之前的例子而言, 我们可以有下面的代码:\n\n```java\nenum Size { SMALL, MEDIUM, LARGE, EXTRA_LARGE }\n```\n\n> `Size` 也接受 `null`, 表示这个 `Size` 变量没有设置任何值.\n\n## 高级用法 $^{[2]}$\n对于之前的 `Size` 枚举类, 它的本质其实是一个类. **这个类刚好有4个实例, 所以不可能构造新的对象.**\n\n#### 值的比较\n在对两个枚举类型的值进行比较时, 直接使用 `==` 即可.\n\n#### 添加构造器, 字段, 方法\n修改之前的代码:\n```java\npublic enum Size {\n    SMALL(\"S\"), MEDIUM(\"M\"), LARGE(\"L\"), EXTRA_LARGE(\"XL\");\n\n    private String abbreviation;\n\n    private Size(String abbreviation) {\n        this.abbreviation = abbreviation;\n    }\n    public String getAbbreviation() {\n        return abbreviation;\n    }\n}\n```\n> 注意事项\n> 1. 枚举的构造器总是私有的. (`public` 的构造器会报语法错误)\n\n#### 常用方法\n所有的枚举类型都是 `Enum` 类的子类, 并继承了这个类的许多方法.\n\n> `Enum` 的 `valueOf` 方法\n> `static Enum valueOf(Class enumClass, String name)` 返回给定类中制定名字的枚举常量.\n\n1. `toString()`. 这个方法会返回枚举类的常量名. 例: `Size.SMALL.toString()` 将返回字符串 `\"SMALL\"`\n2. 静态的 `values()` 方法. 会返回一个包含全部枚举值的数组. 例: `Size[] sizes = Size.values()` 将会返回 `{ Size.SMALL, Size.MEDIUM, Size.LARGE, Size.EXTRA_LARGE }`\n3. `ordinal()`. 返回枚举常量的位置, 从 0 开始.\n\n\n\n## 参考资料\n[1] *Java核心技术 卷一, 3.4.4, 枚举类型*\n\n[2] *Java核心技术 卷一, 5.6, 枚举类*"
    },

    {
        "id": "3a4b6d88-fdcd-4955-809f-ee262d7478a3",
        "title": "Mac 进入全屏时 Dock 不自动隐藏",
        "category": null,
        "date": { "year": 2021, "month": 3, "day": 3 },
        "peek": "正如标题所示, 有时候当 Mac 进入全屏模式时, Dock 不自动隐藏",
        "content": "> 编写于 2021-03-03\n\n## 问题\n正如标题所示, 有时候当 Mac 进入全屏模式时, Dock 不自动隐藏. 这对看视频造成了困扰. 就像下面这样.\n\n![fullscreen-dock-wont-hide](img/articles/fullscreen-dock-wont-hide.png)\n\n## 解决方法\n### 解决方法一\n\n打开 **系统偏好设置**, 点击 **Dock & Menu Bar**, 将 Dock 的方向改为左或右, 再改回到下. 现在再进入全屏, Dock 就能自动隐藏了.\n\n### 解决方法二\n\n在终端执行下面的命令:\n```\nkillall Dock\n```\n> 屏幕背景将会黑一下, Dock 会消失一下, 然后会自动恢复.\n\n\n## 参考链接\n[1] *https://www.cnblogs.com/yoyogis/p/13558131.html, 解决 mac全屏时不能隐藏Dock工具栏 killall Dock*\n\n[2] *https://discussions.apple.com/thread/8191574, Dock Remains Visible in Fullscreen Applications*\n\n"
    },

    {
        "id": "17db1d46-683f-4860-a41a-910d5bc77317",
        "title": "JVM - 运行时数据区域",
        "category": "Java",
        "date": { "year": 2021, "month": 3, "day": 2 },
        "peek": "如题所示",
        "content": "> 创建于 2021-03-02\n> 更新于 2021-03-08\n\n## 运行时数据区图\n> 八月十九日, 2021\n\n画了一张图帮助视觉化记忆.\n\n![JVM 运行时数据区演示图](img/articles/JVM-Runtime-Memory.jpg)\n\n> 三月二日, 2021\n\n![JVM 运行时数据区](img/articles/JVM-Runtime-Memory-2.png)\n\n## 程序计数器\n> 三月三日, 2021\n\n- 是一个较小的内存空间. \n- 可以作为当前线程所执行的字节码的行号指示器. \n- 是程序控制流的指示器, 分支, 循环, 跳转, 异常处理都依赖于这个计数器.\n- 每个线程都有一个**独立**的计数器. (线程私有)\n- 如果线程在执行一个 Java 方法, 那么这个计数器记录的是正在执行的虚拟机字节码指令的地址; 如果正在执行的是本地方法(Native), 这个计数器值应为空 `undefined`.\n- 此内存区域是唯一一个没有规定任何 `OutOfMemoryError` 情况的区域.\n\n## 虚拟机栈 VM Stack\n> 三月六日, 2021\n\n- 线程私有.\n- 生命周期于线程的相同.\n- 描述**Java方法执行的线程内存模型**\n  - 每个方法执行时, 都会同步创建一个**栈帧**\n    > **栈帧**是一种数据结构, 主要存储了以下信息:\n    >\n    >   1. 局部变量表\n    >   2. 操作数栈\n    >   3. 动态连接\n    >   4. 方法出口\n    >   ...\n- 每个方法从被调用到执行完毕的过程, 就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程.\n- 栈帧中的局部变量表包含了\n  1. Java 虚拟机的基本数据类型\n  2. 对象引用\n  3. `returnAddress` 类型\n- 上述的数据类型在局部变量表中以**局部变量槽**来表示, 除了 `long`, `double` 占用两个局部变量槽以外, 所有其他类型都只占用一个.\n- 局部变量槽的内存在编译期间完成分配. 当进入一个方法时, 对应的栈帧需要被分配多少内存是完全确定的. \n- 运行期间内不会改变局部变量表的大小.\n  > 注意: 这里的 \"大小\" 指的是**局部变量槽的数量**. 变量槽的内存大小会根据不同的虚拟机实现而变化.\n- 两类异常情况\n  1. 如果栈深度超过虚拟机所允许的深度, 将会抛出 `StackOverflowError`.\n  2. 如果虚拟机栈容量可以动态扩展, 那么当栈扩展时却没有办法申请到足够的内存, 就会抛出 `OutOfMemoryError`.\n\n## 本地方法栈\n> 三月八日, 2021 (阴) 佛山\n\n- 作用与虚拟机栈相似.\n- 区别在于本地方法栈是为**虚拟机使用到的本地方法**服务.\n- 本地方法栈也会在栈深度溢出或栈扩大失败时分别抛出 `StackOverflowError` 和 `OutOfMemoryError`.\n\n## Java 堆\n> 三月十二日, 2021 (晴) 佛山\n- 是内存中**最大**的一块\n- 线程共享\n- 虚拟机启动时创建\n- **作用**: 存放对象实例\n- \"所有的对象实例以及数组都应当在堆上分配.\"\n  > The heap is the runtime data area from which memory for all class instances and arrays is allocated\n- 是**垃圾收集器**管理的内存区域\n- 如果从分配内存的角度看, 左右线程共享的 Java 堆中可以划分出多个线程私有的分配缓冲区 (Thread Local Allocation Buffer, TLAB), 以提升对象分配时的效率\n- 如果在 Java 堆中没有内存完成实例分配, 并且堆也无法再扩展时, Java 虚拟机将会抛出 `OutOfMemoryError` 异常\n\n## 方法区\n> 三月十六日, 2021 (阴) 武汉\n- 线程共享\n- **作用**: 用于存储已被虚拟机加载的**类型信息**, **常量**, **静态变量**, **及时编译器编译后的代码缓存**等数据\n\n> **方法区**与 \"永久代\"\n> - 到了 JDK 8, 完全废除了 \"永久代\" 的概念, 改用在本地内存中实现的元空间来代替\n\n- **不需要** 连续的内存, 可以选择 固定大小 / 可扩展, 甚至可以不实现垃圾收集\n- 相对而言, 垃圾收集行为在这个区域的确是比较少出现的\n- 该区域内存回收的主要目标: 针对常量池的回收和堆类型的卸载\n- 如果方法区无法满足新的内存分配需求时, 将抛出 `OutOfMemoryError` 异常\n\n### 运行时常量池\n> 三月十六日, 2021 (阴) 武汉\n- 是**方法区**的一部分\n- Class 文件除了有类的版本, 字段, 方法, 接口等描述信息外, 还有**常量池表**, **用于**存放编译期产生的各种字面量和符号引用, 这部分将在类加载后存放到方法区的运行常量池中\n- 运行时常量池是具备**动态性**的. 常量不一定只有在编译期才能产生, 运行期间也可以将新的常量放入池中. 例如 `String` 的 `intern` 方法.\n\n### 直接内存\n> 三月十六日, 2021 (阴) 武汉\n- Direct Memory\n- 不是虚拟机运行时数据区的一部分, 也不是 *Java 虚拟机规范* 中定义的内存区域\n- 但是会被频繁地使用, 且可能导致 `OutOfMemoryError` 的出现\n\n\n\n"
    },

    {
        "id": "259b5c18-adfd-4aa8-bc69-84cf2981ace1",
        "title": "LaTeX - 箭头上的文字",
        "category": "LaTeX",
        "date": { "year": 2021, "month": 2, "day": 24 },
        "peek": "本文介绍了在 LaTeX 中的箭头上的文字",
        "content": "> 编写于 2021-02-24\n\n## 解决方法\n使用 `\\xrightarrow` 命令\n```md\na \\xrightarrow{x} b\n```\n$$\na \\xrightarrow{x} b\n$$\n\n`\\xrightarrow` 还可以做到在箭头的下方写文字.\n```md\na \\xrightarrow[y]{x} b\n```\n$$\na \\xrightarrow[y]{x} b\n$$\n\n这就是如何在 LaTeX 中在箭头的上/下方写文字的方法.\n\n## 参考链接\n[1] *\\Rightarrow with text above it, https://tex.stackexchange.com/questions/103988/rightarrow-with-text-above-it*"
    },

    {
        "id": "1cce18f1-7c12-4cb2-91b4-4241b30f00cf",
        "title": "LaTeX - \" \\ \" 符号",
        "category": "LaTeX",
        "date": { "year": 2021, "month": 2, "day": 14 },
        "peek": "如题所示",
        "content": "> 写于 2021-02-14\n\n## 使用方法\n`\\` 在 $LAT_EX$ 中有特殊含义. 如果需要打出 `\\`, 则需要输入 `\\backslash`.\n\n### 使用\n```latex\n\\backslash\n```\n\n结果: $\\backslash$\n\n### 注意事项 \n`\\backslash` 在 markdown 中可以用. `\\textbackslash` 似乎也是一个指令, 但是在 markdown 中却无法识别.\n\n## 参考链接\n[1] *https://tex.stackexchange.com/questions/34580/escape-character-in-latex, \"Escape character in LaTeX\"*"
    },

    {
        "id": "3de901fb-211f-4532-be6e-b176d27e1e9f",
        "title": "pip 使用国内镜像",
        "category": null,
        "date": { "year": 2021, "month": 2, "day": 13 },
        "peek": "本文介绍如何在 pip 中使用国内镜像",
        "content": "> 编写于: 2021-02-13\n\n## 使用方法\n#### 临时使用\n使用下面的命令下载\n```shell\npip3 install -i {镜像链接} {包名}\n```\n例如用淘宝的镜像下载 `scipy`:\n```shell\npip3 install -i https://mirrors.aliyun.com/pypi/simple/ scipy\n```\n## 一些镜像源\n|镜像源|镜像链接|\n|-------|-------|\n|阿里云|https://mirrors.aliyun.com/pypi/simple/|\n|豆瓣|http://pypi.douban.com/simple/|\n|清华大学|https://pypi.tuna.tsinghua.edu.cn/simple/|\n|中国科学技术大学|http://pypi.mirrors.ustc.edu.cn/simple/|\n|华中科技大学|http://pypi.hustunique.com/|\n\n## 参考链接\n[1] *https://blog.csdn.net/sinat_21591675/article/details/82770360, \"将pip源更换到国内镜像\"*\n"
    },

    {
        "id": "1ec594fe-327e-4ac6-ada9-347e4778e2ab",
        "title": "算法第四版 - 优先队列 (堆排序)",
        "category": "算法",
        "date": { "year": 2021, "month": 2, "day": 3 },
        "peek": "本文介绍了优先队列",
        "content": "> 写于 2021-02-03\n\n> 下面的 **最大** 泛指最值, 也就是 **最大/最小**. 为了书写和阅读的方便, 则简写为 **最大**.\n\n## 适用的情形\n我们需要收集一些数据并在某些时候获取其中最大/小的那个元素. 此时, 这些数据不需要保持有序, 只需要保证 **存放元素和取出最大元素** 的效率.\n\n## 核心 API\n```java\nvoid insert(Key k)\t插入一个元素\nKey max()\t\t返回最大元素\nKey delMax() \t\t删除并返回最大元素\n```\n## 初级实现\n#### 无序数组\n- 维持一个无序数组\n- 每次取最大元素时, 遍历所有元素并找到最大的元素. $O(N)$\n- 每次加入新元素时, 置于尾部. $N(1)$\n#### 有序数组\n- 维持一个有序数组\n- 每次取最大元素时, 返回最大的元素. $O(1)$\n- 每次加入新元素时, 遍历并置于合适的位置. $O(N)$\n\n## 二叉堆\n二叉堆可以在 $O(\\lg N)$ 的运行速度下:\n- 插入新元素.\n- 取出最大元素. \n\n> 堆有序\n> 当一棵二叉树的每个结点都大于它的两个子结点时, 它被称为 **堆有序**.\n\n根据 **堆有序** 的定义, 一棵符合 **堆有序** 的二叉树的根节点是该树中的最大结点.\n\n#### 表示方法\n使用一个数组来表示这个二叉堆:\n- 不使用数组的第一个位置.\n- 一个索引为 $k$ 的结点的父结点所在的位置是 $\\lfloor k/2\\rfloor$.\n- 一个索引为 $k$ 的结点的子结点所在的位置分别是 $2k$ 和 $2k+1$.\n\n## 堆的算法\n#### 堆的有序化\n在进行添加元素/取出最大元素的操作后, 更新后的二叉堆将不再保证 **堆有序**, 这个时候, 就需要将这个二叉堆重新保证 **堆有序**. 这个重新保证堆有序的过程就被称作 **堆的有序化**.\n\n堆的有序化有两种情形, 分别对应添加元素和取出最大元素. \n\n#### 由下至上的堆有序化\n在加入一个新元素后, 这个新元素会添加在数组的尾部. 这个时候, 除非这个新元素已经是最小的元素, 否者 **堆有序** 就会被打破. 这个时候, 就需要重新调整这个元素的位置, (进行一系列的交换动作), 使得重新回到 **堆有序** 的状态.\n```java\nprivate void swim(int k) {\n    while (k > 1 && less(k/2, k)) {\n        exch(k/2, k);\n        k = k/2;\n    }\n}\n```\n\n#### 由上至下的堆有序化\n取出最大元素后, 根节点的值就会出现空缺. 做法是将数组中最后面的那个元素置于根节点, 然后重新调整这个元素的位置, (进行一系列的交换动作), 直到重新回到 **堆有序** 的状态. \n```java\nprivate void sink(int k) {\n    while (2*k <= N) {\n        int j = 2*k;\n        if (j < N && less(j, j+1)) j++;\n        if (!less(k, j)) break;\n        exch(j, k);\n        k = j;\n    }\n}\n```\n\n## 堆排序\n堆排序分为两个阶段:\n1. 将数组调整为 **堆有序** 的二叉堆表示.\n2. 数组头的元素和当前堆的尾部的交换, 并将剩下的堆回到堆有序的状态.\n```java\npublic static void sort(Comparable[] a) {\n    int N = a.length;\n    for (int k = N/2; k >= 1; k--) \n        sink(a, 1, N--);\n    while (N > 1) {\n        exch(a, 1, N--);\n        sink(a, 1, N);\n    }   \n}\n```\n\n"
    },

    {
        "id": "16d96c23-b4fc-4272-84fb-6de92877270a",
        "title": "算法第四版 - 快速排序",
        "category": "算法",
        "date": { "year": 2021, "month": 2, "day": 1 },
        "peek": "快速排序是一种 分治 的排序算法. 它将一个数组分成两个子数组, 将两部分独立地排序.",
        "content": "> 2021-02-01  佛山\n\n#### 原理\n\n快速排序是一种 **分治** 的排序算法. 它将一个数组分成两个子数组, 将两部分独立地排序. \n\n快速排序和归并排序是互补的: \n\n- 归并排序将数组分成两个子数组分别排序, 并将有序的子数组归并以将整个数组排序;\n- 快速排序将数组排序的方式则是当两个子数组都有序时整个数组也就自然有序了.\n- 在第一种情况中, 递归调用发生在处理整个数组之前;\n- 在第二种情况中, 递归调用发生在处理整个数组之后.\n- 在归并排序中, 一个数组被等分为两半;\n- 在快速排序中, 切分 (partition) 的位置取决于数组的内容.\n\n#### 优点\n\n实现简单; 使用与各种不同的输入数据且一般应用中比其他算法都要快得多; 原地排序( 只需要一个很小的辅助栈 ), 且将长度为 $N$ 的数组排序所需的时间和 $N\\log N$ 成正比; 内循环比大多数排序算法都要短小, 这意味着它无论在理论上还是实际中都要更快. \n\n#### 缺点\n\n非常脆弱, 在实现时要非常小心才能避免低劣的性能.\n\n#### 实现\n\n```java\npublic class Quick {\n  public static void sort(Comparable[] a) {\n    shuffle(a); //消除对输入的依赖\n    sort(a, 0, a.length-1);\n  }\n  \n  public static void sort(Comparable[] a, int lo, int hi) {\n    if (lo >= hi) { return; }\n    int j = partition(a, lo, hi);\n    sort(a, lo, j-1);\n    sort(a, j+1, hi);\n  }\n  \n  public static int partition(Comparable[] a, int lo, int hi) {\n    int i = lo, j = hi+1;\n    Comparable v = a[lo];\n    while (true) {\n      while (less(a[++i], v)) { if (i==hi) { break; } }\n      while (less(v, a[--j])) { if (j==lo) { break; } }\n      if (i >= j) { break; }\n      exch(a, i, j);\n    }\n    exch(a, lo, j);\n    return j;\n  }\n}\n```\n\n"
    },

    {
        "id": "7fe1ed57-72e3-460e-8414-3d00dc94dcd9",
        "title": "算法第四版 - 归并排序",
        "category": "算法",
        "date": { "year": 2021, "month": 2, "day": 1 },
        "peek": "需要将一个数组排序, 可以先 (递归地) 将它分成两半分别排序, 然后将结果归并起来.",
        "content": "> 2021-02-01  佛山\n\n## 总览\n#### 原理\n\n需要将一个数组排序, 可以先 (递归地) 将它分成两半分别排序, 然后将结果归并起来.\n\n#### 优点\n\n能够保证将任意长度 $N$ 的数组排序所需时间和 $N\\log N$ 成正比.\n\n#### 缺点\n\n所需的额外空间和 $N$ 成正比.\n\n#### 实现\n\n```java\npublic static void merge(Comparable[] a, int lo, int mid, int hi) {\n  int i=lo, j = mid+1;\n  for (int k=0; k<=hi; k++) { aux[k] = a[k]; }\n  for (int k=0; k<=hi; k++) {\n    if (i>mid) \t\t\t\t{ a[k] = aux[j++]; }\n    else if (j>hi) \t\t\t{ a[k] = aux[i++]; }\n    else if (less(aux[i], aux[j])) \t{ a[k] = aux[i++]; }\n    else \t\t\t\t{ a[k] = aux[j++]; }\n  }\n}\n```\n\n## 自顶向下的归并排序\n\n#### 实现\n\n```java\npublic class Merge {\n  private static Comparable[] aux;\n  \n  public static void sort(Comparable[] a) {\n    aux = new Comparable[a.length];\n    sort(a, 0, a.length-1);\n  }\n  \n  public static void sort(Comparable[] a, lo, hi) {\n    if (lo >= hi) { return; }\n    int mid = lo + (hi - lo)/2;\n    sort(a, lo, mid);\n    sort(a, mid+1, hi);\n    merge(a. lo, mid, hi);\n  }\n}\n```\n\n#### 性能分析\n\n比较次数: $N\\log N$.\n\n## 自底向上的归并排序\n\n#### 实现\n\n```java\npublic class MergeBU {\n  private static Comparable[] aux;\n  public static void sort(Comparable[] a) {\n    int N = a.length;\n    aux = new Comparable[N];\n    for (int sz=1; sz<N; sz = sz+sz) {\n      for (int lo=0; lo<N-sz; lo+=sz+sz) {\n        merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));\n      }\n    }\n  }\n}\n```\n\n"
    },

    {
        "id": "1315d04a-c7b9-4c48-909d-a70b4ad4aa39",
        "title": "初级排序算法",
        "category": "算法",
        "date": { "year": 2021, "month": 2, "day": 1 },
        "peek": "在数组中找到最小的元素, 然后将其与第一个元素交换位置(, 如果是本身的话就和自己交换).",
        "content": "> 2021-02-01  佛山\n\n## 选择排序\n\n#### 原理\n\n在数组中找到最小的元素, 然后将其与第一个元素交换位置(, 如果是本身的话就和自己交换). 然后找到剩下元素中最小的元素, 将它与第二个元素交换位置. 如此反复, 直到排序完成.\n\n#### 实现\n\n```java\npublic class Selection {\n  public static void sort(Comaprable[] a) {\n    int N = a.length;\n    for (int i=0; i<N; i++) {\n      int minIndex = i;\n      for (int j=i+1; j<N; j++) {\n        if less(a[j], a[i]) {\n          minIndex = j;\n        }\n      }\n      exch(a, i, j);\n    }\n  }\n}\n```\n\n\n\n#### 代价分析\n\n| 交换次数 |    比较次数    |\n| :------: | :------------: |\n|   $n$    | $\\dfrac{n^2}2$ |\n\n**Q: 为什么访问次数是 $\\dfrac{n^2}2$?**\n\nA: 对于第一个元素, 最多对比 $n-1$ 次. 对于第二个元素, 最多对比 $n-2$ 次, ... , 对于第倒数第二个元素, 需要访问 1 次.\n$$\n(n-1)+(n-2)+(n-3)+\\cdots+3+2+1 = \\dfrac{[(n-1)+1]\\cdot(n-1)}{2} \\approx \\dfrac{n^2}2\n$$\n\n\n## 插入排序\n\n#### 原理\n\n插入排序的原理就和整理扑克牌一样, 当抽了一张牌以后, 需要把它插入相应的位置, 这就意味着比当前大的所有 \"牌\" 都需要向右移动一个位置. **插入排序所需的时间取决于输入中元素的初始顺序**.\n\n#### 实现\n\n```java\npublic class Insertion {\n  public static void sort(Comparable[] a) {\n    //将 a 按升序排序 (小->大)\n    int N = a.length;\n    for (int i=0; i<N; i++) {\n      //将 a[i] 插入到 a[i-1], a[i-2], ... , a[0] 中\n      for (int j=i; j>0 && less(a[j], a[j-1]); j--) {\n        exch(a, j, j-1);\n      }\n    }\n  }\n}\n```\n\n#### 代价分析\n\n|      |    交换次数    |    比较次数    |\n| :--: | :------------: | :------------: |\n| 平均 | $\\dfrac{n^2}4$ | $\\dfrac{n^2}4$ |\n| 最坏 | $\\dfrac{n^2}2$ | $\\dfrac{n^2}2$ |\n| 最好 |      $0$       |     $n-1$      |\n\n**最坏情况: 倒序**\n\n| 数组              | 交换次数 (当前) | 比较次数 (当前) |\n| ----------------- | --------------- | --------------- |\n| 5, 4, 3, 2, 1     | -               | -               |\n| **4**, 5, 3, 2, 1 | 1               | 1               |\n| **3**, 4, 5, 2, 1 | 2               | 2               |\n| **2**, 3, 4, 5, 1 | 3               | 3               |\n| **1**, 2, 3, 4, 5 | 4               | 4               |\n| **总计**          | 10              | 10              |\n\n$$\n1+2+\\cdots+(n-2)+(n-1)\\approx\\dfrac {n^2}2\n$$\n\n**最好情况: 已经排序完成**\n\n| 数组              | 交换次数 (当前) | 比较次数 (当前) |\n| ----------------- | --------------- | --------------- |\n| 1, 2, 3, 4, 5     | -               | -               |\n| 1, **2**, 3, 4, 5 | 0               | 1               |\n| 1, 2, **3**, 4, 5 | 0               | 1               |\n| 1, 2, 3, **4**, 5 | 0               | 1               |\n| 1, 2, 3, 4, **5** | 0               | 1               |\n| **总计**          | 0               | 4               |\n\n## 部分有序\n\n#### 定义\n\n> **倒置**: 数组中的两个顺序颠倒的元素.\n> - E X A M P L E 中, 有 E-A, X-A, X-M, X-P, X-L, X-E, M-L, M-E, P-L, P-E, L-E 这些倒置.\n\n如果数组中倒置的数量小于数组大小的某个倍数, 那么我们说这个数组是 **部分有序** 的.\n\n#### 典型的部分有序数组\n\n- 数组中每个元素距离它的最终位置都不远;\n- 一个有序的大数组接一个小数组;\n- 数组中只有几个元素的位置不确定.\n\n#### 事实\n\n插入排序对部分有序的数组很有效. 当倒置的数量很少时, 插入排序很可能比其他任何算法都要快.\n\n## 希尔排序\n\n#### 原理\n\n是基于插入排序的排序算法. \n\n希尔排序为了加快速度, 简单地改进了插入排序. (交换不相邻的元素以对数组的局部进行排序, 并最终用插入排序将局部有序的数组排序.\n\n**思想**: 使数组中任意间隔 h 的元素都是有序的. 这样的数组被称为 **h 有序数组**. (一个 h 有序数组就是 h 个互相独立的有序数组编织在一起组成的一个数组.)\n\n```\nL E E A M H L E P S O L T S X\nL ----- M ----- P ----- T\n  E ----- H ----- S ----- S\n    E ----- L ----- O ----- X\n```\n\n\n\n#### 实现\n\n```java\npublic class Shell {\n  public static void sort(Comparable[] a) {\n    int N = a.length;\n    int h = 1;\n    while (h<N/3) { h = 3*h+1; } //?\n    while (h>=1) {\n      for (int i=h; i<N; i++) {\n        for (int j=i; j>=h && less(a[j], a[j-h]); j-=h) {\n          exch(a, j, j-h);\n        }\n      }\n      h/=3;\n    }\n  }\n}\n```\n\n\n\n#### 代价分析\n\n略\n\n## 习题\n\n#### 题目1 \n\n**写下选择排序是如何将数组 E A S Y Q U E S T I O N 排序的**.\n\n| i    | Array                   |\n| ---- | ----------------------- |\n| 0    | A E S Y Q U E S T I O N |\n| 1    | A E S Y Q U E S T I O N |\n| 2    | A E E S Y Q U S T I O N |\n| 3    | A E E I S Y Q U S T O N |\n| 4    | A E E I N S Y Q U S T O |\n| 5    | A E E I N S Y Q U S T O |\n| 6    | A E E I N S S Y Q U T O |\n| 7    | A E E I N S S T Y Q U O |\n| 8    | A E E I N S S T O Y Q U |\n| 9    | A E E I N S S T O Q Y U |\n| 10   | A E E I N S S T O Q U Y |\n\n\n\n#### 题目2\n\n**写下插入排序是如何将数组 E A S Y Q U E S T I O N 排序的**.\n\n| i    | Array                           |\n| ---- | :------------------------------ |\n| 0    | **E** A S Y Q U E S T I O N     |\n| 1    | **A E** S Y Q U E S T I O N     |\n| 2    | A E **S** Y Q U E S T I O N     |\n| 3    | A E S **Y** Q U E S T I O N     |\n| 4    | A E **Q S Y** U E S T I O N     |\n| 5    | A E Q S **U Y** E S T I O N     |\n| 6    | A E **E Q S U Y** S T I O N     |\n| 7    | A E E Q S **S U Y** T I O N     |\n| 8    | A E E Q S S **T U Y** I O N     |\n| 9    | A E E **I Q S S T U** **Y** O N |\n| 10   | A E E I **O Q S S T U Y** N     |\n| 11   | A E E I **N O Q S S T U Y**     |\n\n\n\n"
    },

    {
        "id": "1f0e160d-993e-4772-a6d3-abb8b5e76c17",
        "title": "Mac brew 启用/重启服务",
        "category": null,
        "date": { "year": 2021, "month": 1, "day": 31 },
        "peek": "如题所示",
        "content": "> 2021-01-31 佛山\n\n## 启用服务\n```\nbrew service start {serviceName}\n```\n## 重启服务\n```\nbrew service restart {serviceName}\n```\n## 关闭服务\n```\nbrew service stop {serviceName}"
    },

    {
        "id": "a59b9000-d9a1-4774-8899-f7cb9a0204f4",
        "title": "算法第四版 - 案例: Union Find",
        "category": "算法",
        "date": { "year": 2021, "month": 1, "day": 25 },
        "peek": "本文介绍了 Union Find 算法",
        "content": "> 2021-01-25 佛山\n\n## `Union Find` 的 API\n```java\n\tUF(int N)\t\nvoid\tunion(int p, int q)\nint\tfind(int p)\nboolean\tconnected(int p, int q)\nint\tcount()\n```\n## 实现\n```java\npackage unionFind;\n\npublic abstract class UF {\n    private int[] id;\n    private int count;\n\n    public UF(int N) {\n        count = N;\n        id = new int[N];\n        for (int i = 0; i < N; i++)\n            id[i] = i;\n    }\n\n    public int count() {\n        return count;\n    }\n\n    public boolean connected(int p, int q) {\n        return find(p) == find(q);\n    }\n\n    public abstract int find(int p);\n\n    public abstract void union(int p, int q);\n}\n```\n结合 `UF` 的 API 中, `find` 和 `union` 是需要重要研究的两个方法. 因为可以给出不同的实现而且不同的实现会有速度的权衡.\n> `UF` 的 `成本模型` 主要关注数组的访问次数.\n\n## `quick-find` 算法\n`find` 方法\n```java\npublic int find(int p) {\n    return id[p];\n}\n```\n`union` 方法\n```java\npublic void union(int p, int q) {\n    int pID = find(p);\n    int qID = find(q);\n\n    if (pID == qID) return;\n\n    for (int i = 0; i < id.length; i++)\n        if (id[i] == pID)\n            id[i] = qID;\n        count--;\n}\n```\n#### 算法分析\n虽然 `find` 很快, 但是 `union` 方法会扫描整个数组. \n\n## `quick-union` 算法\n`find` 方法\n```java\npublic int find(int p) {\n    while (p != id[p]) p = id[p];\n    return p;\n}\n```\n`union` 方法\n```java\npublic void union(int p, int q) {\n    int pRoot = find(p);\n    int qRoot = find(q);\n    if (pRoot == qRoot) return;\n    \n    id[pRoot] = qRoot;\n\n    count--;\n}\n```\n#### 算法分析\n详见书本.\n\n## `quick-find` 和 `quick-union` 的性能总览\n|算法|初始化|union|find|connected|\n|-------|-------|-------|-------|------|\n|`quick-find`|N|N|1|1|\n|`quick-union`|N|N|N|N|\n"
    },

    {
        "id": "b72c9d3c-b920-4451-8f5e-fdadd0d107b1",
        "title": "HTML - 隐藏 input type 为 number 时的上下按钮",
        "category": "CSS",
        "date": { "year": 2021, "month": 1, "day": 25 },
        "peek": "本文介绍了如何隐藏数字类型input中的箭头",
        "content": "> 2021-01-25 佛山\n>\n>[参考链接](https://www.w3schools.com/howto/howto_css_hide_arrow_number.asp)\n\n## 做法\n添加 `CSS`:\n```css\n/* Chrome, Safari, Edge, Opera */\ninput::-webkit-outer-spin-button,\ninput::-webkit-inner-spin-button {\n  -webkit-appearance: none;\n  margin: 0;\n}\n\n/* Firefox */\ninput[type=number] {\n  -moz-appearance: textfield;\n}\n```"
    },

    {
        "id": "3d9ef8a2-b0d7-450f-8575-2ab681001f35",
        "title": "Git - gitignore",
        "category": "Git",
        "date": { "year": 2021, "month": 1, "day": 24 },
        "peek": "首先我们需要在某个机器上运行 MQTT 服务器. 在本文中, 我们使用来自 Eclipse Foundation 的 Mosquitto",
        "content": "> 2021-01-24 佛山\n\n## .gitignore 的作用\n将指定的文件, 文件夹在版本控制时忽略.\n\n## Pattern 形式\n- 使用 `#` 符号来添加注释. \n- `/` 是路径分隔符, 可以被放在 pattern 的 **前**, **中**, **后** 的位置\n  - 放在 **前面** 和 **中间**: pattern 是相对于 .gitignore 所在文件目录, 否则会在 .gitignore 所在目录下的全部内容进行搜索.\n  - 放在 **后面**: 只会搜索文件夹. (否则也可能是文件)\n- `*` 会匹配除了 `/` 以外的一个或多个任意字符. \n- `?` 会匹配除了 `/` 以外的单个任意字符.\n- `[a-zA-Z]` 会匹配这个范围内的一个字符.\n- `**`:\n  - `**/`: 匹配任何文件夹.\n  - `/**`: 匹配该文件下面的所有内容.\n  - `../**/..`: 匹配任何文件夹或没有文件夹.\n\n\n\n## 参考链接\n[Git - gitignore Documentation](https://git-scm.com/docs/gitignore)"
    },

    {
        "id": "86a4d782-3e03-4f9e-a38f-4b3f06faaa18",
        "title": "LaTeX 下载新包",
        "category": "LaTeX",
        "date": { "year": 2021, "month": 1, "day": 20 },
        "peek": null,
        "content": "> 2021-01-20  佛山\n>\n> **环境**\n> 系统: MacOS\n>\n> 已经安装 `LaTeX` 软件\n\n## 操作流程\n在终端输入安装命令\n```bash\ntlmgr install {packageName}\n```\n\n## 问题\n#### 权限不够\n在命令前加 `sudo`\n\n#### 需要更新 `ltmgr`\n更新 `tlmgr`\n```bash\ntlmgr update --self\n```"
    },

    {
        "id": "f33ede0a-d161-4b10-80dd-215dd9ab1c8c",
        "title": "Python - 一些常用的私有方法",
        "category": "Python",
        "date": { "year": 2021, "month": 1, "day": 19 },
        "peek": "标题中所指的 私有方法 指的是类似于 Java 中的 .equals 和 .toString 的方法",
        "content": "> 2021-01-19  佛山\n\n## 介绍\n标题中所指的 **私有方法** 指的是类似于 [Java](/#/category/Java/page/1) 中的 `.equals` 和 `.toString` 的方法. 本文将会介绍在 [Python](/#/category/Python/page/1) 中的 `__eq__` 和 `__str__` 方法. \n\n## `__eq__` 方法\n该方法对应 [Java](/#/category/Java/page/1) 中的 `.equals()` 方法, 用于判断两个对象是否相同. 在 [Python](/#/category/Python/page/1) 中则有一点特殊之处: 在编写了该方法后, 当对两个对象执行 `==` 操作时就会调用该 `__eq__` 方法.\n\n```python\nclass Point(object):\n    def __init__(self, x, y):\n        self.__x = x\n        self.__y = y\n\n    def getX(self):\n        return self.__x\n\n    def getY(self):\n        return self.__y\n\n    def __eq__(self, that):\n        sameX = self.getX()==that.getX()\n        sameY = self.getY()==that.getY()\n        return (sameX and sameY)\n\nif __name__ == '__main__':\n    p1 = Point(1, 2)\n    p2 = Point(1, 2)\n    print(p1==p2)\n```\n> 在这个例子中, 如果没有编写 `__eq__` 方法, 就会打印输出 `False`\n\n## `__str__` 方法\n该方法对应 [Java](/#/category/Java/page/1) 中的 `.toString()` 方法, 用于将对象转换成字符串. 在编写了该方法后, 对当前对象的直接打印操作便会调用该方法, 否则将会默认打印一个对象的地址.\n```python\nclass Point(object):\n    def __init__(self, x, y):\n        self.__x = x\n        self.__y = y\n\n    def getX(self):\n        return self.__x\n\n    def getY(self):\n        return self.__y\n\n    def __str__(self):\n        return '{{x: {:.4f}, {:.4f}}}'.format(self.getX(), self.getY())\n\nif __name__ == '__main__':\n    p1 = Point(1, 2)\n    print(p1)\n```\n> 该方法的作用与 [Java](/#/category/Java/page/1) 中的 `toString()` 方法基本一致."
    },

    {
        "id": "b34a421c-16e5-4c37-aa64-c3c63ccd35bb",
        "title": "Python - 异常处理",
        "category": "Python",
        "date": { "year": 2021, "month": 1, "day": 18 },
        "peek": "在程序的运行过程中, 如果遇到异常情况, 就应该抛出一个相应的异常",
        "content": "> 2021-01-18  佛山\n\n## 基本方法\n使用 `try` / `catch` 语句\n```python\ntry:\n    ... # do something\nexcept [XXError]:\n    ... # deal with the exception\n```\n\n\n## 相关问题\n#### 什么是异常?\n在程序的运行过程中, 如果遇到异常情况, 就应该抛出一个相应的 **异常**. **注意, 这里的异常指的是程序中的一个对象, 而不是日常生活认知中的*异常*.**) 此时, 如果这个异常没有被处理, 那么这个程序就会终止. 举一个简单的例子：对一个栈进行 pop 操作时，如果该栈是空的，与其返回一个默认的值（例如-1），不如抛出一个“空栈”异常。在这个例子中，**异常情况**是在栈为空时 pop，对应的异常类型（可以）是“空栈”异常。常见的异常有：空指针异常，索引超出范围异常，除以零异常...\n\n此外, 异常可以作为一种 **特殊的返回类型**. \n**例: People.java**:\n```java\npublic class People {\n    private String name;\n    private boolean keepGenderSecret;\n    private String gender;\n    public String getGender() throws PrivacyException {\n        if (!this.keepGenderSecret) {\n            return this.gender;\n        } else {\n            throw new PrivacyExeption(this.name+\" is not willing to share the gender.\");\n        }\n    }\n}\n```\n"
    },

    {
        "id": "c22474f0-e124-4b45-beff-4304891804e4",
        "title": "Python - 如何写私有属性/方法",
        "category": "Python",
        "date": { "year": 2021, "month": 1, "day": 18 },
        "peek": "本文介绍如何编写 Python 私有方法",
        "content": "> 2021-01-18  佛山\n\n## 解决方法\n在 变量/方法名 添加两个下划线.\n## 例子\n定义 `People` 类\n```python\nclass People(object):\n    def __init__(self, name):\n        self.__name = name\n```\n测试\n```bash\n>>> p = People('Name')\n>>> p.__name\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nAttributeError: 'People' object has no attribute '__name'\n```\n"
    },

    {
        "id": "db463512-3a0d-48e2-abe3-2e7f56d070d8",
        "title": "It's a leap of faith",
        "category": null,
        "date": { "year": 2021, "month": 1, "day": 11 },
        "peek": "ANYONE CAN WEAR A MASK",
        "content": "> 2020-01-11  佛山\n\n![spiderverse](img/articles/spiderverse.jpeg)\n\n\n“ANYONE CAN WEAR A MASK.”\n\n“YOU can wear a mask.”\n\n\"If you didn’t know that before, I hope you do now. \""
    },

    {
        "id": "cffb4e12-b9bf-4573-bbcf-d077f0f3291e",
        "title": "Spring Cloud - Managing Configuration - I",
        "category": "Spring Cloud",
        "date": { "year": 2021, "month": 1, "day": 10 },
        "peek": "终于看完了 Service Discovery 的部分. 虽然只是 20 页的书而已, 但是看了将近一个星期",
        "content": "> 2021-01-10  广州\n>\n> 更新于 2021-05-02\n\n终于看完了 Service Discovery 的部分. 虽然只是 20 页的书而已, 但是看了将近一个星期. 其中最大的\"难点\"就是同时运行多个服务器. 话不多说, 从今天开始进入第 14 章的内容 --- 配置管理. \n> 本章将包含:\n> 1. 运行 `Spring Cloud` 配置服务器\n> 2. 创建配置服务器的客户端\n> 3. 存储敏感配置\n> 4. 自动刷新配置\n\n## 简单应用的配置和生效\n在简单的 Spring 应用中, 对于可能会改变的配置信息, 我们会通过改变**系统变量**并**重启**应用来使得更新生效; 对于不会改变的配置, 我们会将其写在 `application.properties` 或者 `application.yml` 文件中, 然后**重新构建项目**, **重新编译**, **重新启动**来使得配置更新生效. \n\n## 传统配置方式在微服务架构中的问题\n在微服务架构中, 如此的生效方式显然是不可取的. 举个例子, 如果有多个codebase共享一个配置属性且此时我们需要更新这个属性, 那么我们就要重启所有的相关应用来使得这个更新生效. \n\n## 中心化的配置服务器\n为了解决之前提到的问题，我们需要一个中心化的配置管理机制. \n\n如果有一个中心化的配置服务器, 那么,\n- 因为配置信息不再编写于代码中, 那么更新/回滚配置信息就不再需要重新构建, 重新部署项目.\n- 一处修改, 多处生效!\n- 敏感配置可以从应用程序代码中剥离出来, 再经过加密从而保证安全性.\n\n> 配置服务器的**配置信息**通常会被部署在一个**版本管理系统**当中, 如 Git.\n\n## 话不多说, 进入代码的部分\n\n通过 [Spring Initializr](https://start.spring.io/) 来创建一个名为 `config-server` 的应用, 其中需要添加 `Config Server` 依赖. 自动生成的项目中的 `pom.xml` 中将会有下面的代码:\n```xml\n<dependency>\n    <groupId>org.springframework.cloud</groupId>\n    <artifactId>spring-cloud-config-server</artifactId>\n</dependency>\n```\n```xml\n<spring-cloud.version>2020.0.2</spring-cloud.version>\n\n...\n\n<dependencyManagement>\n    <dependencies>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n\t    <artifactId>spring-cloud-dependencies</artifactId>\n\t    <version>${spring - cloud.version}</version>\n\t    <type>pom</type>\n\t    <scope>import</scope>\n\t</dependency>\n    </dependencies>\n</dependencyManagement>\n```\n> 💡 `dependencyManagement` 中的内容会根据 `Spring Cloud` 的版本而发生变化.\n\n在主类中加入 `@EnableConfigServer` 注解, 像下面这样:\n```java\n...\n\n@EnableConfigServer\n@SpringBootApplication\npublic class ConfigServerApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ConfigServerApplication.class, args);\n    }\n\n}\n```\n然后在 `application.yml` 中加入如下配置(注意这里的配置是 `ConfigServer` 的配置, 不是 `ConfigServer` 提供的配置信息).\n```yml\nspring:\n  cloud:\n    config:\n      server:\n        git:\n          uri: https://github.com/...\n\nserver:\n  port: 8888\n```\n> `spring.cloud.config.server.git.uri` 需要输入保存配置信息的版本控制系统url.\n\n现在这个配置服务器已经可以运行了. 但是还不能从这个服务器中获取任何配置信息. 很显然, 我们需要在  `spring.cloud.config.server.git.uri` 所写的版本控制系统中添加一些数据才行. \n\n就先写到这里吧."
    },

    {
        "id": "6dd23861-d609-429e-a291-4794e80d7458",
        "title": "Spring Cloud - Service Discovery - IV",
        "category": "Spring Cloud",
        "date": { "year": 2021, "month": 1, "day": 6 },
        "peek": "有两种消费微服务的方式:",
        "content": "> 2021-01-06  佛山\n\n## 消费微服务 \n> Consume microservices\n\n有两种消费微服务的方式:\n- 一个负载均衡的 RestTemplate\n- 假装生成的客户端接口\n## 通过 RestTemplate 消费\n如果直接使用 `RestTemplate` 的 API 来消费其他服务, 那么就会出现 URL 被硬编码的情况, 而且完全没有发挥负载均衡的作用. 所以我们需要用到**被负载均衡的`RestTemplate`**. 声明一个这样的 `Bean`:\n```java\n@Bean\n@LoadBalanced\npublic RestTemplate restTemplate() {\n    return new RestTemplate();\n}\n```\n### `@LoadBalanced`的作用\n- 这个 `RestTemplate` 可以通过 `Ribbon` 寻找服务.\n- 他可以在 *依赖注入* 时和其他的 `RestTemplate` 区分开来. (见以下代码)\n```java\n@Component\npublic class SomeServiceClient {\n\n    private RestTemplate rest;\n    \n    public SomeServiceClient(@LoadBalanced RestTemplate rest) {\n        this.rest = rest;\n    }\n}\n```\n### 使用该 `RestTemplate`\n```java\npublic XXX getXXX(String id) {\n    return rest.getForObject(\"http://xxx-service/xxx/{id}\", XXX.class, id);\n}\n```\n可以看到, 这里没有出现具体的 `host` 和 `port`, 而仅仅是 `xxx-service`. 因为 `Robbin` 会通过这个 `xxx-service` 找到相应的 `host` 和 `port` 并替换进去. \n\n> 2021-01-07  佛山\n## 使用 WebClient 消费微服务\n在调用端注入 `webflux` 依赖:\n```xml\n<dependency>\n  <groupId>org.springframework.boot</groupId>\n  <artifactId>spring-boot-starter-webflux</artifactId>\n</dependency>\n```\n声明 `WebClient.Builder` `Bean`:\n```java\n@Bean\n@LoadBalanced\npublic WebClient.Builder webClientBuilder() {\n    return new WebClient.Builder();\n}\n```\n编写 `RestController`:\n```java\n@RequestMapping(\"/foo\")\n@RestController\npublic class XXXController {\n    \n    private WebClient.Builder builder;\n\n    @Autowired\n    public XXXController(@LoadBalanced WebClient.Builder builder) {\n        this.builder = builder;\n    }\n}\n```\n编写调用接口\n```java\n@...\npublic XXXController {\n    \n    ...\n    \n    @GetMapping(\"/xxx/{input}\")\n    public Mono<XXXType> getXXX(@PathVariable(\"input) String input) {\n        return builder\n                .build()\n                .get()\n                .url(\"http://some-service/someAPI/{input}\", input)\n                .retrieve()\n                .bodyToMono(XXXType.class);\n    }\n}\n```\n可以发现, 这个和之前的 `RestTemplate` 还是十分相似的.\n\n## 使用 `Feign Client`\n注入依赖\n```xml\n<dependency>\n  <groupId>org.springframework.cloud</groupId>\n  <artifactId>spring-cloud-starter-openfeign</artifactId>\n</dependency>\n```\n激活依赖\n```java\n@Configuration\n@EnableFeignClients\npublic class Configuration {}\n```\n创建 `Feign Client` 接口\n```java\n@FeignClient(\"xxx-service\")\npublic interface XXXClient {\n    @GetMapping(\"/apiPath/{input}\")\n    public XXX getXXX(@PathVariable(\"input\") String input);\n}\n```\n创建 `RestController`\n```java\n@RestController\n@RequestMapping(\"/consumer\")\npublic class Consumer {\n    \n    private XXXClient client;\n\n    @Autowired\n    public Consumer(XXXClient clent) {\n        this.client = client;\n    }\n\n    @GetMapping(\"/consume/{input}\")\n    public XXX getXXX(@PathVariable(\"input\") String input) {\n        return client.getXXX(input);\n    }\n}\n```\n\n## 小节结语\n到这里就结束了第13章, Service Discovery, 的全部内容! ✿✿ヽ(°▽°)ノ✿\n下面是一些技术总结:\n- `Eureka Server` 的配置\n  - `@EnableEurekaServer`\n- 注册服务\n  - `@EnableEurekaClient`\n- 消费服务\n  - 使用 `RestTenplate`\n  - 使用 `WebClient`\n  - 使用 `FeignClient`"
    },

    {
        "id": "9e545a6f-19bc-4895-b496-e11da51a7ce1",
        "title": "Spring Cloud - Service Discovery - III",
        "category": "Spring Cloud",
        "date": { "year": 2021, "month": 1, "day": 6 },
        "peek": "要注册一个新的微服务, 那么就要在 相应的微服务项目中添加 eureka client 的依赖",
        "content": "> 2021-01-06  佛山\n\n## 注册/发现服务\n> Registering and discovering services\n\n要注册一个新的微服务, 那么就要在 相应的微服务项目中添加 eureka client 的依赖, 和 Spring Cloud 依赖管理的配置. 这些配置可以手动编写, 或直接用 [spring initializer](https://start.spring.io) 生成一个配置完整的项目文件.\n\n### 设置 Eureka client 属性\n\n**`spring.application.name`**\n\n最重要的属性就是应用的名称了. 他的配置方法也是十分简单: 在 application.yml 中添加下面的信息即可:\n```yml\nspring:\n  application:\n    name: my-service\n```\n\n**`server.port`**\n既然我们只会通过 Eureka 寻找想要的微服务, 那么有意设置一个端口号或许意义不大. 这个时候不如直接让系统为其分配端口号. 为了做到这一点, 只需要在 application.yml 中添加下面的信息即可:\n```yml\nserver:\n  port: 0\n```\n当端口被设置为 0 时, 应用会在可选的端口中随机选择一个端口号并运行.\n\n### 注册服务\n如果需要将当前的应用注册到 Eureka Server, 则需要在 application.yml 中添加相应 Eureka Server 的信息:\n```yml\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/\n```\n其中 `defaultZone` 后的地址为具体地址, 上面指示一个例子. 如果同时有多个 Eureka Server, 就在该字段后面加上其他 Eureka Server 的地址, 差不多像这样:\n```yml\neureka:\n  client:\n    service-url:\n      defaultZone: http://localhost:8761/eureka/, http://.../eureka/\n```\n"
    },

    {
        "id": "a1239091-4ed8-49bc-80bf-ae8cefd1ec72",
        "title": "Spring Cloud - Service Discovery - II",
        "category": "Spring Cloud",
        "date": { "year": 2021, "month": 1, "day": 5 },
        "peek": "本想在B站上找一点有关于 Eureka 的视频, 却意外的发现这个东西已经停止更新了, 同时了解到了一些它的替代物.",
        "content": "> 2021-01-05  佛山\n\n## Caution !\n本想在B站上找一点有关于 Eureka 的视频, 却意外的发现这个东西已经停止更新了, 同时了解到了一些它的替代物. 不得不感慨, 世间的一切都在变, 而且变得很快. 虽然 Eureka 已经停止更新, 但是为了保证不影响该书后面两章的阅读, 还是先继续研究 Eureka 比较好. 即使是已经停更的技术, 也它也总是有价值的.\n\n## 官网教程\n👉 [快速链接](https://spring.io/guides/gs/service-registration-and-discovery/)\n\n## Scale Eureka Server\n这里运行了两个 Eureka Server, 他们相互发现.\n\n以下是两个 Eureka Server 的配置文件:\n```yml\nserver:\n  port: 8761\n\nspring:\n  application:\n    name: \"eurekaServer1\"\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    service-url:\n      defaultZone: http://${other.eureka.host}:${other.eureka.port}/eureka\n\nother:\n  eureka:\n    host: localhost\n    port: 8762\n\n---\nserver:\n  port: 8762\n\nspring:\n  application:\n    name: \"eurekaServer2\"\n\neureka:\n  instance:\n    hostname: localhost\n  client:\n    service-url:\n      defaultZone: http://${other.eureka.host}:${other.eureka.port}/eureka\n\nother:\n  eureka:\n    host: localhost\n    port: 8761\n```"
    },

    {
        "id": "bff33c09-1e69-41cf-8451-509a86f1f8c1",
        "title": "Spring Cloud - Service Discovery - I",
        "category": "Spring Cloud",
        "date": { "year": 2021, "month": 1, "day": 4 },
        "peek": "Spring Cloud 是一个巨大的项目. 它包含多个支持微服务运行的子项目",
        "content": "> 2021-01-04  佛山\n\nSpring Cloud 是一个巨大的项目. 它包含多个支持微服务运行的子项目. 子项目 Spring Cloud Netflix 中的 Eureka 组件, 是Netflix service registry.\n\n```text\nSpring Cloud\n|\n| _ Spring Cloud Netflix (Sub-project)\n    | \n    | _ Eureka (Component)\n```\n\n#### 开始项目\n用 [spring initializer](http://start.spring.io) 来生成一个初始项目文件. 只需要选择添加 Eureka Server 依赖即可.\n\n等待 IDEA 完成初始化工作以后, 在 `XXXApplication` 类上加 `@EurekaServer` 注解即可启动 `Eureka` 服务器.\n\n可以在 [localhost:8080](http://localhost:8080) 查看相关信息.\n\n#### 配置 Eureka\n在按照上面的指示启动 Eureka Server 以后, 没过30秒就会在终端抛出异常. 这是因为 Eureka Server 还没有配置完全导致的. \n\n在生产环境下, Eureka Server 自己也应该有多个复制来避免因为单点失败带来的整个系统的失败. 但是在开发环境下, 单个 Eureka Server 就已经足够了. \n\n因此, 在 application.yml 中添加以下配置:\n```yml\neureka:\n  instance: \n    hostname: localhost\n  client:\n    fetch-registry: false\n    registry-with-eureka: false\n    server-url:\n      defaultZone: http://${eureka.instance.hostname}:${server.port}/eureka\n```\n#### Q: `eureka.client.fetch-registry` 和 `eureka.client.register-with-eureka` 有什么作用?\nA: 这两者的默认值都是 `true`. 这意味着 Eureka Server 需要从其他的 Eureka Server 获取信息. 且需要把自己注册到其他的 Eureka Server 中. \n\n#### `SELF-PRESERVATION` 模式\n该模式默认打开. 在打开的情况下, 如果Eureka在90秒之内没有收到来自某个服务用例的更新信息, 那么这个用例就会被取消注册. 该模式在生产环境中需要被打开, 在开发的环境下, 可以保持关闭. \n "
    },

    {
        "id": "d7ca05c1-fe7b-4dcf-a4b7-a7d945b660cf",
        "title": "Spring Cloud - 启动!",
        "category": "Spring Cloud",
        "date": { "year": 2021, "month": 1, "day": 3 },
        "peek": "从今天开始, 我将通过 \"Spring in Action fifth edition\" 来正式学习 Spring Cloud 相关的知识. ",
        "content": "> 佛山 2021-01-03\n\n#### 简介\n从今天开始, 我将通过 *\"Spring in Action fifth edition\"* 来正式学习 Spring Cloud 相关的知识. 该书的第四部分包含了 Spring Cloud 的内容. 其中:\n- 第十三章介绍了 service discovery\n- 第十四章介绍了 Config Server \n- 第十五章展示了如何使各个服务更加可靠 (failure tolerance)\n\n#### 传统项目的弊端\n在传统的Spring项目中, 随着项目的发展, 一味地在原有的项目上添加新的代码会使得项目变得逐渐巨大臃肿. 在这样的系统中, 各个部分的职责很有可能会变得十分模糊. 此外, 因为项目的巨大以及其复杂度, 全面的测试会变得十分困难. 而且繁多的组件很容易导致库的冲突...\n\n#### 微服务   \n这个时候, 微服务的出现就解决了以上单一系统的不足. **一个应用将被分割成一个个可以被独立开发并部署的小应用**. **这些微服务互相协作来构成一个功能完整的系统**.\n\nQ: **微服务架构有什么缺点吗?**\nA: 因为微服务架构是一个分布式的系统, 那么分布式系统所拥有的弊端不可避免的会在该架构中出现. 例如网络延迟等等.\n\n\n"
    },

    {
        "id": "4fbb3aa4-5fbc-4cc4-831f-ac8388359def",
        "title": "Java 深拷贝 和 浅拷贝",
        "category": "Java",
        "date": { "year": 2021, "month": 1, "day": 2 },
        "peek": "在Java中, 类可以通过实现 `Cloneable` 接口来实现. 但是由此方法拷贝的对象是浅拷贝.",
        "content": "在Java中, 类可以通过实现 `Cloneable` 接口来实现. \n\n但是由此方法拷贝的对象是浅拷贝. 具体地说, 对于对象内部的基本类型是深拷贝, 而引用类型是浅拷贝. \n\n查看以下代码: (省略constructor, getter, setter, toString...)\n\n```java\npackage prototype;\n\nimport java.io.Serializable;\n\npublic class Bar implements Serializable {\n    private String name;\n}\n```\n\n```java\n package prototype;\n \n import java.io.*;\n \n public class Prototype implements Cloneable, Serializable {\n     private long id;\n     private Bar bar;\n \n     @Override\n     public Prototype clone() {\n         try {\n             return (Prototype) super.clone();\n         } catch (CloneNotSupportedException e) {\n             e.printStackTrace();\n             return null;\n         }\n     }\n \n     public Prototype deepClone() throws Exception {\n         var baos = new ByteArrayOutputStream();\n         var oos  = new ObjectOutputStream(baos);\n         oos.writeObject(this);\n         var bais = new ByteArrayInputStream(baos.toByteArray());\n         var ois  = new ObjectInputStream(bais);\n         return (Prototype) ois.readObject();\n     }\n }\n```\n\n```java\n package prototype;\n \n public class Client {\n     public static void main(String[] args) throws Exception {\n         Prototype prototype = new Prototype();\n         prototype.setBar(new Bar(\"bar\"));\n         prototype.setId(3);\n \n         //浅拷贝\n         Prototype prototype1 = prototype.clone();\n \n         System.out.println(\"=== if any of the following varies, then it is shallow clone ===\");\n \n         //基本类型是深拷贝\n         prototype1.setId(2);\n         System.out.println(\"the old id is 3, and now it is \" + prototype.getId());\n         //引用类型是浅拷贝\n         prototype1.getBar().setName(\"newbar\");\n         System.out.println(\"the old bar is {bar}, and now it is {\" + prototype.getBar().getName()+\"} <==\");\n \n         //序列化来实现深拷贝\n         //Prototype 类以及 Bar 类都要实现 Serializable 接口\n         prototype.getBar().setName(\"bar\"); //恢复旧名字\n         Prototype prototype2 = prototype.deepClone();\n         prototype2.getBar().setName(\"newbar\");\n         System.out.println(\"the old bar is {bar}, and now it is {\"+prototype.getBar().getName()+\"}\");\n     }\n }\n```\n\n以下是输出结果\n\n```text\n=== if any of the following varies, then it is shallow clone ===\nthe old id is 3, and now it is 3\nthe old bar is {bar}, and now it is {newbar} <==\nthe old bar is {bar}, and now it is {bar}\n```\n\n可以观察到: 进行浅拷贝后, 若通过新的对象改变对象内部的引用类型对象, 原有对象的内部的引用对象也会做出相同的改变. 之所以会发生这样的事情, 是因为此时两个对象内部包含的对象是同一个.\n\n用序列化可以实现深拷贝.\n\n在上面的代码中, Prototype类和Bar类都实现了了Serializable接口.\n\n使用Prototype类中的deepClone方法得到的对象是深拷贝对象.\n\n> 如果类的结构不至于太复杂, 对于引用型对象来说, 可以通过使用 `new` 关键字来实现深拷贝. "
    },

    {
        "id": "30e886f7-a212-4912-8b7c-9130f7331443",
        "title": "软件版本号定义规范",
        "category": null,
        "date": { "year": 2021, "month": 1, "day": 2 },
        "peek": "本文介绍了软件版本号定义规范",
        "content": "### GNU 风格的版本号命名格式\n\n> **版本格式**：主版本号.子版本号[.修正版本号[.编译版本号]]\n\n**主版本号**：做了不兼容的 API 修改\n\n**子版本号**：做了向下兼容的功能性新增\n\n**修订号**：做了向下兼容的问题修正\n\n**编译版本号**：编译器在编译过程中自动生成；其中包含日期版本号和希腊字母版本号\n\n##### 日期版本号 和 希腊字母版本号\n\n**日期版本号**：记录修改的当前日期\n\n**希腊字母版本号**：标注当前版本的软件处于哪个开发阶段\n\n- $\\alpha$：**内测版** - 此版本表示该软件在此阶段主要是以实现软件功能为主，通常只在软件开发者内部交流，或者专业测试人员测试用，一般而言，该版本软件的Bug较多，需要继续修改。\n\n- $\\beta$：**公测版** - 该版本相对于 $\\alpha$ 版已有了很大的改进，消除了严重的错误，但还是存在着一些缺陷，需要经过多次测试来进一步消除，此版本主要的修改对像是软件的UI，供专业爱好者大规模测试用。\n\n- RC（Release Candidate）：**候选版本** - 该版本已经相当成熟了，完成全部功能并清除大部分的BUG，基本上不存在导致错误的BUG，与即将发行的正式版相差无几。\n\n- Release：**正式版** - 最终交付用户使用的一个版本。一般情况下，Release不会以单词形式出现在软件封面上，取而代之的是符号(R)。\n \n举例：1.1.1.051021_beta\n\n> 参考资料: https://www.jianshu.com/p/9a25e8eae32e\n\n"
    },

    {
        "id": "80463840-73b7-4346-99d1-6d81e0f826cd",
        "title": "Java 序列化和反序列化",
        "category": "Java",
        "date": { "year": 2021, "month": 1, "day": 2 },
        "peek": "一直对 Java 中的序列化和反序列化有疑惑：序列化和反序列化有什么用？",
        "content": "一直对 Java 中的序列化和反序列化有疑惑：序列化和反序列化有什么用？怎么进行对象的序列化和反序列化？被序列化的类代码中的 serialVersionUID 有什么用？下面的这篇来自CodeSheep的文章很好地回答了这些问题。\n\n我来做一个小小的总结：\n\n**序列化和反序列化有什么用**？\n序列化可以把一个对象转换成字节序列，然后存储在磁盘中。反序列化顾名思义就是序列化的一个逆过程，即将一个字节序列还原成一个对象。那么为什么要把一个对象以字节序列的格式存储在磁盘中呢？那是因为，首先，我们可以永久地存储一个对象的信息；其次，字节序列可以用于其他方面的传输，例如网络运输（这个还有点不大懂）。\n\n**怎么使用**？\n代码略过～\nIO流的知识是必不可少的，毕竟涉及到文件的读写操作。其中需要的类主要是：File，ObjectInputStream，ObjectOutputStream，FileInputStream，FileOutputStream. \n其中，被序列化的对象的类必须实现 Serializable 接口（这是一个标记借口）。然后将这个对象传入ObjectOutputStream 的 writeObject 方法中（ObjectOutputStream 对象的构造略过～）。这样一来，这个对象就存储在磁盘中了。反序列化则需要创建一个 ObjectInputStream （同样略过构造），然后调用 readObject 方法。\n\n**SerialVersionUID 有什么用**？\n首先考虑一下下面的场景：当一个对象被序列化且存储在磁盘中后，如果此时这个类的代码被更改，那么很好想象会有这么一个结果，那就是这个字节序列无法被还原成一个对象，而且会有错误信息告诉我们，版本不一样。\n有两个事实：\n1. serialVersionUID 是序列化前后唯一的标识符\n2. 如果没有显式地定义一个 serialVersionUID，那编译器就会为它自动声名一个。\n\n在反序列化时，如果字节序列中的 serialVersionUID 和被序列化的类的 serialVersionUID 不同，就无法被反序列化，这也就是之前描述的情况。\n如果类中的代码发生了改变，那么这个类的 serialVersionUID 也会发生改变。所以，为了 serialVersionUID 的确定性，最好显式地定义一个值。\n\n这篇文章中还有很多关于 SerialVersionUID 的技术细节，包括静态常量和transient关键字，单例模式使用实现序列化不能保证单例的问题，序列化的受控和加强。文章语言通俗易懂，值得一读。\n\n如果我的总结有错误，请大家指出。\n\n文章网址在这里👇\nhttps://b23.tv/IcHB4y"
    },

    {
        "id": "8e2abc5d-6901-43c0-b070-5645d2ee0853",
        "title": "做事六部曲",
        "category": null,
        "date": { "year": 2021, "month": 1, "day": 2 },
        "peek": "六步曲",
        "content": "> 2020-11-10 深圳\n\n### 六步曲\n1. 设定目标\n2. 拆分事项\n3. 分析条件\n4. 达到条件\n5. 完成事项\n6. 完成目标\n\n### 说明\n- 前三步都是**思考**的过程.\n- 第三步中的条件根据第二步的各个事项具体分析.\n- 第四步包含 \n\t1. 思考达到(满足)这些条件的方法 \n\t2. 按照这些方法去执行\n- 满足了条件以后就去执行第二步中列出的事项.\n- 第五步可以和第四步的 ii 同时进行\n- 在执行的过程中可以添加第四步中的 i\n- 前四步是 **准备** 工作, 也就是思考的过程, 这里就能体现出思考的周全性\n- 第五步才是执行的过程, 是体现执行力的步骤, 如果前四步准备充分, 第五步不应该有什么问题.\n"
    },

    {
        "id": "14214023-8701-4e68-aa0b-c462f4f54498",
        "title": "XOR 链表",
        "category": "C",
        "date": { "year": 2021, "month": 1, "day": 2 },
        "peek": "很久以前写的 Xor 链表. 纪念一下",
        "content": "> 2020-10-26 深圳\n\n很久以前写的 Xor 链表. 纪念一下.\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#define INDEXERROR -1\n\nstruct Node {\n    int key;\n    intptr_t xorptrval;\n};\n\ntypedef struct Node *NodePtr;\n\nunsigned int *intp2ptr(intptr_t intp) {\n    return (unsigned int *) intp;\n}\n\nintptr_t xor(intptr_t a, intptr_t b) { return a^b; }\n\nNodePtr createNodePtr(int key) {\n    NodePtr node = (NodePtr) malloc(sizeof(struct Node));\n    node->key = key;\n    node->xorptrval = 0;\n    return node;\n}\n\nNodePtr add(NodePtr root, const NodePtr z) {\n    if (root == NULL) {\n        root = z;\n        return root;\n    }\n    \n    int count = 1;\n    NodePtr current = root;\n    NodePtr old = root;\n    intptr_t currentVal = current->xorptrval;\n    while (currentVal!=0 && currentVal!=(intptr_t) old) {\n        NodePtr temp = current;\n        if (count) {\n            current = intp2ptr(currentVal);\n            count=0;\n        } else {\n            intptr_t nextintp = ((intptr_t)old) ^ currentVal;\n            current = intp2ptr(nextintp);\n        }\n        old = temp;\n        currentVal = current->xorptrval;\n    }\n    current->xorptrval = (current->xorptrval) ^ (intptr_t)z;\n    z->xorptrval = (intptr_t) current;\n    return root;\n}\n\nint get(NodePtr root, int index) {\n    int flag = 1;\n    NodePtr current = root;\n    NodePtr old = root;\n    intptr_t currentVal = current->xorptrval;\n    while (index>0 && currentVal!=0 && currentVal!=(intptr_t) old) {\n        NodePtr temp = current;\n        if (flag) {\n            current = intp2ptr(currentVal);\n            flag=0;\n        } else {\n            intptr_t nextintp = ((intptr_t)old) ^ currentVal;\n            current = intp2ptr(nextintp);\n        }\n        old = temp;\n        currentVal = current->xorptrval;\n        index--;\n    }\n    if (index!=0) {\n        printf(\"Error: Index out of range.\\n\");\n        return INDEXERROR;\n    }\n    return current->key;\n}\n\nvoid iterate(NodePtr root) {\n    if (root==NULL) {\n        printf(\"Empty List. \\n\");\n        return;\n    }\n    NodePtr current = root;\n    NodePtr old = root;\n    int count=1;\n    intptr_t currentVal = current->xorptrval;\n    while (currentVal!=(intptr_t) old) {\n        printf(\"%d \", current->key);\n        NodePtr temp = current;\n        if (count) {\n            current = intp2ptr(currentVal);\n            count=0;\n        } else {\n            intptr_t nextintp = ((intptr_t)old) ^ currentVal;\n            current = intp2ptr(nextintp);\n        }\n        old = temp;\n        currentVal = current->xorptrval;\n    }\n    \n    printf(\"%d\\n\", current->key);\n}\n\nint main(int argc, char const *argv[])\n{\n    NodePtr root = NULL;\n    \n    NodePtr node1 = createNodePtr(1);\n    root = add(root, node1);\n    \n    NodePtr node2 = createNodePtr(3);\n    root = add(root, node2);\n    \n    NodePtr node3 = createNodePtr(2);\n    root = add(root, node3);\n    \n    NodePtr node4 = createNodePtr(4);\n    root = add(root, node4);\n    \n    NodePtr node5 = createNodePtr(5);\n    root = add(root, node5);\n\n    NodePtr node6 = createNodePtr(7);\n    root = add(root, node6);\n    \n    iterate(root);\n    \n    printf(\"%d\\n\", get(root, -1));\n    printf(\"%d\\n\", get(root, 5));\n    return 0;\n}\n\n/*\n root (node1)               node2                node3                  node4\n ----------------------------------------------------------------------------------\n null                          -                    -                          -            add 1\n 1,(intp) 0            2,     0                      -                        -            add 2\n 1,(intp) *node2       2,(intp) *node1       3,     0                           -            add 3\n 1,(intp) *node2       2,  n1 ^ n3             3, (intp) *node2     4,      0            add 4\n 1,(intp) *node2       2,  n1 ^ n3             3,  n2 ^ n4            4, (intp) *node3\n \n */\n```"
    },

    {
        "id": "f0d25ccb-c5c9-4f84-8a09-222140725316",
        "title": "解决MySQL不需要密码就能登录的问题",
        "category": "MySQL",
        "date": { "year": 2021, "month": 1, "day": 2 },
        "peek": "核心命令",
        "content": "> 2021-01-02 佛山\n\n## 解决方法\n\n### 核心命令\n```bash\nupdate user set plugin = \"mysql_native_password\";\n```\n\n### 具体流程\n```bash\n> use mysql;\n> update user set authentication_string=password(\"你的密码\") where user='root'; \n> update user set plugin=\"mysql_native_password\"; \n> flush privileges;\n> exit;\n```\n\n## 以前的文章\n\nThis is specific to Ubuntu 18.04 LTS and MySQL 5.x Followed this link Follow everything from here onwards:\n\n```shell\nsudo mysql_secure_installation\nsudo mysql\n```\nOnce logged into MySQL, then from the MySQL prompt execute these commands:\n\n```sql\nALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'password';\nFLUSH PRIVILEGES;\n```\n\nNow verify that the table has the password for the root\n\n```sql\nSELECT user,authentication_string,plugin,host FROM MySQL.user;\n```\n\nThis solved my issue and now I am able to log in.\n\n## 参考资料\n\n[Source Link](https://stackoverflow.com/questions/11922323/java-sql-sqlexception-access-denied-for-user-rootlocalhost-using-password)"
    },

    {
        "id": "c7276000-f61d-4e74-994c-ef41294a9bfc",
        "title": "阻止在移动端点击输入框时浏览器自动放大\n",
        "category": "CSS",
        "date": { "year": 2020, "month": 11, "day": 5 },
        "peek": "之所以在移动端点击输入框会自动放大, 是因为移动端的浏览器有如下机制",
        "content": "> 2020-11-05 深圳\n\n之所以在移动端点击输入框会自动放大, 是因为移动端的浏览器有如下机制: 当字号小于 16px 的输入框被点击的时候, 就会自动放大.\n\n所以解决方法显而易见了: 在输入框的CSS添加: font-size: 16px. 其实 16px 还是一个非常适中的大小了."
    },

    {
        "id": "80963560-a3c9-4115-a194-2c499110fac9",
        "title": "对于很长的方法第一点经验心得",
        "category": null,
        "date": { "year": 2020, "month": 10, "day": 26 },
        "peek": "在平时的代码编写中, 经常会遇见因为业务逻辑复杂而导致长方法的情况",
        "content": "> 2020-10-26 深圳\n\n在平时的代码编写中, 经常会遇见因为业务逻辑复杂而导致长方法的情况, 其中, 多重嵌套的 `if` 分支会导致方法不容易读懂且占用大量竖直空间. \n\n我认为可以将该部分的代码提取出来, 包装在一个私有方法中, 然后用有意义的方法名称概括该部分的业务内容.\n\n这样一来, 不仅提高了方法的可读性, 而且使得一个方法的长度大大缩小."
    },

    {
        "id": "daafbd32-3672-46bd-9d00-91e5ea2f75db",
        "title": "SpringBoot 自定义Json反序列化",
        "category": "Spring",
        "date": { "year": 2020, "month": 10, "day": 23 },
        "peek": "在项目开发的过程中, 需要验证所传入的参数类型必须为整数型. 当传入非法类型时, 需要报相应的错误",
        "content": "> 2020-10-23 深圳\n\n## 问题\n在项目开发的过程中, 需要验证所传入的参数类型必须为整数型. 当传入非法类型时, 需要报相应的错误. 比方说, 当传入一个无法转换为整数的字符串类型数据时, 就要报错. 在一般情况下, 直接使用验证框架就可以完成. 在声明model类的字段后, 加上相应的注解即可. 但是有一个情况是这个方法无法处理的: 当传入一个小数类型的时候, SpringBoot会自动把这个小数转换成整数类型.\n\n## 解决方法\n使用自定义的 JSON 转换器.\n\n假如有下面的控制器类. 这个控制器中的 `bar` 方法接收一个 `Foo` 类型的参数\n```java\n@RestController\npublic class MyController {\n    @GetMapping\n    public String bar(@RequestParam Foo foo) {\n        return \"\"+bar;\n    }\n}\n```\n\n`Foo` 类中有一个整数类型的字段.\n```java\npublic class Foo {\n    @NotNull(message = \"value can not be null\")\n    private Integer value;\n\n    @JsonDeserialize(using = ConvertIntegerType.class)\n    public void setValue(Integer value) {\n        this.value = value;\n    }\n}\n```\n\n自定义的转换类型\n```java\npublic class ConvertIntegerType extends JsonDeserializer<Integer> {\n    @Override\n    public Integer deserialize(JsonParser jsonParser, DeserializationContext ctxt) throws IOException, JsonProcessingException {\n        if (jsonParser != null && jsonParser.getText()!=nll && jsonParser.getText().length()>0) {\n            return Integer.parseInt(jsonParser.getText());\n        } else {\n            return null;\n        }\n    }\n}\n```\n\n这样, 当输入一个小数类型的数据时, 就能够正常报错了.\n"
    },

    {
        "id": "75fa541e-b910-4a9f-9d81-cadacccbdba6",
        "title": "编写 编辑 接口时的技巧",
        "category": null,
        "date": { "year": 2020, "month": 10, "day": 23 },
        "peek": "当编写编辑接口的时候, 如果有以下的情况出现, 就会导致自测流程非常痛苦",
        "content": "> 2020-10-23\t深圳\n\n## 问题\n当编写**编辑**接口的时候, 如果有以下的情况出现, 就会导致自测流程非常痛苦---需要在数据库查看工具, 测试工具(我的是Postman), 和IDE之间来回切换, 而且还要很辛苦地对比新旧数据. 其实在两个窗口之间来回切换还是可以接受的.\n- 需要编辑的字段极多\n- 需要记录历史记录\n- 多状态之间的切换\n\n尤其是最后两点同时出现时最为棘手. \n\n## 解决方法\n在每个 DAO 操作的地方输出日志.\n\n没错, 就是这么简单.\n"
    },

    {
        "id": "441738b0-dd29-4852-9da3-e991e0de505f",
        "title": "Spring AOP 使用",
        "category": "Spring",
        "date": { "year": 2020, "month": 10, "day": 22 },
        "peek": "项目中需要为一些操作添加历史记录",
        "content": "> 2020-10-22\t\t深圳\n\n### 前言\n项目中需要为一些操作添加历史记录\n\n#### 第一步: 导包\n```html\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-aop</artifactId>\n    <version>2.1.2.RELEASE</version>\n</dependency>\n```\n\n#### 第二步: 自定义注解\n```java\n@Target(ElementType.METHOD)\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface InsertRecord {\n    int ONLINE = 3;\n    int OFFLINE = 4;\n    int type();\n}\n```\n\n#### 第三步: 编写AOP代码\n```java\n@Component\n@Aspect\n@Slf4j\npublic class InsertRecordAspect {\n    AdMapper adMapper;\n    ManagerService managerService;\n\n    @Autowired\n    public void setManagerService(ManagerService managerService) {\n        this.managerService = managerService;\n    }\n\n    @Autowired\n    public void setAdMapper(AdMapper adMapper) {\n        this.adMapper = adMapper;\n    }\n\n    @Pointcut(\"@annotation(com.konka.pettrackeradmin.service.impl.ad.aop.InsertRecord)\")\n    public void match() {}\n\n    /**\n     * 要求连接点方法的第一个参数是广告id\n     * @param joinPoint 连接点\n     * @param insertRecord 获取类型\n     */\n    @AfterReturning(\"match()&&@annotation(insertRecord)\")\n    public void addRecord(JoinPoint joinPoint, InsertRecord insertRecord) {\n        int adId = (Integer) joinPoint.getArgs()[0];\n        log.info(\"adId: {}, type: {}\", adId, insertRecord.type());\n        adMapper.insertHistory(insertRecord.type(), adId, managerService.getManagerId());\n    }\n}\n```\n\n#### 第四步: 注解业务代码\n```java\n@InsertRecord(type = InsertRecord.ONLINE)\npublic String setOnline(int adId) {\n    ...\n}\n```"
    },

    {
        "id": "25a68461-b89c-4186-aba6-318b8355f730",
        "title": "Java 利用反射调用私有方法",
        "category": "Java",
        "date": { "year": 2020, "month": 10, "day": 14 },
        "peek": "今天需要测试一个服务类的私有方法, 所以需要在测试类中调用该私有方法.",
        "content": "> 2020-10-14 深圳\n\n今天需要测试一个服务类的私有方法, 所以需要在测试类中调用该私有方法.\n服务类中有这样的一个方法:\n```java\nprivate Map<String, List<String>> findDifference(List<String> oldList, List<String> newList) {\n    List<String> removedList = new ArrayList<>();\n    List<String> addedList = new ArrayList<>();\n    for (String newStr:newList) {\n        if (!oldList.contains(newStr)) {\n            addedList.add(newStr);\n        }\n    }\n    for (String oldStr:oldList) {\n        if (!newList.contains(oldStr)) {\n            removedList.add(oldStr);\n        }\n    }\n    Map<String, List<String>> map = new HashMap<>();\n    map.put(\"removed\", removedList);\n    map.put(\"added\", addedList);\n    return map;\n}\n```\n编写测试类:\n```java\npackage ca.zhejianglao.service;\n\nimport ca.zhejianglao.service.impl.AdServiceImpl;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Map;\n\npublic class AdServiceImplTest {\n\n    private AdServiceImpl adService;\n    private Method method;\n\n    @Before\n    public void init() throws NoSuchMethodException {\n        adService = new AdServiceImpl();\n        method = adService.getClass().getDeclaredMethod(\"findDifference\", List.class, List.class);\n        method.setAccessible(true);\n    }\n\n    @Test\n    public void test1() throws InvocationTargetException, IllegalAccessException {\n        Map<String, List<String>> map = (Map<String, List<String>>) method.invoke(adService,\n                Arrays.asList(\"app1\"),\n                Arrays.asList(\"app1\", \"app2\")\n        );\n        Assert.assertArrayEquals(new String[] {}, map.get(\"removed\").toArray());\n        Assert.assertArrayEquals(new String[] {\"app2\"}, map.get(\"added\").toArray());\n    }\n\n    @Test\n    public void test2() throws InvocationTargetException, IllegalAccessException {\n        Map<String, List<String>> map = (Map<String, List<String>>) method.invoke(adService,\n                Arrays.asList(\"app1\", \"app3\"), \n                Arrays.asList(\"app1\", \"app2\")  \n        );\n        Assert.assertArrayEquals(map.get(\"removed\").toArray(),\n                new String[] {\"app3\"}); \n        Assert.assertArrayEquals(map.get(\"added\").toArray(),\n                new String[] {\"app2\"}); \n    }\n}\n```\n\n### 总结\n- 获取 `Class` 对象\n- 调用该对象的 `getDeclaredMethod()` 方法来获取 `Method` 对象\n  - 传入参数\n    - 方法名称\n    - 参数类型\n- 将 `accessible` 设为 `true`\n\n```java\nmethod.setAccessible(true);\n```\n- 调用 `Method` 对象的 `invoke()` 方法来调用该私有方法\n  - 传入参数\n    - 对象\n    - 参数数值\n\n\n"
    },

    {
        "id": "31df54b3-cfba-4194-a844-a977cc422e1d",
        "title": "SpringBoot 整合 Mybatis",
        "category": "Spring",
        "date": { "year": 2020, "month": 8, "day": 17 },
        "peek": "本文介绍了如何在 SpringBoot 中整合 MyBatis",
        "content": "> 深圳 20200817\n>\n> 开发环境: mysql 8.0.21, maven\n\n### 逆向工程\n\n#### 导包\n\n导包是一个很简单的环节\n\n除了一些其他功能的包, **与本主题相关的包为**\n\n1. **mysql 包**\n2. **spring 整合 mybatis 的包**\n\n```xml\n<dependency>\n\t<groupId>mysql</groupId>\n\t<artifactId>mysql-connector-java</artifactId>\n\t<scope>runtime</scope>\n</dependency>\n\t\t\n<dependency>\n\t<groupId>org.mybatis.spring.boot</groupId>\n\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t<version>2.1.3</version>\n</dependency>\n```\n\n#### 生成代码的 plugin \n\n```xml\n<plugin>\n\t<groupId>org.mybatis.generator</groupId>\n  <artifactId>spring-boot-maven-plugin</artifactId>\n  <version>1.3.5</version>\n  <configuration>\n    <configurationFile>src/main/resources/generatorConfiguration.xml</configurationFile>\n    <verbose>true</verbose>\n  </configuration>\n  <executations>\n    <executation>\n      <goals>\n        <goal>generate</goal>\n      </goals>\n    </executation>\n  </executations>\n  <dependencies>\n    <dependency>\n      <groupId>mysql</groupId>\n      <artifactId>mysql-connector-java</artifactId>\n      <version>8.0.21</version>\n      <scope>runtime</scope>\n    </dependency>\n  </dependencies>\n</plugin>\n```\n\n#### 写配置文件\n\n定义数据源 **generatorConfiguration.properties**\n\n(这个文件可以省略, **但是省略的话需要在下面的xml文件中写入数据源的信息**)\n\n```properties\njdbc.url = jdbc:mysql://localhost:3306/demo\njdbc.driver = com.mysql.cj.jdbc.Driver\njdbc.username = root\njdbc.password = password\n```\n\ngeneratorConfiguration.xml\n\n```xml\n<!DOCTYPE generatorConfiguration PUBLIC\n        \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n\n    <properties resource=\"generatorConfiguration.properties\"/><!--联结.properties文件👆-->\n\n    <context id=\"default\" targetRuntime=\"MyBatis3\">\n        <jdbcConnection driverClass=\"${jdbc.driver}\"\n                        connectionURL=\"${jdbc.url}\"\n                        userId=\"${jdbc.username}\"\n                        password=\"${jdbc.password}\"/>\n        <javaModelGenerator targetPackage=\"cn.com.wd4.demo.model\" targetProject=\"src/main/java\"/>\n        <sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"/>\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.com.wd4.demo.mapper\" targetProject=\"src/main/java\"/>\n        \n        <table schema=\"demo\" tableName=\"manager\" domainObjectName=\"Manager\"\n               enableCountByExample=\"false\" enableUpdateByExample=\"false\"\n               enableDeleteByExample=\"false\" enableSelectByExample=\"false\"\n               selectByExampleQueryId=\"false\"/>\n    </context>\n</generatorConfiguration>\n```\n\n\n\n配置完成\n\n\n\n#### 运行生成\n\n双击 generate 生成代码.\n\n![结果](img/articles/springboot_mybatis.png)\n\n### 使用\n\n#### application.properties 中写入.xml文件路径\n\n```properties\nmybatis.mapperLocations=classpath:mapper/*.xml\n```\n\n\n\n#### 加注解\n\n加注解 `@Mapper` 到 XXXMapper.java中\n\n```java\n@Mapper\npublic interface ManagerMapper {\n    /**\n     * This method was generated by MyBatis Generator.\n     * This method corresponds to the database table manager\n     *\n     * @mbg.generated Mon Aug 17 10:15:47 CST 2020\n     */\n    int deleteByPrimaryKey(Integer id);\n\n  ...\n}\n```\n\n\n\n#### 使用\n\n可以在代码中使用该 Mapper 类\n\n##### @Autowired\n\n```java\n@Autowired private ManagerMapper managerMapper;\n```\n\n##### 调用方法\n\n```java\nManager manager = managerMapper.selectByPrimaryKey(id);\n```\n\n\n\n\n\n### 完整代码\n\n#### pom.xml\n\n```xml\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n\txsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\">\n\t<modelVersion>4.0.0</modelVersion>\n\t<parent>\n\t\t<groupId>org.springframework.boot</groupId>\n\t\t<artifactId>spring-boot-starter-parent</artifactId>\n\t\t<version>2.3.3.RELEASE</version>\n\t\t<relativePath/> <!-- lookup parent from repository -->\n\t</parent>\n\t<groupId>cn.com.wd4</groupId>\n\t<artifactId>demo</artifactId>\n\t<version>0.0.1-SNAPSHOT</version>\n\t<name>demo</name>\n\t<description>Demo project for Spring Boot</description>\n\n\t<properties>\n\t\t<java.version>11</java.version>\n\t</properties>\n\n\t<dependencies>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-web</artifactId>\n\t\t</dependency>\n\n\t\t<dependency>\n\t\t\t<groupId>mysql</groupId>\n\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t<scope>runtime</scope>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.projectlombok</groupId>\n\t\t\t<artifactId>lombok</artifactId>\n\t\t\t<optional>true</optional>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.mybatis.spring.boot</groupId>\n\t\t\t<artifactId>mybatis-spring-boot-starter</artifactId>\n\t\t\t<version>2.1.3</version>\n\t\t</dependency>\n\t\t<dependency>\n\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t<artifactId>spring-boot-starter-test</artifactId>\n\t\t\t<scope>test</scope>\n\t\t\t<exclusions>\n\t\t\t\t<exclusion>\n\t\t\t\t\t<groupId>org.junit.vintage</groupId>\n\t\t\t\t\t<artifactId>junit-vintage-engine</artifactId>\n\t\t\t\t</exclusion>\n\t\t\t</exclusions>\n\t\t</dependency>\n\t</dependencies>\n\n\t<build>\n\t\t<plugins>\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.springframework.boot</groupId>\n\t\t\t\t<artifactId>spring-boot-maven-plugin</artifactId>\n\t\t\t</plugin>\n\n\t\t\t<plugin>\n\t\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t\t<artifactId>mybatis-generator-maven-plugin</artifactId>\n\t\t\t\t<version>1.3.5</version>\n\t\t\t\t<configuration>\n\t\t\t\t\t<configurationFile>src/main/resources/generatorConfiguration.xml</configurationFile>\n\t\t\t\t\t<verbose>true</verbose>\n\t\t\t\t</configuration>\n\t\t\t\t<executions>\n\t\t\t\t\t<execution>\n\t\t\t\t\t\t<goals>\n\t\t\t\t\t\t\t<goal>generate</goal>\n\t\t\t\t\t\t</goals>\n\t\t\t\t\t</execution>\n\t\t\t\t</executions>\n\t\t\t\t<dependencies>\n\t\t\t\t\t<dependency>\n\t\t\t\t\t\t<groupId>org.mybatis.generator</groupId>\n\t\t\t\t\t\t<artifactId>mybatis-generator-core</artifactId>\n\t\t\t\t\t\t<version>1.3.5</version>\n\t\t\t\t\t</dependency>\n\t\t\t\t\t<dependency>\n\t\t\t\t\t\t<groupId>mysql</groupId>\n\t\t\t\t\t\t<artifactId>mysql-connector-java</artifactId>\n\t\t\t\t\t\t<version>8.0.21</version>\n\t\t\t\t\t\t<scope>runtime</scope>\n\t\t\t\t\t</dependency>\n\t\t\t\t</dependencies>\n\t\t\t</plugin>\n\t\t</plugins>\n\t</build>\n\n</project>\n\n```\n\n#### generatorConfiguration.xml\n\n```xml\n<!DOCTYPE generatorConfiguration PUBLIC\n        \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\">\n<generatorConfiguration>\n\n    <properties resource=\"generatorConfiguration.properties\"/>\n\n    <context id=\"default\" targetRuntime=\"MyBatis3\">\n        <jdbcConnection driverClass=\"${jdbc.driver}\"\n                        connectionURL=\"${jdbc.url}\"\n                        userId=\"${jdbc.username}\"\n                        password=\"${jdbc.password}\"/>\n        <javaModelGenerator targetPackage=\"cn.com.wd4.demo.model\" targetProject=\"src/main/java\"/>\n        <sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"/>\n        <javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"cn.com.wd4.demo.mapper\" targetProject=\"src/main/java\"/>\n        \n        <table schema=\"demo\" tableName=\"manager\" domainObjectName=\"Manager\"\n               enableCountByExample=\"false\" enableUpdateByExample=\"false\"\n               enableDeleteByExample=\"false\" enableSelectByExample=\"false\"\n               selectByExampleQueryId=\"false\"/>\n    </context>\n</generatorConfiguration>\n```\n\n#### generatorConfiguration.properties\n\n```properties\njdbc.driver = com.mysql.cj.jdbc.Driver\njdbc.url = jdbc:mysql://127.0.0.1:3306/demo?useUnicode=true&characterEncoding=utf-8\njdbc.username = root\njdbc.password = password\n```\n\n#### application.properties\n\n```properties\nspring.datasource.url=jdbc:mysql://localhost:3306/demo\nspring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver\nspring.datasource.username=root\nspring.datasource.password=password\n\nserver.port=80\n\nmybatis.mapperLocations=classpath:mapper/*.xml\n```\n\n"
    },

    {
        "id": "1e084713-e484-4629-b5f5-ef221647c5a1",
        "title": "Java IO 流 - FileWriter",
        "category": "Java",
        "date": { "year": 2020, "month": 7, "day": 6 },
        "peek": "如题所示",
        "content": "> 2020/07/06 大雨 上海建国宾馆\n\n```java\n/**\n* Writes a string.\n*\n* @param  str\n*         String to be written\n*\n* @throws  IOException\n*          If an I/O error occurs\n*/\npublic void write(String str) throws IOException;\n```\n\n\n\n> 2020/07/08 阵雨 上海\n\n**使用示例**\n\n\\# 用以下方式构造的writer对象在每次写文件会覆盖原有的内容, 如果要在原来文件的内容上写入新的内容, 则需要在构建writer对象时传入第二个参数 `true`.\n\n\\# 如果文件不存在, 则会创建新文件.\n\n```java\nFile file = new File(\"masochism.txt\");\nFileWriter writer = null;\n\ntry {\n    writer = new FileWriter(file);\n    writer.write(\"I'm a sadism, haha\"); // 将该字符串写入文件\n    writer.append(\"more and more\"); // 再写一些\n} catch (IOException e) {\n    e.printStackTrace();\n} finally {\n    if (writer!=null) {\n        try {\n            writer.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n```\n\n以上代码会在项目根目录下创建文件 masochism.txt, 然后写入内容 \"I'm a ...\"."
    },

    {
        "id": "0350eece-2422-4b68-8ee0-f53a5bf6cb3c",
        "title": "Java IO 流 - FileReader",
        "category": "Java",
        "date": { "year": 2020, "month": 7, "day": 6 },
        "peek": "如题所示",
        "content": "> 2020/07/06 大雨 上海\n\n```java\n/**\n* 一个字符一个字符地读, 如果是流的末尾, 返回-1, 否则返回一个字符的值.\n**/\npublic int read() throws IOException;\n```\n\n```java\nFileReader reader = null;\ntry {\n    File file = new File(\"hello1.txt\");\n    reader = new FileReader(file);\n\n    int data;\n    while ((data = reader.read())!=-1) {\n        System.out.print((char) data);\n    }\n} catch (FileNotFoundException e) {\n    Logger.getGlobal().severe(\"file \"+file.getName()+\" (\"+file.getAbsolutePath()+\") doesn't exist.\");\n    e.printStackTrace();\n} catch (IOException e) {\n    Logger.getGlobal().severe(\"can't read from file \"+file.getName()+\" (\"+file.getAbsolutePath()+\").\");\n    e.printStackTrace();\n} finally {\n    try {\n        if (reader!=null)\n            reader.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n```java\n/**\n* 将数据读入一个数组中. 在 得到输入前|发生IO错误前|到达流的结尾之前, 这个方法会阻塞.\n* \n* @param cbuf 目标缓存数组\n*\n* @return 读到的字符的数量, 如果到达流的尾部, 返回 -1\n*\n* @exception IOException 如果发生IO错误\n**/\npublic int read(char cbuf[]) throws IOException;\n```\n\n```java\nFileReader reader = null;\ntry {\n    File file = new File(\"hello1.txt\");\n    reader = new FileReader(file);\n\n    char[] cbuf = new char[5];\n    while ((reader.read(cbuf))!=-1) {\n        System.out.print(new String(cbuf));\n    }\n} catch (FileNotFoundException e) {\n    Logger.getGlobal().severe(\"file \"+file.getName()+\" (\"+file.getAbsolutePath()+\") doesn't exist.\");\n    e.printStackTrace();\n} catch (IOException e) {\n    Logger.getGlobal().severe(\"can't read from file \"+file.getName()+\" (\"+file.getAbsolutePath()+\").\");\n    e.printStackTrace();\n} finally {\n    try {\n        if (reader!=null)\n            reader.close();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}\n```\n\n\n\n```java\npublic int read(char cbuf[], int off, int len) throws IOException;\n```\n\n这个方法不大用的."
    },

    {
        "id": "63457aec-3c1d-4c6e-ace8-8b2f27f326a7",
        "title": "Java IO 流 - File 类",
        "category": "Java",
        "date": { "year": 2020, "month": 7, "day": 6 },
        "peek": "File 类的一个对象, 代表一个文件或者目录, 在 java.io 包中.",
        "content": "> 创建于 2020-03-07\n\n`File` 类的一个对象, 代表一个文件或者目录, 在 `java.io` 包中.\n\n### 1 构造器\n\n```java\nFile(String pathname);\n// pathname 如果是相对路径, 那么该相对路径指的是当前module的路径\nFile(File parent, String child);\nFile(String parent, String child);\n```\n\n### 2 常量\n\n##### 路径分隔符\n\n```java\npublic static final String separator; //根据操作系统, 动态地提供分隔符.\n```\n\n> File.java  源码\n>\n> public static final char separatorChar = fs.getSeparator();\n> public static final String separator = \"\" + separatorChar;\n\n### 3 常用方法\n\n##### 3.1 获取功能\n\n```java\npublic String getAbsolutePath(); \npublic String getPath();\npublic String getName();\npublic String getParent(); // 获取上层文件目录路径. 若无, 则返回 null.\npublic long length(); // 获取文件长度 (字节数). 不能获取目录的长度.\npublic long lastModified(); //获取最后一次修改的时间 (毫秒值).\n\npublic String[] list(); //获取指定目录下的所有文件或者目录的名称 String 数组.\npublic File[] listFIles(); //获取指定目录下的所有文件或者文件目录的 File 数组\n```\n\n##### 3.2 判断功能\n\n```java\npublic boolean isDiectory();\npublic boolean isFile();\npublic boolean exists();\npublic boolean canRead();\npublic boolean canWrite();\npublic isHidden();\n```\n\n##### 3.3 创建/删除 功能\n\n```java\npublic boolean createNewFile() throws IOException; // 若文件存在, 就不创建, 返回 false\npublic boolean mkdir(); // 若目录存在, 就不创建, 返回 false;\npublic boolean mkdirs(); \n\npublic boolean delete(); // 不可以删除有文件的目录; 直接抹掉数据, 不会到垃圾桶\n```\n"
    },

    {
        "id": "6c870eb9-e21c-4389-8dc0-b8fca9a538a0",
        "title": "Java IO 流 - 总览",
        "category": "Java",
        "date": { "year": 2020, "month": 7, "day": 6 },
        "peek": "本文介绍了 Java IO 的总览, 使得在学习之前有一个全局的认识",
        "content": "> 2020-07-06 大雨 上海\n>\n> https://www.bilibili.com/video/BV1Qb411g7cz?p=584\n\n\n\n**输入**: 读取外部数据到内存中\n\n**输出**: 将程序数据输出到磁盘, 光盘等设备中\n\n\n\n### 流的分类\n\n- 按**操作数据单位**, 可以分为: 字节流 (8bit = 1byte), 字符流 (16bit = 1char);\n\n- 按**数据流的流向**, 可以分为: 输入流, 输出流\n\n- 按**流的角色**, 可以分为: 节点流, 处理流\n\n|        | 字节流       | 字符流 |\n| ------ | ------------ | ------ |\n| 输入流 | InputStream  | Reader |\n| 输出流 | OutputStream | Writer |\n\n\n\n### IO 流体系\n\n| 分类              | 字节输入流              | 字节输出流               | 字符输入流            | 字符输出流             |\n| ----------------- | ----------------------- | ------------------------ | --------------------- | ---------------------- |\n| 抽象基类          | **InputStream**         | **OutputStream**         | **Reader**            | **Writer**             |\n| 访问文件 (节点流) | **FileInputStream**     | **FileOutputStream**     | **FileReader**        | **FileWriter**         |\n| 访问数组          | ByteArrayInputStream    | ByteArrayOutputStream    | CharArrayInputStream  | CharArrayOutputStream  |\n| 访问管道          | PipedInputStream        | PipedOutputStream        | PipedReader           | PipedWriter            |\n| 访问字符串        |                         |                          | StringReader          | StringWriter           |\n| 缓冲流            | **BufferedInputStream** | **BufferedOutputStream** | **BufferedReader**    | **BufferedWriter**     |\n| 转换流            |                         |                          | **InputStreamReader** | **OutputStreamWriter** |\n| 对象流            | **ObjectInputStream**   | **ObjectOutputStream**   |                       |                        |\n|                   | FilterInputStream       | FilterOutputStream       | FilterReader          | FilterWriter           |\n| 打印流            |                         | PrintStream              |                       | PrintWriter            |\n| 推回输入流        | PushbackInputStream     |                          | PushbackReader        |                        |\n| 特殊流            | DataInputStream         | DataOutputStream         |                       |                        |"
    },
];
